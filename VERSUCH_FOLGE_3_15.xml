Auf geht's
<FILE id="P01" inhalt="R von 1...n auf 0...(n-1) umstellen">
#
Read("PcgsOfR.txt");
R4:=function(V)#neu
  local i,R,V2;
  V2:=List(V);Add(V2,V2[1],1);Add(V2,V2[1],1);
  R:=[[0],[0,0],[1,1,1]];
  for i in [4..Size(V)+1] do Add(R,ListWithIdenticalEntries(i,0)); od;
  Add(R,V2);
  return R;
  end;

R:=R4([0,0]);P:=PcgsOfR(R);IdSmallGroup(P);
R:=R4([0,1]);P:=PcgsOfR(R);IdSmallGroup(P);
R:=R4([1,1]);P:=PcgsOfR(R);IdSmallGroup(P);
R:=R4([0,2]);P:=PcgsOfR(R);IdSmallGroup(P);
R:=R4([1,2]);P:=PcgsOfR(R);IdSmallGroup(P);
R:=R4([2,3]);P:=PcgsOfR(R);IdSmallGroup(P);

R:=R4([0,0,0,0,0,0]);P:=PcgsOfR(R);IdSmallGroup(P);
R:=R4([0,0,0,0,0,1]);P:=PcgsOfR(R);IdSmallGroup(P);
R:=R4([0,0,0,0,0,2]);P:=PcgsOfR(R);IdSmallGroup(P);
R:=R4([0,0,0,0,2,3]);P:=PcgsOfR(R);IdSmallGroup(P);
R:=R4([0,0,0,0,1,1]);P:=PcgsOfR(R);IdSmallGroup(P);
R:=R4([0,0,0,0,1,2]);P:=PcgsOfR(R);IdSmallGroup(P);
R:=R4([0,0,0,1,1,2]);P:=PcgsOfR(R);IdSmallGroup(P);
R:=R4([0,0,1,1,1,2]);P:=PcgsOfR(R);IdSmallGroup(P);
R:=R4([0,0,1,1,2,2]);P:=PcgsOfR(R);IdSmallGroup(P);
R:=R4([0,0,1,2,2,2]);P:=PcgsOfR(R);IdSmallGroup(P);
R:=R4([0,1,1,1,2,2]);P:=PcgsOfR(R);IdSmallGroup(P);
R:=R4([0,1,1,2,2,2]);P:=PcgsOfR(R);IdSmallGroup(P);
R:=R4([1,1,1,2,2,2]);P:=PcgsOfR(R);IdSmallGroup(P);
R:=R4([1,1,1,1,2,2]);P:=PcgsOfR(R);IdSmallGroup(P);
#Ergebnis: viele gleiche
  </FILE>

<FILE id="P02" inhalt="n=16 als 1:0">
Read("XSAMMEL.txt");
ClearProfile();
ERG:=[];XSAMMEL:=[];
IS:=[0,1];IS2:=[0,2];
for i1 in IS2 do 
  for i2 in IS2 do
    for i3 in IS do
      for i4 in IS do
        RT:=[i1+i3,i2+i4];
        Print("\n",RT);
        R:=R4(RT);
        G:=PcgsOfR(R);
        Print(IdSmallGroup(G),"\c");
        NEU:=RMAXSUCH(G);
        if NEU>0 then Add(ERG,RT); fi; 
        od;
      od;
    od;
  od;
ERG;
  </FILE>

<FILE id="P03" inhalt="n=16,32 als 1:0 mit ListX">
Read("XSAMMEL.txt");
ClearProfile();
FUN:=function(arg)#alt
  RT:=[];
  j:=Size(arg)/2;
  for i in [1..j] do
    Add(RT,arg[i]+arg[i+j]);
    od;
  Print("\n",RT);
  R:=R4(RT);
  G:=PcgsOfR(R);
  Print(IdSmallGroup(G),"\c");
  NEU:=RMAXSUCH(G);
  if NEU>0 then Add(ERG,RT); fi;
  return [];
  end;
 
ERG:=[];XSAMMEL:=[];
IS:=[0,1];IS2:=[0,2];
ListX(IS2,IS2,IS,IS,FUN);;ERG;
ListX(IS2,IS2,IS2,IS,IS,IS,FUN);;ERG;
ListX(IS2,IS2,IS2,IS2,IS,IS,IS,IS,FUN);;ERG;
[ [ 0, 0 ], [ 0, 1 ], [ 1, 1 ], [ 0, 2 ], [ 1, 2 ], [ 2, 3 ], 
  [ 0, 0, 0 ], [ 0, 1, 1 ], [ 0, 0, 2 ], [ 0, 1, 2 ], [ 1, 1, 2 ], 
  [ 0, 2, 0 ], [ 1, 2, 1 ], [ 2, 2, 2 ] ]
ok warum dauert das was schon drin ist so lange, das ist die momentane Schwachstelle
  ok mit RTT() jetzt ok
  </FILE>

<FILE id="P04" inhalt="RTT() als schnelles RMAXSUCH wenn schon drin, n=16,32,64">
Read("XSAMMEL.txt");
ClearProfile();
R:=R4([1,2]);P:=PcgsOfR(R);IdSmallGroup(P);
R:=R4([2,3]);P:=PcgsOfR(R);IdSmallGroup(P);
#muss ich ja so machen dass mit dem R gesucht wird und nicht G bilden
NEU:=RMAXSUCH(P);
NEU:=RMAXSUCH(P);#da soll schon bei 0 Schluss sein
#so, aus QY13 rausmach:
PL:=Reversed(GeneratorsOfGroup(P));

RTT:=function()#neu
  if HRES=[] then GR:=Group(P.1^0); else GR:=Group(HRES); fi;
  ri:=PL[S];
  Add(HRES,ri,1);HRESEXT[S]:=ri;
#  QY10(HRES,S,GR);#ob HRES wirklich ein pcgs ist, deshalb PL
  PNEU:=QY11(HRES,S);
  R[S]:=List(PNEU);
  HRESMERK:=List(HRES);
  n:=nn;ZR:=QY21(HRES,S,nn,ZEIGER,PNEU);;
  HRES:=List(ZR[1]);WEGLI[S]:=ZR[5];ZR3MERK:=ZR[3];
    S:=S+1;nn:=2*nn;ZEIGER:=ZR[2];;
  if ZR3MERK=-1 then return -10000; else
    if ZEIGER=[] then return 1; else return RTT()+1; fi;
    fi;
  end;

S:=1;nn:=1;HRES:=[];HRESEXT:=[];R:=[];WEGLI:=[];
ZEIGER:=XSAMMEL;;
NEU:=RTT();
inh:=1;
FUN:=function(arg)#neu
  RT:=[];
  j:=Size(arg)/2;
  for i in [1..j] do
    Add(RT,arg[i]+arg[i+j]);
    od;
  Print("\n",RT);
  R:=R4(RT);RSIZE:=Size(R);
  P:=PcgsOfR(R);
#  Print(IdSmallGroup(P),"\c");
PL:=Reversed(GeneratorsOfGroup(P));
S:=1;nn:=1;HRES:=[];HRESEXT:=[];R:=[];WEGLI:=[];
ZEIGER:=XSAMMEL;;
  NEU:=RTT();Print(NEU);
  if NEU<>RSIZE then inh:=inh+1;RMAXSUCH(P);Add(ERG,RT); fi;
  return [];
  end;

ClearProfile();
ERG:=[];XSAMMEL:=[];
IS:=[0,1];IS2:=[0,2];
ListX(IS2,IS2,IS,IS,FUN);;ERG;#16
ListX(IS2,IS2,IS2,IS,IS,IS,FUN);;ERG;#32
ListX(IS2,IS2,IS2,IS2,IS,IS,IS,IS,FUN);;ERG;#64
ListX(IS2,IS2,IS2,IS2,IS2,IS,IS,IS,IS,IS,FUN);;ERG;#128
ListX(IS2,IS2,IS2,IS2,IS2,IS2,IS,IS,IS,IS,IS,IS,FUN);;ERG;#256
ListX(IS2,IS2,IS2,IS2,IS2,IS2,IS2,IS,IS,IS,IS,IS,IS,IS,FUN);;ERG;#512
ListX(IS2,IS2,IS2,IS2,IS2,IS2,IS2,IS2,IS,IS,IS,IS,IS,IS,IS,IS,FUN);;ERG;#1024
XSAMMELVIEWER4(XSAMMEL);
DisplayProfile();
GasmanStatistics();

ok na, ganz ordentliches Ergebnis, reicht für heute: 3+3,2+6,3+11
ERG:=[ [ 0, 0 ], [ 0, 1 ], [ 1, 1 ], 
  [ 0, 2 ], [ 1, 2 ], [ 2, 3 ], 
  [ 0, 0, 0 ], [ 0, 1, 1 ], 
  [ 0, 0, 2 ], [ 0, 1, 2 ], [ 1, 1, 2 ], 
  [ 0, 2, 0 ], [ 1, 2, 1 ], [ 2, 2, 2 ], 
  [ 0, 0, 0, 0 ], [ 0, 0, 0, 1 ], [ 0, 1, 1, 1 ], 
  [ 0, 0, 0, 2 ], [ 0, 1, 1, 2 ], [ 0, 0, 2, 2 ], [ 0, 0, 2, 3 ], 
  [ 0, 1, 2, 2 ], [ 1, 1, 2, 2 ], [ 0, 2, 0, 0 ], [ 0, 2, 0, 1 ], 
  [ 1, 2, 1, 1 ], [ 2, 2, 2, 2 ], [ 2, 2, 2, 3 ], 
  [ 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 1 ], [ 0, 1, 1, 1, 1 ], 
  [ 0, 0, 0, 0, 2 ], [ 0, 0, 0, 1, 2 ], [ 0, 1, 1, 1, 2 ], [ 0, 0, 2, 2, 2 ], [ 0, 0, 2, 2, 3 ], 
  [ 0, 1, 2, 2, 2 ], [ 1, 1, 2, 2, 2 ], [ 0, 2, 0, 0, 0 ], [ 0, 2, 0, 0, 1 ], 
  [ 1, 2, 1, 1, 1 ], [ 2, 2, 2, 2, 2 ], [ 2, 2, 2, 2, 3 ],
  [ 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 1 ], [ 0, 1, 1, 1, 1, 1 ], 
  [ 0, 0, 0, 0, 0, 2 ], [ 0, 0, 0, 0, 1, 2 ], [ 0, 1, 1, 1, 1, 2 ],
  [ 0, 0, 2, 2, 2, 2 ], [ 0, 0, 2, 2, 2, 3 ],
  [ 0, 1, 2, 2, 2, 2 ], [ 1, 1, 2, 2, 2, 2 ], [ 0, 2, 0, 0, 0, 0 ],
  #weiter so dazu: 
  [ 0, 2, 0, 0, 0, 1 ], 
  [ 1, 2, 1, 1, 1, 1 ], [ 2, 2, 2, 2, 2, 2 ], [ 2, 2, 2, 2, 2, 3 ]
  ] ;
 
  [ 0, 0, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 0, 1 ], [ 0, 1, 1, 1, 1, 1 ], 
  [ 0, 0, 0, 0, 0, 2 ], [ 0, 0, 0, 0, 1, 2 ], [ 0, 1, 1, 1, 1, 2 ], [ 0, 0, 2, 2, 2, 2 ], [ 0, 0, 2, 2, 2, 3 ]
  [ 0, 1, 2, 2, 2, 2 ], [ 1, 1, 2, 2, 2, 2 ], [ 0, 2, 0, 0, 0, 0 ], ...dann >2G
#umgekehrt [1,0]
ClearProfile();
ERG:=[];XSAMMEL:=[];
IS:=[1,0];IS2:=[0,2];
[ [ 1, 1 ], [ 1, 0 ], [ 0, 0 ], [ 1, 3 ], [ 0, 3 ], [ 3, 2 ], 
  [ 1, 1, 1 ], [ 1, 0, 0 ], [ 1, 1, 3 ], [ 1, 0, 3 ], [ 0, 0, 3 ], 
  [ 1, 3, 1 ], [ 0, 3, 0 ], [ 3, 3, 3 ], [ 1, 1, 1, 1 ], [ 1, 1, 1, 0 ], 
  [ 1, 0, 0, 0 ], [ 1, 1, 1, 3 ], [ 1, 0, 0, 3 ], [ 1, 1, 3, 3 ], 
  [ 1, 1, 3, 2 ], [ 1, 0, 3, 3 ], [ 0, 0, 3, 3 ], [ 1, 3, 1, 1 ], 
  [ 1, 3, 1, 0 ], [ 0, 3, 0, 0 ], [ 3, 3, 3, 3 ], [ 3, 3, 3, 2 ] ]
[ [ 1, 1 ], [ 1, 0 ], [ 0, 0 ], [ 1, 3 ], [ 0, 3 ], [ 3, 2 ], [ 1, 1, 1 ],
  [ 1, 0, 0 ], [ 1, 1, 3 ], [ 1, 0, 3 ], [ 0, 0, 3 ], [ 1, 3, 1 ],
  [ 0, 3, 0 ], [ 3, 3, 3 ], [ 1, 1, 1, 1 ], [ 1, 1, 1, 0 ], [ 1, 0, 0, 0 ],
  [ 1, 1, 1, 3 ], [ 1, 0, 0, 3 ], [ 1, 1, 3, 3 ], [ 1, 1, 3, 2 ],
  [ 1, 0, 3, 3 ], [ 0, 0, 3, 3 ], [ 1, 3, 1, 1 ], [ 1, 3, 1, 0 ],
  [ 0, 3, 0, 0 ], [ 3, 3, 3, 3 ], [ 3, 3, 3, 2 ], [ 1, 1, 1, 1, 1 ],
  [ 1, 1, 1, 1, 0 ], [ 1, 0, 0, 0, 0 ], [ 1, 1, 1, 1, 3 ], [ 1, 1, 1, 0, 3 ],
  [ 1, 0, 0, 0, 3 ], [ 1, 1, 3, 3, 3 ], [ 1, 1, 3, 3, 2 ], [ 1, 0, 3, 3, 3 ],
  [ 0, 0, 3, 3, 3 ], [ 1, 3, 1, 1, 1 ], [ 1, 3, 1, 1, 0 ] ..... und dann bei [ 0, 3, 0, 0, 0 ] steckengelieben.
aber jetzt durch
[ [ 1, 1 ], [ 1, 0 ], [ 0, 0 ], [ 1, 3 ], [ 0, 3 ], [ 3, 2 ], [ 1, 1, 1 ], 
  [ 1, 0, 0 ], [ 1, 1, 3 ], [ 1, 0, 3 ], [ 0, 0, 3 ], [ 1, 3, 1 ], [ 0, 3, 0 ], [ 3, 3, 3 ], 
  [ 1, 1, 1, 1 ], [ 1, 1, 1, 0 ], [ 1, 0, 0, 0 ], [ 1, 1, 1, 3 ], [ 1, 0, 0, 3 ], [ 1, 1, 3, 3 ], 
  [ 1, 1, 3, 2 ], [ 1, 0, 3, 3 ], [ 0, 0, 3, 3 ], [ 1, 3, 1, 1 ], [ 1, 3, 1, 0 ], [ 0, 3, 0, 0 ], 
  [ 3, 3, 3, 3 ], [ 3, 3, 3, 2 ], [ 1, 1, 1, 1, 1 ], [ 1, 1, 1, 1, 0 ], [ 1, 0, 0, 0, 0 ], 
  [ 1, 1, 1, 1, 3 ], [ 1, 1, 1, 0, 3 ], [ 1, 0, 0, 0, 3 ], [ 1, 1, 3, 3, 3 ], [ 1, 1, 3, 3, 2 ], 
  [ 1, 0, 3, 3, 3 ], [ 0, 0, 3, 3, 3 ], [ 1, 3, 1, 1, 1 ], [ 1, 3, 1, 1, 0 ], [ 0, 3, 0, 0, 0 ], 
  [ 3, 3, 3, 3, 3 ], [ 3, 3, 3, 3, 2 ] ]
.. dauert auch alles zu lange, da war ich schon weiter (oder war das noch alt?)
.. danach kann ich auch die Sortierung innerhalb QY13 herausnehmen, das mit 1001 und so.
.. und auch ob sowas wie RTT() auch in QY13() rein muss.
.. und Diagonale auswerten
  </FILE>

<FILE id="P05" inhalt="Fehlersuch R:=R4([0,2,0,0])">
ERG:=[];XSAMMEL:=[];
R:=R4([0,2,0,0]);P:=PcgsOfR(R);RMAXSUCH(P);
ok aha, da hat die Umschaltung von IdSmallGroup auf inh nicht funktioniert
  .. muss ich später nochmal versuchen
ok dann gap anders starten, mit
#gap -g -g -s 2000000k -a 2000000k -m 2000000k -o 2000000k
#gap -g -s 1000000k -a 1000000k -m 1000000k -o 1000000k
ok hab jetzt auch den Wechsel der Sortierreihenfolge einfach mit return -RET
OK bringt aber auch nichts, also jetzt definitiv Adder weitermachen
  ok und der ist erstmal raus, mit deuticher Verbesserung
  ok da war doch tatsächlich was mit der Sortierung durcheinandergeraten,
    ok jetzt wieder durchgängig alles PMAX abwärts

außerdem
#DisplayProfile();ClearProfile();
#DisplayProfile();
#GasmanStatistics();
#GasmanLimits();
  </FILE>

<FILE id="P06" inhalt="wie hat das alles funktioniert">
XSAMMEL:=[];R:=R4([2,3]);P:=PcgsOfR(R);RMAXSUCH(P);XSAMMELVIEWER0(XSAMMEL);#16,2
XSAMMEL:=[];R:=R4([0,2]);P:=PcgsOfR(R);RMAXSUCH(P);XSAMMELVIEWER0(XSAMMEL);#16,3
XSAMMEL:=[];R:=R4([1,2]);P:=PcgsOfR(R);RMAXSUCH(P);XSAMMELVIEWER0(XSAMMEL);#16,4
#was schon so in XSAMMEL ist:
PARTZ:=0;PARTZAHL(XSAMMEL);PARTZ;#=Zeilenzahl bei XSAMMEL2
WEG:=[1,2,2,4];PART:=WEGEDISP(WEG,XSAMMEL,1);#führt zur Zeile mit <== [16,4]
ALLEWEGEDISP(PART,XSAMMEL,1);#ist aber noch nicht das erwartete, da muss noch mehr hinzu

#das hier findet RMAX aus dem WEGLI nach RMAXSUCH:
PART:=WEGEDISP(WEGLI,XSAMMEL,1);
RMAX:=[];PARTFIND(XSAMMEL,PART);RMAX;

#zwischendurch: sind gleich
XSAMMEL:=[];R:=R4([0,1,1,1,1,1]);P:=PcgsOfR(R);RMAXSUCH(P);XSAMMELVIEWER4(XSAMMEL);#16,4
R:=R4([1,1,1,1,1,1]);P:=PcgsOfR(R);
PL:=Reversed(GeneratorsOfGroup(P));
S:=1;nn:=1;HRES:=[];R:=[];WEGLI:=[];
ZEIGER:=XSAMMEL;;
NEU:=RTT();Print(NEU);
.. RTT testet nur Stufe S, das muss noch erweitert werden beim Abzweige nach oben

  </FILE>

<FILE id="P07" inhalt="mit PNEU abwärts ist XSAMMEL keine sortierte Liste mehr">
ok in QY09 wieder return -RET, aber jetzt auch in XMERK umdingsen.
ok in QY14 nach maximalem -P suchen
ok in QY15 XMERK sortieren
nö IsSortedList prüfen in QY08
ok in UMKEHRLIST aus -P neu P-1
ok PositionFirstComponent komplett durch PositionSorted ersetzen
los
T(64) macht noch keinen Unterschied
ClearProfile();
XSAMMEL:=[];R:=R4([0,1,1,1,1,1,1]);P:=PcgsOfR(R);RMAXSUCH(P);XSAMMELVIEWER4(XSAMMEL);#16,4
DisplayProfile();VZ;
  </FILE>

<FILE id="P08" inhalt="zu R die Diagonale bestimmen">
ok iter:=IteratorOfTuples( [0,1], 5 );
ok Anzahl der Einsen je Tupel bestimmen
ok wenn kleiner 3, dann Ergebnis aus Flat(R) holen
ok sonst Ergebnis aus 1. 2. und restlichen Einsen bilden 
ok schließlich Collected
ok funktioniert, es sind paar gleich

DIAG:=function(R)#neu
  local i,ii,j,k,S,RET,RF,X,Y,Z,POS1,POS2,PROD,GM,XP,YP,ZP;
#  PR:=function(X) return RET[IZUN(Reversed(X))+1]; end; 
  RET:=[];
  RF:=Flat(R);Add(RF,0,1);
#  Print("\n",RF);
  S:=Size(R);
  j:=1;
  GM:=[[0,1,2,3],[1,0,3,2],[2,3,0,1],[3,2,1,0]];
  for i in IteratorOfTuples( [0,1], S ) do
#    Print("\n",i,IZUN(Reversed(i)));
    if Sum(i)<3 then 
#      Print("<3");
      Add(RET,RF[j]);j:=j+1;
      else 
#        Print(">3");
        X:=0*i;Y:=List(X);Z:=List(i);
        POS1:=Position(Z,1);
        X[POS1]:=1;Z[POS1]:=0;XP:=2^(S-POS1);
        POS2:=Position(Z,1);
        Y[POS2]:=1;Z[POS2]:=0;YP:=2^(S-POS2);
#        ZP:=IZUN(Reversed(Z));
        ZP:=0;ii:=1;
        for POS3 in [S,S-1..1] do 
          if Z[POS3]=1 then ZP:=ZP+ii; fi;
          ii:=ii+ii;
          od;          
#        Print("\n  ",X);
#        Print("\n  ",Y);
#        Print("\n  ",Z);
#        PROD:=PR(X)+PR(Y)+PR(Z)+PR(X+Y)+PR(X+Z)+PR(Y+Z);
#if PR(X)<>RET[XP+1] then Error(XP); fi;
        PROD:=GM[RET[XP+1]+1][RET[YP+1]+1];
        PROD:=GM[PROD+1][RET[ZP+1]+1];
        PROD:=GM[PROD+1][RET[XP+YP+1]+1];
        PROD:=GM[PROD+1][RET[XP+ZP+1]+1];
        PROD:=GM[PROD+1][RET[YP+ZP+1]+1];
#        Print(PROD);
        Add(RET,PROD);
#        Print("\n  ",RET);
        fi;
    od;
  return RET;
  end;

R:=R4([0,0]);;D:=DIAG(R);;Collected(D);
R:=R4([0,1]);;D:=DIAG(R);;Collected(D);
R:=R4([1,1]);;D:=DIAG(R);;Collected(D);

for i in ERG do Print("\n",i,Collected(DIAG(R4(i)))); od;

[ 0, 0, 0, 0, 0 ][ [ 0, 96 ], [ 1, 32 ] ]
[ 0, 0, 0, 0, 1 ][ [ 0, 80 ], [ 1, 48 ] ]
[ 0, 1, 1, 1, 1 ][ [ 0, 64 ], [ 1, 64 ] ]
[ 0, 1, 2, 2, 2 ][ [ 0, 64 ], [ 1, 32 ], [ 2, 32 ] ]
[ 1, 1, 2, 2, 2 ][ [ 0, 48 ], [ 1, 48 ], [ 2, 16 ], [ 3, 16 ] ]=
[ 1, 2, 1, 1, 1 ][ [ 0, 48 ], [ 1, 48 ], [ 2, 16 ], [ 3, 16 ] ]=
[ 2, 2, 2, 2, 2 ][ [ 0, 48 ], [ 1, 16 ], [ 2, 48 ], [ 3, 16 ] ]=
[ 2, 2, 2, 2, 3 ][ [ 0, 48 ], [ 1, 16 ], [ 2, 32 ], [ 3, 32 ] ]
[ 0, 1, 1, 1, 2 ][ [ 0, 56 ], [ 1, 40 ], [ 2, 24 ], [ 3, 8 ] ]
[ 0, 0, 0, 1, 2 ][ [ 0, 64 ], [ 1, 32 ], [ 2, 16 ], [ 3, 16 ] ]=
[ 0, 0, 2, 2, 3 ][ [ 0, 64 ], [ 1, 32 ], [ 2, 16 ], [ 3, 16 ] ]=
[ 0, 2, 0, 0, 1 ][ [ 0, 64 ], [ 1, 32 ], [ 2, 16 ], [ 3, 16 ] ]=
[ 0, 0, 0, 0, 2 ][ [ 0, 72 ], [ 1, 24 ], [ 2, 24 ], [ 3, 8 ] ]
[ 0, 0, 2, 2, 2 ][ [ 0, 80 ], [ 1, 16 ], [ 2, 16 ], [ 3, 16 ] ]=
[ 0, 2, 0, 0, 0 ][ [ 0, 80 ], [ 1, 16 ], [ 2, 16 ], [ 3, 16 ] ]=
[ 0, 0, 0, 0, 0, 0 ][ [ 0, 192 ], [ 1, 64 ] ]
[ 0, 0, 0, 0, 0, 1 ][ [ 0, 160 ], [ 1, 96 ] ]
[ 0, 1, 1, 1, 1, 1 ][ [ 0, 128 ], [ 1, 128 ] ]
[ 0, 1, 2, 2, 2, 2 ][ [ 0, 128 ], [ 1, 64 ], [ 2, 64 ] ]
[ 1, 1, 2, 2, 2, 2 ][ [ 0, 96 ], [ 1, 96 ], [ 2, 32 ], [ 3, 32 ] ]=
[ 1, 2, 1, 1, 1, 1 ][ [ 0, 96 ], [ 1, 96 ], [ 2, 32 ], [ 3, 32 ] ]=
[ 2, 2, 2, 2, 2, 2 ][ [ 0, 96 ], [ 1, 32 ], [ 2, 96 ], [ 3, 32 ] ]
[ 2, 2, 2, 2, 2, 3 ][ [ 0, 96 ], [ 1, 32 ], [ 2, 64 ], [ 3, 64 ] ]
[ 0, 1, 1, 1, 1, 2 ][ [ 0, 112 ], [ 1, 80 ], [ 2, 48 ], [ 3, 16 ] ]
[ 0, 0, 0, 0, 1, 2 ][ [ 0, 128 ], [ 1, 64 ], [ 2, 32 ], [ 3, 32 ] ]=
[ 0, 0, 2, 2, 2, 3 ][ [ 0, 128 ], [ 1, 64 ], [ 2, 32 ], [ 3, 32 ] ]=
[ 0, 2, 0, 0, 0, 1 ][ [ 0, 128 ], [ 1, 64 ], [ 2, 32 ], [ 3, 32 ] ]=
[ 0, 0, 0, 0, 0, 2 ][ [ 0, 144 ], [ 1, 48 ], [ 2, 48 ], [ 3, 16 ] ]
[ 0, 0, 2, 2, 2, 2 ][ [ 0, 160 ], [ 1, 32 ], [ 2, 32 ], [ 3, 32 ] ]=
[ 0, 2, 0, 0, 0, 0 ][ [ 0, 160 ], [ 1, 32 ], [ 2, 32 ], [ 3, 32 ] ]=

  </FILE>

<FILE id="P09" inhalt="zu allen R die Diagonale bestimmen">
ok jetzt alle R durchlaufen lassen
los

FUND:=function(arg)#neu
  RT:=[];
  j:=Size(arg)/2;
  for i in [1..j] do
    Add(RT,arg[i]+arg[i+j]);
    od;
  R:=R4(RT);D:=DIAG(R);;C:=Collected(D);#Print(C);
  D:=List(C{[2..Size(C)]},i->i[2]);D:=SortedList(D);Add(D,C[1][2],1);
  if not D in ERGD then Add(ERG,[RT,D]);Add(ERGD,D);Print("\n",RT,D); fi;
# if NEU<>RSIZE then inh:=inh+1;RMAXSUCH(P);Add(ERG,RT); fi;
  return [];
  end;

ClearProfile();
IS:=[0,1];IS2:=[0,2];
ERG:=[];ERGD:=[];ListX(IS2,IS2,IS,IS,FUND);;;Size(ERG);#16
ERG:=[];ERGD:=[];ListX(IS2,IS2,IS2,IS,IS,IS,FUND);;;Size(ERG);#32
ERG:=[];ERGD:=[];ListX(IS2,IS2,IS2,IS2,IS,IS,IS,IS,FUND);;;Size(ERG);#64
ERG:=[];ERGD:=[];ListX(IS2,IS2,IS2,IS2,IS2,IS,IS,IS,IS,IS,FUND);;;Size(ERG);#128
ERG:=[];ERGD:=[];ListX(IS2,IS2,IS2,IS2,IS2,IS2,IS,IS,IS,IS,IS,IS,FUND);;;Size(ERG);#256
ERG:=[];ERGD:=[];ListX(IS2,IS2,IS2,IS2,IS2,IS2,IS2,IS,IS,IS,IS,IS,IS,IS,FUND);;;Size(ERG);#512
ERG:=[];ERGD:=[];ListX(IS2,IS2,IS2,IS2,IS2,IS2,IS2,IS2,IS,IS,IS,IS,IS,IS,IS,IS,FUND);;;Size(ERG);#1024
ERG:=[];ERGD:=[];ListX(IS2,IS2,IS2,IS2,IS2,IS2,IS2,IS2,IS2,IS,IS,IS,IS,IS,IS,IS,IS,IS,FUND);;;Size(ERG);#2048

[ 0, 0 ][ 12, 4 ]
[ 0, 1 ][ 8, 8 ]
[ 1, 1 ][ 4, 12 ]
[ 0, 2 ][ 8, 4, 4 ]
[ 1, 2 ][ 4, 4, 8 ]
[ 2, 3 ][ 4, 4, 4, 4 ]6
[ 0, 0, 0 ][ 24, 8 ]
[ 0, 1, 1 ][ 16, 16 ]
[ 0, 0, 2 ][ 20, 4, 4, 4 ]
[ 0, 1, 2 ][ 16, 8, 8 ]
[ 1, 1, 2 ][ 12, 4, 4, 12 ]5
[ 0, 0, 0, 0 ][ 48, 16 ]
[ 0, 0, 0, 1 ][ 40, 24 ]
[ 0, 1, 1, 1 ][ 32, 32 ]
[ 0, 0, 0, 2 ][ 36, 4, 12, 12 ]
[ 0, 1, 1, 2 ][ 28, 4, 12, 20 ]
[ 0, 0, 2, 2 ][ 40, 8, 8, 8 ]
[ 0, 0, 2, 3 ][ 32, 8, 8, 16 ]
[ 0, 1, 2, 2 ][ 32, 16, 16 ]
[ 1, 1, 2, 2 ][ 24, 8, 8, 24 ]
[ 2, 2, 2, 3 ][ 24, 8, 16, 16 ]10
[ 0, 0, 0, 0, 0 ][ 96, 32 ]
[ 0, 0, 0, 0, 1 ][ 80, 48 ]
[ 0, 1, 1, 1, 1 ][ 64, 64 ]
[ 0, 0, 0, 0, 2 ][ 72, 8, 24, 24 ]
[ 0, 0, 0, 1, 2 ][ 64, 16, 16, 32 ]
[ 0, 1, 1, 1, 2 ][ 56, 8, 24, 40 ]
[ 0, 0, 2, 2, 2 ][ 80, 16, 16, 16 ]
[ 0, 1, 2, 2, 2 ][ 64, 32, 32 ]
[ 1, 1, 2, 2, 2 ][ 48, 16, 16, 48 ]
[ 2, 2, 2, 2, 3 ][ 48, 16, 32, 32 ]10
[ 0, 0, 0, 0, 0, 0 ][ 192, 64 ]
[ 0, 0, 0, 0, 0, 1 ][ 160, 96 ]
[ 0, 1, 1, 1, 1, 1 ][ 128, 128 ]
[ 0, 0, 0, 0, 0, 2 ][ 144, 16, 48, 48 ]
[ 0, 0, 0, 0, 1, 2 ][ 128, 32, 32, 64 ]
[ 0, 1, 1, 1, 1, 2 ][ 112, 16, 48, 80 ]
[ 0, 0, 2, 2, 2, 2 ][ 160, 32, 32, 32 ]
[ 0, 1, 2, 2, 2, 2 ][ 128, 64, 64 ]
[ 1, 1, 2, 2, 2, 2 ][ 96, 32, 32, 96 ]
[ 2, 2, 2, 2, 2, 3 ][ 96, 32, 64, 64 ]10
[ 0, 0, 0, 0, 0, 0, 0 ][ 384, 128 ]
[ 0, 0, 0, 0, 0, 0, 1 ][ 320, 192 ]
[ 0, 1, 1, 1, 1, 1, 1 ][ 256, 256 ]
[ 0, 0, 0, 0, 0, 0, 2 ][ 288, 32, 96, 96 ]
[ 0, 0, 0, 0, 0, 1, 2 ][ 256, 64, 64, 128 ]
[ 0, 1, 1, 1, 1, 1, 2 ][ 224, 32, 96, 160 ]
[ 0, 0, 2, 2, 2, 2, 2 ][ 320, 64, 64, 64 ]
[ 0, 1, 2, 2, 2, 2, 2 ][ 256, 128, 128 ]
[ 1, 1, 2, 2, 2, 2, 2 ][ 192, 64, 64, 192 ]
[ 2, 2, 2, 2, 2, 2, 3 ][ 192, 64, 128, 128 ]10
[ 0, 0, 0, 0, 0, 0, 0, 0 ][ 768, 256 ]
[ 0, 0, 0, 0, 0, 0, 0, 1 ][ 640, 384 ]
[ 0, 1, 1, 1, 1, 1, 1, 1 ][ 512, 512 ]
[ 0, 0, 0, 0, 0, 0, 0, 2 ][ 576, 64, 192, 192 ]
[ 0, 0, 0, 0, 0, 0, 1, 2 ][ 512, 128, 128, 256 ]
[ 0, 1, 1, 1, 1, 1, 1, 2 ][ 448, 64, 192, 320 ]
[ 0, 0, 2, 2, 2, 2, 2, 2 ][ 640, 128, 128, 128 ]
[ 0, 1, 2, 2, 2, 2, 2, 2 ][ 512, 256, 256 ]
[ 1, 1, 2, 2, 2, 2, 2, 2 ][ 384, 128, 128, 384 ]
[ 2, 2, 2, 2, 2, 2, 2, 3 ][ 384, 128, 256, 256 ]10

  </FILE>

<FILE id="P10" inhalt="Jetzt die R zu den Abzweigen bestimmen">
.. R4 um das innere R erweitern
.. eine Ausgangsliste für die inneren R
.. erstmal nur ein Stockwerk, deshalb geht dafür die Kurzform mit R4 und ERG.
.. deshalb von ERG zu ERG[S] übergehen
.. und in 

for RK in ERG[S] do R:=R4(RK);  

R5:=function(R,V)#neu
  local i,V2;
  V2:=List(V);Add(V2,V2[1],1);Add(V2,V2[1],1);
  Add(R,V2);
  return R;
  end;

R5(R4([0,1]),[0,0,0]);

ERGS:=[];

FUN5:=function(arg)#neu
  RT:=[];
  j:=Size(arg)/2;
  for i in [1..j] do
    Add(RT,arg[i]+arg[i+j]);
    od;
  Print("\n",RT);
  R:=R5(R4(RI),RT);RSIZE:=Size(R);
  P:=PcgsOfR(R);
#  Print(IdSmallGroup(P),"\c");
PL:=Reversed(GeneratorsOfGroup(P));
S:=1;nn:=1;HRES:=[];HRESEXT:=[];R:=[];WEGLI:=[];
ZEIGER:=XSAMMEL;;
  NEU:=RTT();Print(NEU);
  if NEU<>RSIZE then 
    inh:=inh+1;
    RMAXSUCH(P);
    S:=Size(R);
    Add(ERGS[S],[RI,RT]);
    fi;
  return [];
  end;

ClearProfile();
ERGS:=[];XSAMMEL:=[];
IS:=[0,1];IS2:=[0,2];
ERG:=[];ListX(IS2,IS2,IS,IS,FUN);;ERGS[4]:=ERG;;ERGS;#16;ERGS
ERG:=[];ListX(IS2,IS2,IS2,IS,IS,IS,FUN);;ERGS[5]:=ERG;;ERGS;#32
for RI in ERGS[4] do
  Print("\n*******************",RI);
  ListX(IS2,IS2,IS2,IS,IS,IS,FUN5);
  od;ERGS;
ERG:=[];ListX(IS2,IS2,IS2,IS2,IS,IS,IS,IS,FUN);;ERGS[6]:=ERG;;ERGS;#64
for RI in ERGS[5] do
  if IsInt(RI[1]) then
    Print("\n*******************",RI);
    ListX(IS2,IS2,IS2,IS,IS,IS,FUN5);
    fi;
  od;ERGS;
ERG:=[];ListX(IS2,IS2,IS2,IS2,IS2,IS,IS,IS,IS,IS,FUN);;ERGS[6]:=ERG;;ERGS;#128

[ ,,, [ [ 0, 0 ], [ 0, 1 ], [ 1, 1 ], [ 0, 2 ], [ 1, 2 ], [ 2, 3 ] ], 
  [ [ 0, 0, 0 ], [ 0, 1, 1 ], [ 0, 0, 2 ], [ 0, 1, 2 ], [ 1, 1, 2 ], 
      [ 0, 2, 0 ], [ 1, 2, 1 ], [ 2, 2, 2 ], [ [ 0, 1 ], [ 0, 1, 0 ] ], 
      [ [ 0, 1 ], [ 1, 1, 1 ] ], [ [ 0, 1 ], [ 1, 1, 2 ] ], 
      [ [ 0, 1 ], [ 0, 2, 0 ] ], [ [ 0, 1 ], [ 1, 2, 1 ] ], 
      [ [ 0, 1 ], [ 2, 2, 3 ] ], [ [ 0, 1 ], [ 2, 3, 2 ] ], 
      [ [ 1, 1 ], [ 1, 1, 2 ] ], [ [ 1, 1 ], [ 2, 2, 2 ] ], 
      [ [ 0, 2 ], [ 1, 2, 3 ] ], [ [ 1, 2 ], [ 1, 2, 3 ] ] ] ]

  </FILE>


<NACHLAD> #oben ändern
R4:=function(V)
  local i,R,V2;
  V2:=List(V);Add(V2,V2[1],1);Add(V2,V2[1],1);
  R:=[[0],[0,0],[1,1,1]];
  for i in [4..Size(V)+1] do Add(R,ListWithIdenticalEntries(i,0)); od;
  Add(R,V2);
  return R;
  end;

RTT:=function()
  if HRES=[] then GR:=Group(P.1^0); else GR:=Group(HRES); fi;
  ri:=PL[S];
  Add(HRES,ri,1);HRESEXT[S]:=ri;
#  QY10(HRES,S,GR);#ob HRES wirklich ein pcgs ist, deshalb PL
  PNEU:=QY11(HRES,S);
  R[S]:=List(PNEU);
  n:=nn;ZR:=QY21(HRES,S,nn,ZEIGER,PNEU);;
  HRES:=List(ZR[1]);ZR3MERK:=ZR[3];
    S:=S+1;nn:=2*nn;ZEIGER:=ZR[2];;
  if ZR3MERK=-1 then return -10000; else
    if ZEIGER=[] then return 1; else return RTT()+1; fi;
    fi;
  end;

FUN:=function(arg)
  RT:=[];
  j:=Size(arg)/2;
  for i in [1..j] do
    Add(RT,arg[i]+arg[i+j]);
    od;
  Print("\n",RT);
  R:=R4(RT);RSIZE:=Size(R);
  P:=PcgsOfR(R);
#  Print(IdSmallGroup(P),"\c");
PL:=Reversed(GeneratorsOfGroup(P));
S:=1;nn:=1;HRES:=[];HRESEXT:=[];R:=[];WEGLI:=[];
ZEIGER:=XSAMMEL;;
  NEU:=RTT();Print(NEU);
  if NEU<>RSIZE then inh:=inh+1;RMAXSUCH(P);Add(ERG,RT); fi;
  return [];
  end;

DIAG:=function(R)#neu
  local i,ii,j,k,S,RET,RF,X,Y,Z,POS1,POS2,PROD,GM,XP,YP,ZP;
#  PR:=function(X) return RET[IZUN(Reversed(X))+1]; end; 
  RET:=[];
  RF:=Flat(R);Add(RF,0,1);
#  Print("\n",RF);
  S:=Size(R);
  j:=1;
  GM:=[[0,1,2,3],[1,0,3,2],[2,3,0,1],[3,2,1,0]];
  for i in IteratorOfTuples( [0,1], S ) do
#    Print("\n",i,IZUN(Reversed(i)));
    if Sum(i)<3 then 
#      Print("<3");
      Add(RET,RF[j]);j:=j+1;
      else 
#        Print(">3");
        X:=0*i;Y:=List(X);Z:=List(i);
        POS1:=Position(Z,1);
        X[POS1]:=1;Z[POS1]:=0;XP:=2^(S-POS1);
        POS2:=Position(Z,1);
        Y[POS2]:=1;Z[POS2]:=0;YP:=2^(S-POS2);
#        ZP:=IZUN(Reversed(Z));
        ZP:=0;ii:=1;
        for POS3 in [S,S-1..1] do 
          if Z[POS3]=1 then ZP:=ZP+ii; fi;
          ii:=ii+ii;
          od;          
#        Print("\n  ",X);
#        Print("\n  ",Y);
#        Print("\n  ",Z);
#        PROD:=PR(X)+PR(Y)+PR(Z)+PR(X+Y)+PR(X+Z)+PR(Y+Z);
#if PR(X)<>RET[XP+1] then Error(XP); fi;
        PROD:=GM[RET[XP+1]+1][RET[YP+1]+1];
        PROD:=GM[PROD+1][RET[ZP+1]+1];
        PROD:=GM[PROD+1][RET[XP+YP+1]+1];
        PROD:=GM[PROD+1][RET[XP+ZP+1]+1];
        PROD:=GM[PROD+1][RET[YP+ZP+1]+1];
#        Print(PROD);
        Add(RET,PROD);
#        Print("\n  ",RET);
        fi;
    od;
  return RET;
  end;
  
FUND:=function(arg)#neu
  RT:=[];
  j:=Size(arg)/2;
  for i in [1..j] do
    Add(RT,arg[i]+arg[i+j]);
    od;
  R:=R4(RT);D:=DIAG(R);;C:=Collected(D);#Print(C);
  D:=List(C{[2..Size(C)]},i->i[2]);D:=SortedList(D);Add(D,C[1][2],1);
  if not D in ERGD then Add(ERG,[RT,D]);Add(ERGD,D);Print("\n",RT,D); fi;
# if NEU<>RSIZE then inh:=inh+1;RMAXSUCH(P);Add(ERG,RT); fi;
  return [];
  end;
  </NACHLAD>

gap> DisplayProfile();#Referenz 128 jetzt komplett ohne PositionFirstComponent
  count  self/ms  chld/ms  stor/kb  chld/kb  package  function
   1962        1      203       76    39405           PcgsByPcSequenceNCMI
   2102        1      241       82    40867           PcgsByPcSequenceNC15
 715188      939        3   161906        0           DEEP_COPY_OBJ
 664872     1014       22    18180        0  GAP      PositionSorted
 332436      299     1019    18180    18180           PositionFirstComponentRepariert
 331385      362     1315    15533    36245           QY08
   2234      970     1269     5046    59742           XMISCH
  19435     1598     1818      911        9           XLEER
 441656     3646        8   232302        0  GAP      Group
  22939     3678     2555   324108    77871           XFUELL
 393744     7087     1912   894860   121754           QY10
   1051     9039        1      184      236           Adder
109593*    12634       71   818731        0           Commu
  77967       71    13666     3045  1850094           PcgsByPcSequenceNC07
8452912    24864        0  5515198        0           IZUN
 210267    31298        0  3437698        0  (oprt.)  RightTransversal
109952*    31514        0  5715812        0           QY09
 329213      278    37956    12859  5743027           PcgsByPcSequenceNC11
169675*    40150        0  4909587        0           NZUI
 329213     4423    49641   434122  7740059           QY11
9910155    73257       68   755049        0  (oprt.)  Size
1188069    47772 <-    16   708428        0  (oprt.)  Size
 330264     4635    82442   373473  8689650           QY21
 601925      556    92094    23512  122007*           PcgsByPcSequenceNC14
524472*   104108        0  7754008        0  (oprt.)  PcElementByExponentsNC
 746464      827   104265    29158  146440*           PcgsByPcSequenceNC12
199927*   141173        0  150012*        0  (oprt.)  ExponentsOfPcElement
 111854   136546    22756  1173109  2423687           WEGEVERGLEICHER
   1051   111572    69166   769530   206209           QY15
   1051    25156   170952  1548182  203355*           QY14
1760657   248528        0  345400*        0  (oprt.)  PcgsByPcSequenceNC
 111854    33124   250634  4467574  112055*           QY07
  52925    38206   261849  2413734  348740*           QY12
 210267     6867  1081807   977203  909743*           QY13
         1098421           923442*                    TOTAL
alle <- Markierung sind aktuelle Verbesserungen, Rest nicht mit aktualisiert