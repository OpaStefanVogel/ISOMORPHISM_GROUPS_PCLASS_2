#Read("DA_LEGST_DICH_NIEDER.txt");
#funktioniert hat Zeile 604-616, danach neues

SAGE:=true;
dmax:=10;
#dmax:=12;

XORMAT:=[[1]];
for i in [1..dmax] do
  n2:=2^(i-1);
  for j in [1..n2] do
    XORMAT[j+n2]:=[];
    for k in [1..n2] do
      XORMAT[j][k+n2]:=XORMAT[j][k]+n2;
      XORMAT[j+n2][k+n2]:=XORMAT[j][k];
      XORMAT[j+n2][k]:=XORMAT[j][k]+n2;
      od; od; od;
#---------#
Diagonale:=function(G,flag)
  local HRES,i,j,D,DD,DDD,RET,RA,PC;
  RA:=RankPGroup(G);
  PC:=Pcgs(G);
  HRES:=Reversed(PC{[1..RA]});#Print(RA,PC,HRES);
  D:=[];
  for i in [1..Size(HRES)] do
    Add(D,HRES[i]);
    for j in [1..Size(D)-1] do
      Add(D,HRES[i]*D[j]);
      od;
    od;
  DDD:=List(D);
  DD:=List(D,i->i^2);
  HRES:=MinimalGeneratingSet(Group(DD));
  D:=[];
  for i in [1..Size(HRES)] do
    Add(D,HRES[i]);
    for j in [1..Size(D)-1] do
      Add(D,D[j]*HRES[i]);
      od;
    od;
  Add(D,D[1]^0,1); Add(DDD,D[1]^0,1);
  RET:=List(DD,i->Position(D,i)-1);
  if flag=1 then RET:=DDD; fi;
  return RET;
  end;

Diagonale(SmallGroup(4,1),0);
Diagonale(SmallGroup(8,2),0);
Diagonale(SmallGroup(16,3),0);
Diagonale(SmallGroup(256,55750),1);

COMPDIAG6E:=function(dd,D,flag)#neu
  local i,j,k,l,SD,ORBZU,MARK,NMARK,STUFE;
  SD:=Size(D);
  ORBZU:=[]; STUFE:=1;
  ORBZU[STUFE]:=List(D);
  ORBZU[STUFE][1]:=-1;
  repeat
    if flag=88 then Print("\n",ORBZU); fi;
    Print("#",Size(Collected(ORBZU[STUFE])),"\c");
    MARK:=[];
    for i in [1..SD] do
      MARK[i]:=[-1];
      for j in [1..SD] do 
        MARK[i][j]:=[
          ORBZU[STUFE][i],
          ORBZU[STUFE][j],
          ORBZU[STUFE][XORMAT[j][i]]];
        od;
      MARK[i]:=Collected(MARK[i]{[1..SD]});
      od;
    STUFE:=STUFE+1;
    ORBZU[STUFE]:=[];
    for i in [1..SD] do for j in [i,i-1..1] do
      if MARK[i]=MARK[j] and ORBZU[STUFE-1][i]=ORBZU[STUFE-1][j] then ORBZU[STUFE][i]:=j; fi; od; od;
    until ORBZU[STUFE]=ORBZU[STUFE-1];  
  return ORBZU[STUFE];
  end;

COMPDIAG7E:=function(D)
  local i,j,SD,ORBZU,ORBZUMERK,MARK;
  SD:=Size(D); ORBZU:=List(D);
  repeat
    MARK:=[];
    for i in [1..SD] do
      MARK[i]:=[];
      for j in [1..SD] do MARK[i][j]:=[ORBZU[j],ORBZU[XORMAT[j][i]]]; od;
      MARK[i]:=Collected(MARK[i]);
      od;
    ORBZUMERK:=ORBZU; ORBZU:=[1];
    for i in [2..SD] do for j in [i,i-1..2] do
      if MARK[i]=MARK[j] and ORBZUMERK[i]=ORBZUMERK[j] then ORBZU[i]:=j; fi; od; od;
    until ORBZU=ORBZUMERK;  
  return ORBZU;
  end;

RMINVORTEST:=function(D)
  local SD,S,STUFE,LRES,LNEU,V,VNEU,VARIANTEN,NEUE_VARIANTEN,RR,RMIN,RNEU,
  HRES,LD,ORBZU,ORBS,ONEU;
  SD:=Size(D); S:=LogInt(SD,2); STUFE:=0; RMIN:=[];
  ORBZU:=COMPDIAG6E(S,D,0);
  VARIANTEN:=[rec(LD:=[],HRES:=[],LRES:=[1])];
  for STUFE in [1..S] do
    NEUE_VARIANTEN:=[];
    RNEU:=[9999];
    for V in VARIANTEN do
      HRES:=V.HRES;LRES:=V.LRES;LD:=V.LD;
      ORBS:=[];
      for i in [2..SD] do if not IsBound(LD[i]) then
        RR:=[D[i]];
        for j in HRES do Add(RR,D[XORMAT[i][j]]); od;
        if RR<RNEU then NEUE_VARIANTEN:=[]; RNEU:=RR; fi;
        if RR=RNEU then
          LNEU:=List(LRES,j->XORMAT[i][j]);
          ONEU:=List(LNEU,j->ORBZU[j]);
          if not (ONEU in ORBS) then
            Add(ORBS,ONEU);
            VNEU:=StructuralCopy(V);
            Add(VNEU.HRES,i);
            VNEU.LRES:=Concatenation(LRES,LNEU);
            for i in LNEU do VNEU.LD[i]:=STUFE; od;
            Add(NEUE_VARIANTEN,VNEU);
            fi;
          fi;
        fi; od;
      od;
    VARIANTEN:=NEUE_VARIANTEN;
    Add(RMIN,RNEU);
    od;
  return [RMIN,VARIANTEN];
  end;

ALPHA:=[0];#global weil von DNEU veraendert
BETA:=[0];

DNEU:=function(d)
  local dneu,i;
  if not IsBound(ALPHA[d+1]) then
    dneu:=Size(BETA);
    for i in [dneu,dneu-1..1] do Add(BETA,XORMAT[d+1][BETA[i]+1]-1); od;
    for i in [1..dneu] do ALPHA[BETA[dneu+i]+1]:=dneu+i-1; od;
    fi;
  dneu:=ALPHA[d+1];
  return dneu;
  end;

DNEU(2);ALPHA;BETA;
DNEU(7);ALPHA;BETA;
DNEU(6);ALPHA;BETA;

RMINSUCH:=function(D)
  local SD,S,STUFE,LRES,LNEU,V,VNEU,VARIANTEN,NEUE_VARIANTEN,RR,RMIN,RNEU,
  HRES,KRES,LD,ORBZU,ORBS,ONEU;
  SD:=Size(D); S:=LogInt(SD,2); STUFE:=0; RMIN:=[];
  #ORBZU:=COMPDIAG6E(S,D,0);
  ORBZU:=COMPDIAG7E(D);
  VARIANTEN:=[rec(LD:=[],HRES:=[],LRES:=[1],ALPHA:=[0],BETA:=[0])];
  for STUFE in [1..S] do 
    #Print("\nSTUFE=",STUFE);
    NEUE_VARIANTEN:=[];
    RNEU:=[0];
    for V in VARIANTEN do
      HRES:=V.HRES;LRES:=V.LRES;LD:=V.LD;
      ORBS:=[];
      for i in [2..SD] do if not IsBound(LD[i]) then
        ALPHA:=List(V.ALPHA);BETA:=List(V.BETA);
        KRES:=[i];
        for j in HRES do Add(KRES,XORMAT[i][j]); od;
        RR:=List(KRES,i->DNEU(D[i]));
        if RR>RNEU then NEUE_VARIANTEN:=[]; RNEU:=RR; fi;#max geht schneller als min
        if RR=RNEU then
          LNEU:=List(LRES,j->XORMAT[i][j]);
          ONEU:=List(LNEU,j->ORBZU[j]);#Print("O");
          if not (ONEU in ORBS) then
            Add(ORBS,ONEU);
            VNEU:=StructuralCopy(V);
            Add(VNEU.HRES,i);
            VNEU.LRES:=Concatenation(LRES,LNEU);
            for i in LNEU do VNEU.LD[i]:=STUFE; od;
            VNEU.ALPHA:=ALPHA; VNEU.BETA:=List(BETA);
            Add(NEUE_VARIANTEN,VNEU);
            fi;
          #Print("P");
          fi;
        fi; od;
      od;
    VARIANTEN:=NEUE_VARIANTEN;
    Add(RMIN,RNEU);
    #Print(", VARIANTEN=",Size(VARIANTEN));
    od;
  return [RMIN,VARIANTEN];
  end;


#---------#

ERWIND:=[];
j:=1;k:=1;S:=dmax;
for i in IteratorOfTuples( [0,1], S ) do
   if not SAGE then Print("."); fi;
#  Print("\n",i);
  if 3>Sum(i) then 
    ERWIND[k]:=j;j:=j+1;k:=k+1;
    else
      XL:=0*i;YL:=List(XL);ZL:=List(i);
      POS1:=Position(ZL,1);
      XL[POS1]:=1;ZL[POS1]:=0;XP:=2^(S-POS1);
      POS2:=Position(ZL,1);
      YL[POS2]:=1;ZL[POS2]:=0;YP:=2^(S-POS2);
      ZP:=0;ii:=1;
      for POS3 in [S,S-1..1] do 
        if ZL[POS3]=1 then ZP:=ZP+ii; fi;
        ii:=ii+ii;
        od;          
      ERWIND[k]:=[XP+1,YP+1,ZP+1,XP+YP+1,XP+ZP+1,YP+ZP+1];
      k:=k+1;
      fi;
#  Print(ERWIND[k-1]);
  od;

DIAG:=function(R)#neu
  local i,S,T,RET,RF,PROD,GM,XP,YP,ZP,XPYP,XPZP,YPZP;
#  PR:=function(X) return RET[IZUN(Reversed(X))+1]; end; 
  RET:=[];
  RF:=Flat(R);Add(RF,0,1);
#  Print("\n",RF);
  S:=Size(R);T:=2^S;RET:=EmptyPlist(T);
  GM:=[[0,1,2,3],[1,0,3,2],[2,3,0,1],[3,2,1,0]];
  for i in [1..T] do
    if IsInt(ERWIND[i]) then
      RET[i]:=RF[ERWIND[i]];
      else
        XP:=ERWIND[i][1];
        YP:=ERWIND[i][2];
        ZP:=ERWIND[i][3];
        XPYP:=ERWIND[i][4];
        XPZP:=ERWIND[i][5];
        YPZP:=ERWIND[i][6];
        PROD:=GM[RET[XP]+1][RET[YP]+1];
        PROD:=GM[PROD+1][RET[ZP]+1];
        PROD:=GM[PROD+1][RET[XPYP]+1];
        PROD:=GM[PROD+1][RET[XPZP]+1];
        PROD:=GM[PROD+1][RET[YPZP]+1];
        RET[i]:=PROD;
        fi;
    od;
  return RET;
  end;
R:=[[0],[0,0],[1,1,1],[1,1,1,0],[0,0,0,2,3],[2,2,2,3,1,1]];
DIAG(R);

#--------------#

JKLLISTE:=[ [ 2, 3, 4 ],#d=2
 
  [ 2, 5, 6 ], [ 2, 7, 8 ],#d=3 

  [ 3, 5, 7 ], [ 3, 6, 8 ], 
  [ 4, 5, 8 ], [ 4, 6, 7 ] ];

for d in [4..dmax] do
  for i in [(2^(d-2)-1)*(2^(d-2)-2)/6+1..(2^(d-1)-1)*(2^(d-1)-2)/6] do
    Add(JKLLISTE,[JKLLISTE[i][1],JKLLISTE[i][2]+2^(d-2),JKLLISTE[i][3]+2^(d-2)]);
    Add(JKLLISTE,[JKLLISTE[i][1],JKLLISTE[i][2]+2^(d-1),JKLLISTE[i][3]+2^(d-1)]);
    od;
  for j in [1..2^(d-2)] do for k in [1..2^(d-2)] do
    Add(JKLLISTE,[j+2^(d-2),k+2^(d-1),XORMAT[j][k+2^(d-2)+2^(d-1)]]);
    od; od; 
  od;


#--------------#

a:=[];
for i in [1..1000] do a[i]:=i+Int(i/2); od;

KANTENZUG:=function(d,z)
  local s,u,R,LWIE;
  LWIE:=ListWithIdenticalEntries;
  if d=1 then R:=[[1]]; else
    if z>=a[d] then 
      R:=KANTENZUG(d-1,a[d-1]);
      Add(R,LWIE(d,1)); 
      else
        s:=Int(z/6); u:=z mod 6;
        if u=0 then R:=KANTENZUG(d-1,z);
          Add(R,Concatenation(LWIE(4*s,1),LWIE(d-4*s,0))); fi;
        if u=1 then R:=KANTENZUG(d-1,z+1);
          Add(R,Concatenation(LWIE(4*s,1),LWIE(d-4*s,0))); fi;
        if u=2 then R:=KANTENZUG(d-1,z);
          Add(R,Concatenation(LWIE(4*s+1,1),LWIE(d-4*s-1,0))); fi;
        if u=3 then 
          if z+1=a[d-1] then 
            R:=KANTENZUG(d-1,z);
            Add(R,Concatenation(LWIE(4*s+1,1),LWIE(d-4*s-2,0),[1]));
            else if z=a[d-1] then
              R:=KANTENZUG(d-1,z);
              Add(R,Concatenation(LWIE(4*s+1,1),LWIE(d-4*s-1,0)));
              else 
                R:=KANTENZUG(d-1,z+1);
                Add(R,Concatenation(LWIE(4*s+1,1),LWIE(d-4*s-2,0),[1]));  
                fi; fi;
          fi;
        if u=4 then R:=KANTENZUG(d-1,z+1);
          Add(R,Concatenation(LWIE(4*s+1,1),LWIE(d-4*s-1,0))); fi;
        if u=5 then R:=KANTENZUG(d-1,z);
          Add(R,Concatenation(LWIE(4*s+3,1),LWIE(d-4*s-3,0))); fi;
        fi;
    fi;
  return R;
  end;

KANTENZUG(2,1);

ERGS1:=[];
KANTENZUEGE:=function(ddmax)
  #global dmax;
  local dd;
  ERGS1:=[];
  for dd in [1..ddmax] do
    ERGS1[dd]:=[];
    for i in [1..a[dd]] do ERGS1[dd][i]:=KANTENZUG(dd,i); od;
    od;
  end;
KANTENZUEGE(10);
ERGS1[4];

#--------------#

FORTSETZ:=function(HRES,y,D) #setzt HRES,y zu einem gueltigen pcgs fort und macht ein PHI daraus
  local PHI,i,j,k,HRESNEU,nochnichtgefunden;
  PHI:=[];HRESNEU:=[];
  i:=1;
  repeat
    if i<=Size(HRES) then HRESNEU[i]:=HRES[i]; fi;
    if i=Size(HRES)+1 then HRESNEU[i]:=y; fi;
    if i>Size(HRES)+1 then
      nochnichtgefunden:=true;
      for k in [1..Size(D)] do if nochnichtgefunden and not k in PHI then
        if D[k]=D[2^(i-1)] then 
          nochnichtgefunden:=false;
          for j in [1..Size(PHI)] do if nochnichtgefunden=false then 
            if D[XORMAT[PHI[j]+1][k+1]-1]<>D[2^(i-1)+j] then nochnichtgefunden:=true; fi;
            fi; od;
          if nochnichtgefunden=false then HRESNEU[i]:=k; fi;
          fi; fi; od;
      fi;
    PHI[2^(i-1)]:=HRESNEU[i];#ja!!!
    for j in [1..2^(i-1)-1] do
      PHI[2^(i-1)+j]:=XORMAT[PHI[j]+1][PHI[2^(i-1)]+1]-1;#ja!!!
      od;
    i:=i+1;
    until 2^(i-1)=Size(D)+1;
  return PermList(PHI);
  end;

FORTSETZ([1,2],4,[1,0,0,1,1,3,0]);();
FORTSETZ([1],3,[1,0,0,1,1,3,0]);(2,3)(4,5);
FORTSETZ([], 4,[1,0,0,1,1,3,0]);(1,4,5)(2,3,7);

LRESAUSHRES:=function(HRES)
  local LRES,i,j;
  LRES:=[];
  for i in [1..Size(HRES)] do
    LRES[2^(i-1)]:=HRES[i];
    for j in [1..Size(LRES)-1] do
      LRES[2^(i-1)+j]:=XORMAT[LRES[j]+1][HRES[i]+1]-1;
      od;
    od;
  return LRES;
  end;
LRESAUSHRES([1,2,27]);[ 1, 2, 3, 27, 26, 25, 24 ];
  
STABERZ:=function(MENGE,HRES,STAB,D)
  #global LRESAUSHRES,FORTSETZ;
  local MENGENEU,STABNEU,x,y,i,DRIN,PHI,DK,PHI0,LRES;
  #1
  x:=MENGE[1];STABNEU:=STAB;
  LRES:=LRESAUSHRES(HRES);
  #2
  MENGENEU:=[];
  for y in MENGE do
    DRIN:=true;
    ##Print("\ny=",y," ",D[y]," ",D[x]);
    if D[y]<>D[x] then DRIN:=false; fi;
    for i in [1..Size(LRES)] do
     ##Print(" i=",i," ",D[XORMAT[HRES[i]+1][y+1]-1]," ",D[XORMAT[HRES[i]+1][x+1]-1]);
      if D[XORMAT[LRES[i]+1][y+1]-1]<>D[XORMAT[LRES[i]+1][x+1]-1] then DRIN:=false; fi;
      od;
    if DRIN then Add(MENGENEU,y); fi;
    od;
  ##Print("\nMENGENEU=",MENGENEU,"\n\c");
  #3
  repeat
    y:=MENGENEU[1];
    #4
    DK:=List(D);Remove(DK,1);
    ##Print("\n",MENGENEU,HRES,y,D,"\n\c");
    PHI:=FORTSETZ(HRES,y,D);
    #5
    if not PHI in STABNEU then Add(STABNEU,PHI); fi;
    ##Print("\n",PHI,STABNEU,"\n\c");
    #6
    MENGENEU:=Difference(MENGENEU,Orbit(Group(STABNEU),x));
  #7
    until MENGENEU=[];
  #8
  return STABNEU;
  end;
 
STAB:=[];
# 0  1  2  3  4  5  6  7
# e  a  b ab  c ac bc abc
D:=[ 1, 0, 0, 1, 1, 3, 0];#D
STAB:=STABERZ([4..7],[1,2],STAB,D);
STAB:=STABERZ([2..7],[1],STAB,D);
STAB:=STABERZ([1..7],[],STAB,D);
Size(STAB);
Size(Group(STAB));#6 laut 4788 und 4752R

COMPDIAGSTABERZ:=function(D)#aus COMPDIAG4 mit geaendertem RETURN
  #global JKLLISTE;
  local RET,i,j,k,l,jkl,jkli,dj,dk,dl,RET2,reti,SD,DD;
  SD:=Size(D);DD:=[];
  for i in [1..SD] do DD[i]:=D[i]+2; od;
  for jkli in [1..(SD-1)*(SD-2)/6] do
    jkl:=JKLLISTE[jkli];
    j:=jkl[1];k:=jkl[2];l:=jkl[3];
    dj:=D[j];dk:=D[k];dl:=D[l];
#Print("\n",jkl," ",dj," ",dk," ",dl);
    if dj=1 and dk=dl then DD[j]:=1; fi;
    if dj=0 and dk<>dl then DD[j]:=0; fi;
    if dk=1 and dj=dl then DD[k]:=1; fi;
    if dk=0 and dj<>dl then DD[k]:=0; fi;
    if dl=1 and dk=dj then DD[l]:=1; fi;
    if dl=0 and dk<>dj then DD[l]:=0; fi;
    od;
#Print("\n",DD);
  return DD;
  end;

STABMACH:=function(dd,D)
  #global STABERZ;
  local STAB,ddd;
  STAB:=[];
  for ddd in [dd,dd-1..1] do 
    STAB:=STABERZ([2^(ddd-1)..2^dd-1],List([1..ddd-1],i->2^(i-1)),STAB,D);
    od;
  return STAB;
  end;

DOPPELSTAB:=function(dd,S)
  local L,LL,SD;
  L:=List(S,s->ListPerm(s,2^(dd-1)-1));
  for LL in L do LL[2^(dd-1)]:=2^(dd-1); 
    for i in [2^(dd-1)+1..2^dd-1] do
      LL[i]:=LL[i-2^(dd-1)]+2^(dd-1);
      od;
    od; #Display(L);
  SD:=List(L,s->PermList(s));
  return SD;
  end;

HMACH:=function(dd)
  local d,ddd,dddd,i,j,H,L;
  H:=[];ddd:=2^(dd-1);dddd:=2^dd;
  for d in [1..dd-1] do
    L:=[];
    for j in [1..ddd-1] do L[j]:=j; od;
    for j in [ddd..dddd-1] do
      if not IsBound(L[j]) then
        L[j]:=j+2^(d-1);
        L[j+2^(d-1)]:=j;
        fi;
      od;
    Add(H,PermList(L));
    od;
  return H;
  end;
HMACH(4);

RVOND:=function(dd,D)
  local d,j,R,RI;
  R:=[[0],[0,0]];
  for d in [1..dd] do
    RI:=[D[2^(d-1)],D[2^(d-1)],D[2^(d-1)]];
    for j in [2..d] do
      Add(RI,D[2^(d-1)+2^(j-2)]);
      od;
    Add(R,RI);
    od;
  return R;
  end;
RVOND(4,[ 1, 1, 2, 1, 2, 3, 2, 0, 0, 0, 2, 0, 2, 3, 3 ]);[[0],[0,0],[1,1,1],[1,1,1,2],[1,1,1,2,3],[0,0,0,0,0,0]];

RKVOND:=function(dd,D)
  local d,j,R,RI;
  R:=[];
  for d in [1..dd] do
    RI:=[D[2^(d-1)]];
    for j in [2..d] do
      Add(RI,D[2^(d-1)+2^(j-2)]);
      od;
    Add(R,RI);
    od;
  return R;
  end;
RKVOND(4,[ 1, 1, 2, 1, 2, 3, 2, 0, 0, 0, 2, 0, 2, 3, 3 ]);[[1],[1,2],[1,2,3],[0,0,0,0]];

STABMACH2:=function(D) #beginnt mit D und mit neutralem Element
  local C,C1,PHITAB;
  C:=COMPDIAGSTABERZ(D);
  C1:=List(C); Remove(C1,1);
  PHITAB:=STABMACH(LogInt(Size(C),2),C1);
  PHITAB:=List(PHITAB,i->PermList(Concatenation([1],List(ListPerm(i),j->j+1))));
  return PHITAB;
  end;

RVOND4:=function(D) # erwartet neutrales Element mit
  local D0,R;
  D0:=List(D);Remove(D0,1);
  R:=RKVOND(LogInt(Size(D),2),D0);
  return R;
  end;

DGANZNEU:=function(d)
  local dneu;
  dneu:=DNEU(d);
  if dneu=0 then return 0; fi;
  if dneu=1 then return 3; fi;
  if dneu=2 then return 1; fi;
  if dneu=3 then return 2; fi;
  end;

RMAXSUCH:=function(D) #sucht RMAX mit Umbenennen
  local SD,S,STUFE,LRES,LNEU,V,VNEU,VARIANTEN,NEUE_VARIANTEN,RR,RMIN,RNEU,
  HRES,KRES,LD,S1,S2,SX,D1,D2,MENGS,GOINGS,BOINGS,
  GANZ_NEUE_VARIANTEN,GNV,i,j,MALPHA;
  SD:=Size(D); S:=LogInt(SD,2); STUFE:=0; RMIN:=[]; 
  D1:=List(D,i->Int(i/2));
  D2:=List(D,i->i mod 2);
  S1:=Group(STABMACH2(D1));
  S2:=Group(STABMACH2(D2));
  SX:=Intersection(S1,S2);
  VARIANTEN:=[rec(LD:=[],HRES:=[],LRES:=[1],ALPHA:=[0],BETA:=[0],SX:=SX)];
  #Print("\nSX=",List(SX));
  for STUFE in [1..S] do 
    #Print("\nSTUFE=",STUFE);
    #Print(", VARIANTEN=",Size(VARIANTEN));
    #for V in VARIANTEN do Print("\n",V.LRES); od;
    NEUE_VARIANTEN:=[];
    RNEU:=[];
    for V in VARIANTEN do
      HRES:=V.HRES;LRES:=V.LRES;LD:=V.LD;SX:=V.SX;
      MENGS:=[];MALPHA:=[];
      for i in [2..SD] do if not IsBound(LD[i]) then
        ALPHA:=List(V.ALPHA);BETA:=List(V.BETA);
        KRES:=[i];
        for j in HRES do Add(KRES,XORMAT[i][j]); od;
        RR:=List(KRES,i->DGANZNEU(D[i]));#Error("\n",RR,KRES);
        if RR>RNEU then NEUE_VARIANTEN:=[]; MENGS:=[]; RNEU:=RR; fi;
        if RR=RNEU then Add(MENGS,i); MALPHA[i]:=[ALPHA,BETA]; fi;
        fi; od;
      #Print("\nMENGS=",MENGS,Size(MENGS));
      GOINGS:=Orbits(SX,MENGS);
      #Print("\nGOINGS=",GOINGS);
      BOINGS:=List(GOINGS,i->i[1]);
      #Print("\nBOINGS=",BOINGS);
      GANZ_NEUE_VARIANTEN:=[];
      for i in BOINGS do
        VNEU:=StructuralCopy(V);
        Add(VNEU.HRES,i);
        LNEU:=List(LRES,j->XORMAT[i][j]);
        VNEU.LRES:=Concatenation(LRES,LNEU);
        for j in LNEU do VNEU.LD[j]:=STUFE; od;
        VNEU.ALPHA:=List(MALPHA[i][1]); VNEU.BETA:=List(MALPHA[i][2]);
        Add(GANZ_NEUE_VARIANTEN,VNEU);        
        od;
      #Print("\n  GANZ_NEUE_VARIANTEN=",List(GANZ_NEUE_VARIANTEN,i->i.HRES),Size(GANZ_NEUE_VARIANTEN));
      NEUE_VARIANTEN:=Concatenation(NEUE_VARIANTEN,GANZ_NEUE_VARIANTEN);
      od;
    Add(RMIN,RNEU);
    for V in NEUE_VARIANTEN do
      V.SX:=Stabilizer(V.SX,V.HRES[STUFE]);
      od;
    VARIANTEN:=NEUE_VARIANTEN;
    #Print("\n  VARIANTEN=",List(VARIANTEN,i->i.HRES),Size(VARIANTEN));
    od;
  return [RMIN,VARIANTEN];
  end;

SCHNICK:=function(R1,R2)#alle Fortsetzungen von R1 konstant und R2 ergaenzt
  #global COMPDIAGSTABERZ,STABMACH,DOPPELSTAB,HMACH,RKVOND;
  local D0,D1,D2,DD,DDD,S0,S1,S2,SD,SD1,SD2,H,K,t,ORBS,dd;
  dd:=Size(R1);
  D0:=DIAG(R1);
  D1:=DIAG(R1{[1..dd-1]});
  D2:=DIAG(R2);
  #folgendes aus S:=STABAUSD4(dd-1,D);
  D1:=COMPDIAGSTABERZ(D1);Remove(D1,1);
  D2:=COMPDIAGSTABERZ(D2);Remove(D2,1);
  S1:=STABMACH(dd-1,D1);
  if not SAGE then Print("\nDOPPELSTAB S1: \c"); t:=Runtime(); fi;
  SD1:=DOPPELSTAB(dd,S1);
  if not SAGE then Print(Runtime()-t); fi;
  S2:=STABMACH(dd-1,D2);
  if not SAGE then Print("\nDOPPELSTAB S2: \c"); t:=Runtime(); fi;
  SD2:=DOPPELSTAB(dd,S2);
  if not SAGE then Print(Runtime()-t); fi;
  if not SAGE then Print("\nIntersection(S1,S2): \c"); t:=Runtime(); fi;
  S:=Intersection(Group(SD1),Group(SD2));
  if not SAGE then Print(Runtime()-t); fi;
  if not SAGE then Print("\nHMACH: \c"); t:=Runtime(); fi;
  H:=HMACH(dd);
  if not SAGE then Print(Runtime()-t); fi;
  if not SAGE then Print("\nConcatenation(List(S),H): \c"); t:=Runtime(); fi;
  K:=Group(Concatenation(SmallGeneratingSet(S),H));
  if not SAGE then Print(Runtime()-t); fi;
  D0:=COMPDIAGSTABERZ(D0);Remove(D0,1);
  S0:=STABMACH(dd,D0);
  if not SAGE then Print("\nIntersection(S0,K): \c"); t:=Runtime(); fi;
  K:=Intersection(Group(S0),K);
  if not SAGE then Print(Runtime()-t); fi;

  DD:=Tuples([0..1],dd);;#Print(Size(DD));
  DDD:=[];
  for i in [1..2^dd] do
    DDD[i]:=DIAG(Concatenation(R2,[DD[i]])){[2..2^dd]};
    od;
  ORBS:=OrbitsDomain(K,DDD,Permuted);;#Print(Size(ORBS));
  #Add(OM,ORBS);
  #Print(List(ORBS,i->Size(i)));Print("\c");
  D0:=DIAG(R1);Remove(D0,1);
  #List(ORBS,i->IdSmallGroup(PcgsOfR(RVOND(dd,D0+2*i[1]))));
  #Print(Collected(List(ORBS,i->IdSmallGroup(PcgsOfR(R03/04/2018(dd,D0+2*i[1]))))));
  return Reversed(SortedList(List(ORBS,i->RKVOND(dd,Maximum(i)))));
  end;

SCHNACK:=function(dd,CMPD)
  local jj,R,R1,R1R2,TEILDILIST,ORBI,ORB,ID,ts,ZM,rr;
  if not SAGE then Exec("date"); fi;
  ts:=Runtime(); ZM:=0;
  ERGS2[dd]:=[];GESAMTDILIST[dd]:=[];
  for rr in [1..Size(ERGS1[dd])] do
    R1:=Reversed(ERGS1[dd])[rr];
    if not SAGE then Print("\n***R1=",R1); fi;
    TEILDILIST:=[];
    for jj in [1..Size(ERGS2[dd-1])] do R1R2:=ERGS2[dd-1][jj]; if R1{[1..dd-1]}=R1R2[1] then
      if not SAGE then Print("\n...R1,R1R2=\n",R1,"\n",R1R2,"\n"); fi;
      ORBI:=SCHNICK(R1,R1R2[2]); ZM:=ZM+Size(ORBI);
      #1#Print("\nORBI=",ORBI,Size(ORBI),"\n",R1R2,"...\n");
      if not SAGE then Print("\nSize(ORBI)=",Size(ORBI)); fi;
      if not SAGE then Print("\n",jj," von ",Size(ERGS2[dd-1])," in ",rr," von ",Size(ERGS1[dd]),": Size(GESAMTDILIST[dd])=",Size(GESAMTDILIST[dd]),"\n"); fi;
      for ORB in ORBI do
        R:=2*R1+ORB;
        D:=DIAG(R);
        #a#Remove(D,1);
        #a#RV:=RVOND(dd,D);
        #a#ID:=IdSmallGroup(PcgsOfR(RV));
        ID:=CMPD(dd,D,false);
        #a#Print(" ",ID,"\c");
        if not ID in GESAMTDILIST[dd] then
        #if DIAG(ID)=D then
          #if DIAG(ID)<>D then Print("\n",ID,"\n",RVOND4(D),"\n"); fi;
          Add(ERGS2[dd],[R1,ORB]); 
          Add(GESAMTDILIST[dd],ID);
          if not SAGE then Print("*\c"); fi;
          else if not SAGE then Print(".\c"); fi; fi;
        od;
      fi; od;
    od;
  Print("\n",List(GESAMTDILIST,i->Size(i)),ZM);
  Print("\n",[ 1, 6, 19, 60, 158, 442, 1122, 2945],Runtime()-ts,"\n");
  if not SAGE then Exec("date"); fi;
  end;



COMPDIAG5RS:=function(dd,D,flag) return RMAXSUCH(D)[1]; end;

ProfileFunctions(SCHNACK,SCHNICK,COMPDIAGSTABERZ,STABMACH2,Stabilizer,Orbits,RMAXSUCH);

#-----------
KANTENZUEGE(10);
ERGS1[4];
ERGS2:=[[[[[1]],[[1]]]]];
ERGS2[1][1];[[[1]],[[1]]];
GESAMTDILIST:=[[[[3]]]];
ClearProfile();ZM:=0;
SCHNACK(2,COMPDIAG5RS);#16#6
SCHNACK(3,COMPDIAG5RS);#32#19
SCHNACK(4,COMPDIAG5RS);#64#60
#SCHNACK(5,COMPDIAG5RS);#128#158
#SCHNACK(6,COMPDIAG5RS);#256#442
#SCHNACK(7,COMPDIAG5RS);#512#1122
#SCHNACK(8,COMPDIAG5RS);#1024#2945
DisplayProfile();
