#Read("DIAG.txt");

R4:=function(V)
  local i,R,V2;
  V2:=List(V);Add(V2,V2[1],1);Add(V2,V2[1],1);
  R:=[[0],[0,0],[1,1,1]];
  for i in [4..Size(V)+1] do Add(R,ListWithIdenticalEntries(i,0)); od;
  Add(R,V2);
  return R;
  end;

RTT:=function()
  if HRES=[] then GR:=Group(P.1^0); else GR:=Group(HRES); fi;
  ri:=PL[S];
  Add(HRES,ri,1);HRESEXT[S]:=ri;
#  QY10(HRES,S,GR);#ob HRES wirklich ein pcgs ist, deshalb PL
  PNEU:=QY11(HRES,S);
  R[S]:=List(PNEU);
  n:=nn;ZR:=QY21(HRES,S,nn,ZEIGER,PNEU);;
  HRES:=List(ZR[1]);ZR3MERK:=ZR[3];
    S:=S+1;nn:=2*nn;ZEIGER:=ZR[2];;
  if ZR3MERK=-1 then return -10000; else
    if ZEIGER=[] then return 1; else return RTT()+1; fi;
    fi;
  end;

FUN:=function(arg)
  RT:=[];
  j:=Size(arg)/2;
  for i in [1..j] do
    Add(RT,arg[i]+arg[i+j]);
    od;
  Print("\n",RT);
  R:=R4(RT);RSIZE:=Size(R);
  P:=PcgsOfR(R);
#  Print(IdSmallGroup(P),"\c");
PL:=Reversed(GeneratorsOfGroup(P));
S:=1;nn:=1;HRES:=[];HRESEXT:=[];R:=[];WEGLI:=[];
ZEIGER:=XSAMMEL;;
  NEU:=RTT();Print(NEU);
  if NEU<>RSIZE then inh:=inh+1;RMAXSUCH(P);Add(ERG,RT); fi;
  return [];
  end;

DIAG:=function(R)#neu
  local i,ii,j,k,S,RET,RF,X,Y,Z,POS1,POS2,PROD,GM,XP,YP,ZP;
  RET:=[];
  RF:=Flat(R);Add(RF,0,1);
  S:=Size(R);
  j:=1;
  for i in IteratorOfTuples( [0,1], S ) do
    if Sum(i)<3 then 
      Add(RET,RF[j]);j:=j+1;
      else 
        X:=0*i;Y:=List(X);Z:=List(i);
        POS1:=Position(Z,1);
        X[POS1]:=1;Z[POS1]:=0;XP:=2^(S-POS1);
        POS2:=Position(Z,1);
        Y[POS2]:=1;Z[POS2]:=0;YP:=2^(S-POS2);
        ZP:=0;ii:=1;
        for POS3 in [S,S-1..1] do 
          if Z[POS3]=1 then ZP:=ZP+ii; fi;
          ii:=ii+ii;
          od;          
#        Print("\n  ",X);
#        Print("\n  ",Y);
#        Print("\n  ",Z);
#        PROD:=PR(X)+PR(Y)+PR(Z)+PR(X+Y)+PR(X+Z)+PR(Y+Z);
#if PR(X)<>RET[XP+1] then Error(XP); fi;
        PROD:=GM[RET[XP+1]+1][RET[YP+1]+1];
        PROD:=GM[PROD+1][RET[ZP+1]+1];
        PROD:=GM[PROD+1][RET[XP+YP+1]+1];
        PROD:=GM[PROD+1][RET[XP+ZP+1]+1];
        PROD:=GM[PROD+1][RET[YP+ZP+1]+1];
#        Print(PROD);
        Add(RET,PROD);
#        Print("\n  ",RET);
        fi;
    od;
  return RET;
  end;
  
FUND:=function(arg)#neu
  RT:=[];
  j:=Size(arg)/2;
  for i in [1..j] do
    Add(RT,arg[i]+arg[i+j]);
    od;
  R:=R4(RT);D:=DIAG(R);;C:=Collected(D);#Print(C);
  D:=List(C{[2..Size(C)]},i->i[2]);D:=SortedList(D);Add(D,C[1][2],1);
  if not D in ERGD then Add(ERG,[RT,D]);Add(ERGD,D);Print("\n",RT,D); fi;
# if NEU<>RSIZE then inh:=inh+1;RMAXSUCH(P);Add(ERG,RT); fi;
  return [];
  end;

R5:=function(RIV)#neu
  local i,V2,RI,V;
  if IsInt(RIV[1]) then
    R:=R4(RIV);
    else
      RI:=RIV[1];V:=RIV[2];
      V2:=List(V);Add(V2,V2[1],1);Add(V2,V2[1],1);
      R:=R5(RI);
      Add(R,V2);
      fi;
  return R;
  end;

FUN5:=function(arg)
  RT:=[];
  j:=Size(arg)/2;
  for i in [1..j] do
    Add(RT,arg[i]+arg[i+j]);
    od;
  Print("\n",RT);
  R:=R5([RI,RT]);RSIZE:=Size(R);
#Print("???",R);
  P:=PcgsOfR(R);
#  Print(IdSmallGroup(P),"\c");
PL:=Reversed(GeneratorsOfGroup(P));
S:=1;nn:=1;HRES:=[];HRESEXT:=[];R:=[];WEGLI:=[];
ZEIGER:=XSAMMEL;;
  NEU:=RTT();Print(NEU);
  if NEU<>RSIZE then 
    inh:=inh+1;
    RMAXSUCH(P);
    S:=Size(R);
    Add(ERGS[S],[RI,RT]);
    fi;
  return [];
  end;

XORMAT:=MatrixOf([[0,],[0,0],[0,0,0],[0,0,0,0]]);
JKLLISTE:=[];
JKLLISTEMACH:=function(SI)
  local j,k,l;
  JKLLISTE:=[];
  for j in [2..SI-1] do
    for k in [j+1..SI] do
      l:=XORMAT[j][k];
      if l>j and l>k then
        Add(JKLLISTE,[j,k,l]);
        Print("\n",j," ",k," ",l);
        fi;
      od;
    od;
  end;
JKLLISTEMACH(8);

QUADMAT:=[];
QUADMATMACH:=function()
  local j,k,l,COL,fun;
  QUADMAT:=[];
  for j in [0..3] do
    QUADMAT[j+1]:=[];
    for k in [0..3] do
      QUADMAT[j+1][k+1]:=[];
      for l in [0..3] do
        COL:=Collected([0,j,k,l]);fun:="******";
        if COL[1][2]=4 then fun:=0; fi;
        if COL[1][2]=3 then fun:=[[COL[2][1],1]]; fi;
        if COL[1][2]=2 then 
          if COL[2][2]=2 then fun:=[[COL[2][1],2]]; fi;
          if COL[2][2]=1 then fun:=[[COL[2][1],3],[COL[3][1],3]]; fi;
          fi;
        if COL[1][2]=1 then 
          if COL[2][2]=3 then fun:=[[COL[2][1],4]]; fi;
          if COL[2][2]=2 then fun:=[[COL[2][1],5],[COL[3][1],6]]; fi;
          if COL[2][2]=1 then 
            if COL[3][2]=2 then fun:=[[COL[2][1],6],[COL[3][1],5]]; fi;
            if COL[3][2]=1 then fun:=[[1,7],[2,7],[3,7]]; fi;
            fi;
          fi;
        QUADMAT[j+1][k+1][l+1]:=fun;
        Print("\n0 ",j," ",k," ",l," ",COL,"->",fun);
        od;
      od;
    od;
  end;
QUADMATMACH();


COMPDIAG:=function(D)#neu
  local C,RET,i,j,k,jkl,l,QUAD1,QUAD2,SI,ii,fun;
#Print(D,"\n");
  C:=Collected(D);
#Print(C,"\n");
  SI:=Size(D);
#Print(SI,"\n");
  QUAD0:=0;QUAD:=[[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0]];
  for jkl in JKLLISTE do
#Print(jkl,"\n");
    j:=jkl[1];k:=jkl[2];l:=jkl[3];
#Print(j," ",k," ",l,"\n");
    dj:=D[j];dk:=D[k];dl:=D[l];
#Print(dj," ",dk," ",dl,"\n");
    fun:=QUADMAT[dj+1][dk+1][dl+1];
#Print(fun,"\n");
    if fun=0 then QUAD0:=QUAD0+1; else
      for i in fun do QUAD[i[1]][i[2]]:=QUAD[i[1]][i[2]]+1; od;
      fi;
    od;
  RET:=List(C{[2..Size(C)]},i->[i[2],QUAD0,QUAD[i[1]]]);
  RET:=SortedList(RET);
  Add(RET,C[1][2],1);
  return RET;
  end;

FUN6:=function(arg)#neu
  RT:=[];
  j:=Size(arg)/2;
  for i in [1..j] do
    Add(RT,arg[i]+arg[i+j]);
    od;
#  Print("\n",RT,RI);
#  Print(".");
  if RI=[] then R:=R4(RT); else R:=R5([RI,RT]); fi;
  S:=Size(R);
  RSIZE:=Size(R);
  GESAMTDI:=COMPDIAG(DIAG(R));
  if not (GESAMTDI in GESAMTDILIST) then
    Add(GESAMTDILIST,GESAMTDI);
    if RI=[] then Add (ERG,RT); else Add(ERG,[RI,RT]); fi;
    Print("*",Size(ERG),"\c");
    fi;
  return [];
  end;    

IDLISTE:=[];
FUN7:=function(arg)#neu
  RT:=[];
  j:=Size(arg)/2;
  for i in [1..j] do
    Add(RT,arg[i]+arg[i+j]);
    od;
#  Print("\n",RT,RI);
#  Print(".");
  if RI=[] then R:=R4(RT); else R:=R5([RI,RT]); fi;
  P:=PcgsOfR(R);
  ID:=IdSmallGroup(P)[2];
  if not (IsBound(IDLISTE[ID])) then
    IDLISTE[ID]:=1;
    if RI=[] then Add (ERG,RT); else Add(ERG,[RI,RT]); fi;
    Print("\n",RT,", #",Size(ERG)," ",ID,"\c");
    else IDLISTE[ID]:=IDLISTE[ID]+1; fi;
  return [];
  end;    

RINXS:=function(R,ZEIGER,S)#ohne phi ob R in XSAMMEL ist
  local PNEU,ZEIG,RET;
  RET:=ZEIGER;
  PNEU:=R[S];
#  Print(PNEU,S,Size(R));
  if S<Size(R) then 
    for ZEIG in ZEIGER do 
#      Print(ZEIG[1]);
      if UMKEHRLIST(ZEIG[1])=PNEU then
        if IsBound(ZEIG[5]) then ZEIG:=ZEIG[5]; fi;
        if IsBound(ZEIG[12]) then ZEIG:=ZEIG[12]; fi;
        RET:=RINXS(R,ZEIG[6],S+1); 
        fi;
      od;
    else
      RET:=0;
      for ZEIG in ZEIGER do 
#        Print(ZEIG[1]);
        if UMKEHRLIST(ZEIG[1])=PNEU then
          RET:=-1;
          fi;
        od;
      fi;
  return RET;
  end;
ZEIG:=RINXS([[0],[0,0],[1,1,1],[0,0,0,2],[0,0,0,2,3]],XSAMMEL,1);
ZEIG:=RINXS([[0],[0,0],[1,1,1],[0,0,0,2],[0,0,1,2,3]],XSAMMEL,1);
ZEIG:=RINXS([[0],[0,0],[1,1,1],[2,2,2,3],[0,0,0,0,0]],XSAMMEL,1);

FUN8:=function(arg)#neu-->DIAG.txt
  RT:=[];
  j:=Size(arg)/2;
  for i in [1..j] do
    Add(RT,arg[i]+arg[i+j]);
    od;
  R:=R5([RI,RT]);RSIZE:=Size(R);
#Print("???",R,RINXS(R,XSAMMEL,1));
  if RINXS(R,XSAMMEL,1)=0 then
    Print("\n",RT);
    P:=PcgsOfR(R);
#  Print(IdSmallGroup(P),"\c");
    inh:=inh+1;
    EINMALBIT:=0;
    RMAXSUCH(P);Print("\c");
    EINMALBIT:=0;
    S:=Size(R);
    Add(ERGS[S],[RI,RT]);
    fi;
  return [];
  end;

ProfileFunctions([Fun5,FUN6,FUN7,R4,R5,DIAG,COMPDIAG,
  Flat,Add,Size]);
ClearProfile();
DisplayProfile();
