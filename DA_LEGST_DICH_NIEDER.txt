#Read("DA_LEGST_DICH_NIEDER.txt");
#funktioniert hat Zeile 604-616, danach neues

SAGE:=true;
dmax:=10;
#dmax:=12;

XORMAT:=[[1]];
for i in [1..dmax] do
  n2:=2^(i-1);
  for j in [1..n2] do
    XORMAT[j+n2]:=[];
    for k in [1..n2] do
      XORMAT[j][k+n2]:=XORMAT[j][k]+n2;
      XORMAT[j+n2][k+n2]:=XORMAT[j][k];
      XORMAT[j+n2][k]:=XORMAT[j][k]+n2;
      od; od; od;
#---------#
Diagonale:=function(G,flag)
  local HRES,i,j,D,DD,DDD,RET,RA,PC;
  RA:=RankPGroup(G);
  PC:=Pcgs(G);
  HRES:=Reversed(PC{[1..RA]});#Print(RA,PC,HRES);
  D:=[];
  for i in [1..Size(HRES)] do
    Add(D,HRES[i]);
    for j in [1..Size(D)-1] do
      Add(D,HRES[i]*D[j]);
      od;
    od;
  DDD:=List(D);
  DD:=List(D,i->i^2);
  HRES:=MinimalGeneratingSet(Group(DD));
  D:=[];
  for i in [1..Size(HRES)] do
    Add(D,HRES[i]);
    for j in [1..Size(D)-1] do
      Add(D,D[j]*HRES[i]);
      od;
    od;
  Add(D,D[1]^0,1); Add(DDD,D[1]^0,1);
  RET:=List(DD,i->Position(D,i)-1);
  if flag=1 then RET:=DDD; fi;
  return RET;
  end;

Diagonale(SmallGroup(4,1),0);
Diagonale(SmallGroup(8,2),0);
Diagonale(SmallGroup(16,3),0);
Diagonale(SmallGroup(256,55750),1);

COMPDIAG6E:=function(dd,D,flag)#neu
  local i,j,k,l,SD,ORBZU,MARK,NMARK,STUFE;
  SD:=Size(D);
  ORBZU:=[]; STUFE:=1;
  ORBZU[STUFE]:=List(D);
  ORBZU[STUFE][1]:=-1;
  repeat
    if flag=88 then Print("\n",ORBZU); fi;
    Print("#",Size(Collected(ORBZU[STUFE])),"\c");
    MARK:=[];
    for i in [1..SD] do
      MARK[i]:=[-1];
      for j in [1..SD] do 
        MARK[i][j]:=[
          ORBZU[STUFE][i],
          ORBZU[STUFE][j],
          ORBZU[STUFE][XORMAT[j][i]]];
        od;
      MARK[i]:=Collected(MARK[i]{[1..SD]});
      od;
    STUFE:=STUFE+1;
    ORBZU[STUFE]:=[];
    for i in [1..SD] do for j in [i,i-1..1] do
      if MARK[i]=MARK[j] and ORBZU[STUFE-1][i]=ORBZU[STUFE-1][j] then ORBZU[STUFE][i]:=j; fi; od; od;
    until ORBZU[STUFE]=ORBZU[STUFE-1];  
  return ORBZU[STUFE];
  end;

COMPDIAG7E:=function(D)
  local i,j,SD,ORBZU,ORBZUMERK,MARK;
  SD:=Size(D); ORBZU:=List(D);
  repeat
    MARK:=[];
    for i in [1..SD] do
      MARK[i]:=[];
      for j in [1..SD] do MARK[i][j]:=[ORBZU[j],ORBZU[XORMAT[j][i]]]; od;
      MARK[i]:=Collected(MARK[i]);
      od;
    ORBZUMERK:=ORBZU; ORBZU:=[1];
    for i in [2..SD] do for j in [i,i-1..2] do
      if MARK[i]=MARK[j] and ORBZUMERK[i]=ORBZUMERK[j] then ORBZU[i]:=j; fi; od; od;
    until ORBZU=ORBZUMERK;  
  return ORBZU;
  end;

RMINVORTEST:=function(D)
  local SD,S,STUFE,LRES,LNEU,V,VNEU,VARIANTEN,NEUE_VARIANTEN,RR,RMIN,RNEU,
  HRES,LD,ORBZU,ORBS,ONEU;
  SD:=Size(D); S:=LogInt(SD,2); STUFE:=0; RMIN:=[];
  ORBZU:=COMPDIAG6E(S,D,0);
  VARIANTEN:=[rec(LD:=[],HRES:=[],LRES:=[1])];
  for STUFE in [1..S] do
    NEUE_VARIANTEN:=[];
    RNEU:=[9999];
    for V in VARIANTEN do
      HRES:=V.HRES;LRES:=V.LRES;LD:=V.LD;
      ORBS:=[];
      for i in [2..SD] do if not IsBound(LD[i]) then
        RR:=[D[i]];
        for j in HRES do Add(RR,D[XORMAT[i][j]]); od;
        if RR<RNEU then NEUE_VARIANTEN:=[]; RNEU:=RR; fi;
        if RR=RNEU then
          LNEU:=List(LRES,j->XORMAT[i][j]);
          ONEU:=List(LNEU,j->ORBZU[j]);
          if not (ONEU in ORBS) then
            Add(ORBS,ONEU);
            VNEU:=StructuralCopy(V);
            Add(VNEU.HRES,i);
            VNEU.LRES:=Concatenation(LRES,LNEU);
            for i in LNEU do VNEU.LD[i]:=STUFE; od;
            Add(NEUE_VARIANTEN,VNEU);
            fi;
          fi;
        fi; od;
      od;
    VARIANTEN:=NEUE_VARIANTEN;
    Add(RMIN,RNEU);
    od;
  return [RMIN,VARIANTEN];
  end;

ALPHA:=[0];#global weil von DNEU veraendert
BETA:=[0];

DNEU:=function(d)
  local dneu,i;
  if not IsBound(ALPHA[d+1]) then
    dneu:=Size(BETA);
    for i in [dneu,dneu-1..1] do Add(BETA,XORMAT[d+1][BETA[i]+1]-1); od;
    for i in [1..dneu] do ALPHA[BETA[dneu+i]+1]:=dneu+i-1; od;
    fi;
  dneu:=ALPHA[d+1];
  return dneu;
  end;

DNEU(2);ALPHA;BETA;
DNEU(7);ALPHA;BETA;
DNEU(6);ALPHA;BETA;

RMINSUCH:=function(D)
  local SD,S,STUFE,LRES,LNEU,V,VNEU,VARIANTEN,NEUE_VARIANTEN,RR,RMIN,RNEU,
  HRES,KRES,LD,ORBZU,ORBS,ONEU;
  SD:=Size(D); S:=LogInt(SD,2); STUFE:=0; RMIN:=[];
  #ORBZU:=COMPDIAG6E(S,D,0);
  ORBZU:=COMPDIAG7E(D);
  VARIANTEN:=[rec(LD:=[],HRES:=[],LRES:=[1],ALPHA:=[0],BETA:=[0])];
  for STUFE in [1..S] do 
    #Print("\nSTUFE=",STUFE);
    NEUE_VARIANTEN:=[];
    RNEU:=[0];
    for V in VARIANTEN do
      HRES:=V.HRES;LRES:=V.LRES;LD:=V.LD;
      ORBS:=[];
      for i in [2..SD] do if not IsBound(LD[i]) then
        ALPHA:=List(V.ALPHA);BETA:=List(V.BETA);
        KRES:=[i];
        for j in HRES do Add(KRES,XORMAT[i][j]); od;
        RR:=List(KRES,i->DNEU(D[i]));
        if RR>RNEU then NEUE_VARIANTEN:=[]; RNEU:=RR; fi;#max geht schneller als min
        if RR=RNEU then
          LNEU:=List(LRES,j->XORMAT[i][j]);
          ONEU:=List(LNEU,j->ORBZU[j]);#Print("O");
          if not (ONEU in ORBS) then
            Add(ORBS,ONEU);
            VNEU:=StructuralCopy(V);
            Add(VNEU.HRES,i);
            VNEU.LRES:=Concatenation(LRES,LNEU);
            for i in LNEU do VNEU.LD[i]:=STUFE; od;
            VNEU.ALPHA:=ALPHA; VNEU.BETA:=List(BETA);
            Add(NEUE_VARIANTEN,VNEU);
            fi;
          #Print("P");
          fi;
        fi; od;
      od;
    VARIANTEN:=NEUE_VARIANTEN;
    Add(RMIN,RNEU);
    #Print(", VARIANTEN=",Size(VARIANTEN));
    od;
  return [RMIN,VARIANTEN];
  end;


#---------#

ERWIND:=[];
j:=1;k:=1;S:=dmax;
for i in IteratorOfTuples( [0,1], S ) do
   if not SAGE then Print("."); fi;
#  Print("\n",i);
  if 3>Sum(i) then 
    ERWIND[k]:=j;j:=j+1;k:=k+1;
    else
      XL:=0*i;YL:=List(XL);ZL:=List(i);
      POS1:=Position(ZL,1);
      XL[POS1]:=1;ZL[POS1]:=0;XP:=2^(S-POS1);
      POS2:=Position(ZL,1);
      YL[POS2]:=1;ZL[POS2]:=0;YP:=2^(S-POS2);
      ZP:=0;ii:=1;
      for POS3 in [S,S-1..1] do 
        if ZL[POS3]=1 then ZP:=ZP+ii; fi;
        ii:=ii+ii;
        od;          
      ERWIND[k]:=[XP+1,YP+1,ZP+1,XP+YP+1,XP+ZP+1,YP+ZP+1];
      k:=k+1;
      fi;
#  Print(ERWIND[k-1]);
  od;

DIAG:=function(R)#neu
  local i,S,T,RET,RF,PROD,GM,XP,YP,ZP,XPYP,XPZP,YPZP;
#  PR:=function(X) return RET[IZUN(Reversed(X))+1]; end; 
  RET:=[];
  RF:=Flat(R);Add(RF,0,1);
#  Print("\n",RF);
  S:=Size(R);T:=2^S;RET:=EmptyPlist(T);
  GM:=[[0,1,2,3],[1,0,3,2],[2,3,0,1],[3,2,1,0]];
  for i in [1..T] do
    if IsInt(ERWIND[i]) then
      RET[i]:=RF[ERWIND[i]];
      else
        XP:=ERWIND[i][1];
        YP:=ERWIND[i][2];
        ZP:=ERWIND[i][3];
        XPYP:=ERWIND[i][4];
        XPZP:=ERWIND[i][5];
        YPZP:=ERWIND[i][6];
        PROD:=GM[RET[XP]+1][RET[YP]+1];
        PROD:=GM[PROD+1][RET[ZP]+1];
        PROD:=GM[PROD+1][RET[XPYP]+1];
        PROD:=GM[PROD+1][RET[XPZP]+1];
        PROD:=GM[PROD+1][RET[YPZP]+1];
        RET[i]:=PROD;
        fi;
    od;
  return RET;
  end;
R:=[[0],[0,0],[1,1,1],[1,1,1,0],[0,0,0,2,3],[2,2,2,3,1,1]];
DIAG(R);

#--------------#

JKLLISTE:=[ [ 2, 3, 4 ],#d=2
 
  [ 2, 5, 6 ], [ 2, 7, 8 ],#d=3 

  [ 3, 5, 7 ], [ 3, 6, 8 ], 
  [ 4, 5, 8 ], [ 4, 6, 7 ] ];

for d in [4..dmax] do
  for i in [(2^(d-2)-1)*(2^(d-2)-2)/6+1..(2^(d-1)-1)*(2^(d-1)-2)/6] do
    Add(JKLLISTE,[JKLLISTE[i][1],JKLLISTE[i][2]+2^(d-2),JKLLISTE[i][3]+2^(d-2)]);
    Add(JKLLISTE,[JKLLISTE[i][1],JKLLISTE[i][2]+2^(d-1),JKLLISTE[i][3]+2^(d-1)]);
    od;
  for j in [1..2^(d-2)] do for k in [1..2^(d-2)] do
    Add(JKLLISTE,[j+2^(d-2),k+2^(d-1),XORMAT[j][k+2^(d-2)+2^(d-1)]]);
    od; od; 
  od;


#--------------#

a:=[];
for i in [1..1000] do a[i]:=i+Int(i/2); od;

KANTENZUG:=function(d,z)
  local s,u,R,LWIE;
  LWIE:=ListWithIdenticalEntries;
  if d=1 then R:=[[1]]; else
    if z>=a[d] then 
      R:=KANTENZUG(d-1,a[d-1]);
      Add(R,LWIE(d,1)); 
      else
        s:=Int(z/6); u:=z mod 6;
        if u=0 then R:=KANTENZUG(d-1,z);
          Add(R,Concatenation(LWIE(4*s,1),LWIE(d-4*s,0))); fi;
        if u=1 then R:=KANTENZUG(d-1,z+1);
          Add(R,Concatenation(LWIE(4*s,1),LWIE(d-4*s,0))); fi;
        if u=2 then R:=KANTENZUG(d-1,z);
          Add(R,Concatenation(LWIE(4*s+1,1),LWIE(d-4*s-1,0))); fi;
        if u=3 then 
          if z+1=a[d-1] then 
            R:=KANTENZUG(d-1,z);
            Add(R,Concatenation(LWIE(4*s+1,1),LWIE(d-4*s-2,0),[1]));
            else if z=a[d-1] then
              R:=KANTENZUG(d-1,z);
              Add(R,Concatenation(LWIE(4*s+1,1),LWIE(d-4*s-1,0)));
              else 
                R:=KANTENZUG(d-1,z+1);
                Add(R,Concatenation(LWIE(4*s+1,1),LWIE(d-4*s-2,0),[1]));  
                fi; fi;
          fi;
        if u=4 then R:=KANTENZUG(d-1,z+1);
          Add(R,Concatenation(LWIE(4*s+1,1),LWIE(d-4*s-1,0))); fi;
        if u=5 then R:=KANTENZUG(d-1,z);
          Add(R,Concatenation(LWIE(4*s+3,1),LWIE(d-4*s-3,0))); fi;
        fi;
    fi;
  return R;
  end;

KANTENZUG(2,1);

ERGS1:=[];
KANTENZUEGE:=function(ddmax)
  #global dmax;
  local dd;
  ERGS1:=[];
  for dd in [1..ddmax] do
    ERGS1[dd]:=[];
    for i in [1..a[dd]] do ERGS1[dd][i]:=KANTENZUG(dd,i); od;
    od;
  end;
KANTENZUEGE(10);
ERGS1[4];

#--------------#

FORTSETZ:=function(HRES,y,D) #setzt HRES,y zu einem gueltigen pcgs fort und macht ein PHI daraus
  local PHI,i,j,k,HRESNEU,nochnichtgefunden;
  PHI:=[];HRESNEU:=[];
  i:=1;
  repeat
    if i<=Size(HRES) then HRESNEU[i]:=HRES[i]; fi;
    if i=Size(HRES)+1 then HRESNEU[i]:=y; fi;
    if i>Size(HRES)+1 then
      nochnichtgefunden:=true;
      for k in [1..Size(D)] do if nochnichtgefunden and not k in PHI then
        if D[k]=D[2^(i-1)] then 
          nochnichtgefunden:=false;
          for j in [1..Size(PHI)] do if nochnichtgefunden=false then 
            if D[XORMAT[PHI[j]+1][k+1]-1]<>D[2^(i-1)+j] then nochnichtgefunden:=true; fi;
            fi; od;
          if nochnichtgefunden=false then HRESNEU[i]:=k; fi;
          fi; fi; od;
      fi;
    PHI[2^(i-1)]:=HRESNEU[i];#ja!!!
    for j in [1..2^(i-1)-1] do
      PHI[2^(i-1)+j]:=XORMAT[PHI[j]+1][PHI[2^(i-1)]+1]-1;#ja!!!
      od;
    i:=i+1;
    until 2^(i-1)=Size(D)+1;
  return PermList(PHI);
  end;

FORTSETZ([1,2],4,[1,0,0,1,1,3,0]);();
FORTSETZ([1],3,[1,0,0,1,1,3,0]);(2,3)(4,5);
FORTSETZ([], 4,[1,0,0,1,1,3,0]);(1,4,5)(2,3,7);

LRESAUSHRES:=function(HRES)
  local LRES,i,j;
  LRES:=[];
  for i in [1..Size(HRES)] do
    LRES[2^(i-1)]:=HRES[i];
    for j in [1..Size(LRES)-1] do
      LRES[2^(i-1)+j]:=XORMAT[LRES[j]+1][HRES[i]+1]-1;
      od;
    od;
  return LRES;
  end;
LRESAUSHRES([1,2,27]);[ 1, 2, 3, 27, 26, 25, 24 ];
  
STABERZ:=function(MENGE,HRES,STAB,D)
  #global LRESAUSHRES,FORTSETZ;
  local MENGENEU,STABNEU,x,y,i,DRIN,PHI,DK,PHI0,LRES;
  #1
  x:=MENGE[1];STABNEU:=STAB;
  LRES:=LRESAUSHRES(HRES);
  #2
  MENGENEU:=[];
  for y in MENGE do
    DRIN:=true;
    ##Print("\ny=",y," ",D[y]," ",D[x]);
    if D[y]<>D[x] then DRIN:=false; fi;
    for i in [1..Size(LRES)] do
     ##Print(" i=",i," ",D[XORMAT[HRES[i]+1][y+1]-1]," ",D[XORMAT[HRES[i]+1][x+1]-1]);
      if D[XORMAT[LRES[i]+1][y+1]-1]<>D[XORMAT[LRES[i]+1][x+1]-1] then DRIN:=false; fi;
      od;
    if DRIN then Add(MENGENEU,y); fi;
    od;
  ##Print("\nMENGENEU=",MENGENEU,"\n\c");
  #3
  repeat
    y:=MENGENEU[1];
    #4
    DK:=List(D);Remove(DK,1);
    ##Print("\n",MENGENEU,HRES,y,D,"\n\c");
    PHI:=FORTSETZ(HRES,y,D);
    #5
    if not PHI in STABNEU then Add(STABNEU,PHI); fi;
    ##Print("\n",PHI,STABNEU,"\n\c");
    #6
    MENGENEU:=Difference(MENGENEU,Orbit(Group(STABNEU),x));
  #7
    until MENGENEU=[];
  #8
  return STABNEU;
  end;
 
STAB:=[];
# 0  1  2  3  4  5  6  7
# e  a  b ab  c ac bc abc
D:=[ 1, 0, 0, 1, 1, 3, 0];#D
STAB:=STABERZ([4..7],[1,2],STAB,D);
STAB:=STABERZ([2..7],[1],STAB,D);
STAB:=STABERZ([1..7],[],STAB,D);
Size(STAB);
Size(Group(STAB));#6 laut 4788 und 4752R

COMPDIAGSTABERZ:=function(D)#aus COMPDIAG4 mit geaendertem RETURN
  #global JKLLISTE;
  local RET,i,j,k,l,jkl,jkli,dj,dk,dl,RET2,reti,SD,DD;
  SD:=Size(D);DD:=[];
  for i in [1..SD] do DD[i]:=D[i]+2; od;
  for jkli in [1..(SD-1)*(SD-2)/6] do
    jkl:=JKLLISTE[jkli];
    j:=jkl[1];k:=jkl[2];l:=jkl[3];
    dj:=D[j];dk:=D[k];dl:=D[l];
#Print("\n",jkl," ",dj," ",dk," ",dl);
    if dj=1 and dk=dl then DD[j]:=1; fi;
    if dj=0 and dk<>dl then DD[j]:=0; fi;
    if dk=1 and dj=dl then DD[k]:=1; fi;
    if dk=0 and dj<>dl then DD[k]:=0; fi;
    if dl=1 and dk=dj then DD[l]:=1; fi;
    if dl=0 and dk<>dj then DD[l]:=0; fi;
    od;
#Print("\n",DD);
  return DD;
  end;

STABMACH:=function(dd,D)
  #global STABERZ;
  local STAB,ddd;
  STAB:=[];
  for ddd in [dd,dd-1..1] do 
    STAB:=STABERZ([2^(ddd-1)..2^dd-1],List([1..ddd-1],i->2^(i-1)),STAB,D);
    od;
  return STAB;
  end;

DOPPELSTAB:=function(dd,S)
  local L,LL,SD;
  L:=List(S,s->ListPerm(s,2^(dd-1)-1));
  for LL in L do LL[2^(dd-1)]:=2^(dd-1); 
    for i in [2^(dd-1)+1..2^dd-1] do
      LL[i]:=LL[i-2^(dd-1)]+2^(dd-1);
      od;
    od; #Display(L);
  SD:=List(L,s->PermList(s));
  return SD;
  end;

HMACH:=function(dd)
  local d,ddd,dddd,i,j,H,L;
  H:=[];ddd:=2^(dd-1);dddd:=2^dd;
  for d in [1..dd-1] do
    L:=[];
    for j in [1..ddd-1] do L[j]:=j; od;
    for j in [ddd..dddd-1] do
      if not IsBound(L[j]) then
        L[j]:=j+2^(d-1);
        L[j+2^(d-1)]:=j;
        fi;
      od;
    Add(H,PermList(L));
    od;
  return H;
  end;
HMACH(4);

RVOND:=function(dd,D)
  local d,j,R,RI;
  R:=[[0],[0,0]];
  for d in [1..dd] do
    RI:=[D[2^(d-1)],D[2^(d-1)],D[2^(d-1)]];
    for j in [2..d] do
      Add(RI,D[2^(d-1)+2^(j-2)]);
      od;
    Add(R,RI);
    od;
  return R;
  end;
RVOND(4,[ 1, 1, 2, 1, 2, 3, 2, 0, 0, 0, 2, 0, 2, 3, 3 ]);[[0],[0,0],[1,1,1],[1,1,1,2],[1,1,1,2,3],[0,0,0,0,0,0]];

RKVOND:=function(dd,D)
  local d,j,R,RI;
  R:=[];
  for d in [1..dd] do
    RI:=[D[2^(d-1)]];
    for j in [2..d] do
      Add(RI,D[2^(d-1)+2^(j-2)]);
      od;
    Add(R,RI);
    od;
  return R;
  end;
RKVOND(4,[ 1, 1, 2, 1, 2, 3, 2, 0, 0, 0, 2, 0, 2, 3, 3 ]);[[1],[1,2],[1,2,3],[0,0,0,0]];

R1:=[[1],[0,0],[0,1,0]];
R2:=[[1],[1,1]];
SCHNICK:=function(R1,R2)#alle Fortsetzungen von R1 konstant und R2 ergaenzt
  #global COMPDIAGSTABERZ,STABMACH,DOPPELSTAB,HMACH,RKVOND;
  local D0,D1,D2,DD,DDD,S0,S1,S2,SD,SD1,SD2,H,K,t,ORBS,dd;
  dd:=Size(R1);
  D0:=DIAG(R1);
  D1:=DIAG(R1{[1..dd-1]});
  D2:=DIAG(R2);
  #folgendes aus S:=STABAUSD4(dd-1,D);
  D1:=COMPDIAGSTABERZ(D1);Remove(D1,1);
  D2:=COMPDIAGSTABERZ(D2);Remove(D2,1);
  S1:=STABMACH(dd-1,D1);
  if not SAGE then Print("\nDOPPELSTAB S1: \c"); t:=Runtime(); fi;
  SD1:=DOPPELSTAB(dd,S1);
  if not SAGE then Print(Runtime()-t); fi;
  S2:=STABMACH(dd-1,D2);
  if not SAGE then Print("\nDOPPELSTAB S2: \c"); t:=Runtime(); fi;
  SD2:=DOPPELSTAB(dd,S2);
  if not SAGE then Print(Runtime()-t); fi;
  if not SAGE then Print("\nIntersection(S1,S2): \c"); t:=Runtime(); fi;
  S:=Intersection(Group(SD1),Group(SD2));
  if not SAGE then Print(Runtime()-t); fi;
  if not SAGE then Print("\nHMACH: \c"); t:=Runtime(); fi;
  H:=HMACH(dd);
  if not SAGE then Print(Runtime()-t); fi;
  if not SAGE then Print("\nConcatenation(List(S),H): \c"); t:=Runtime(); fi;
  K:=Group(Concatenation(SmallGeneratingSet(S),H));
  if not SAGE then Print(Runtime()-t); fi;
  D0:=COMPDIAGSTABERZ(D0);Remove(D0,1);
  S0:=STABMACH(dd,D0);
  if not SAGE then Print("\nIntersection(S0,K): \c"); t:=Runtime(); fi;
  K:=Intersection(Group(S0),K);
  if not SAGE then Print(Runtime()-t); fi;

  DD:=Tuples([0..1],dd);;#Print(Size(DD));
  DDD:=[];
  for i in [1..2^dd] do
    DDD[i]:=DIAG(Concatenation(R2,[DD[i]])){[2..2^dd]};
    od;
  ORBS:=OrbitsDomain(K,DDD,Permuted);;#Print(Size(ORBS));
  #Print(List(ORBS,i->Size(i)));Print("\c");
  D0:=DIAG(R1);Remove(D0,1);
  #List(ORBS,i->IdSmallGroup(PcgsOfR(RVOND(dd,D0+2*i[1]))));
  #Print(Collected(List(ORBS,i->IdSmallGroup(PcgsOfR(RVOND(dd,D0+2*i[1]))))));
  return List(ORBS,i->RKVOND(dd,i[1]));
  end;

R1:=[[1],[0,0],[0,1,0]];
R2:=[[1],[0,1]];ORBS:=SCHNICK(R1,R2);Size(ORBS);
R2:=[[1],[1,1]];ORBS:=SCHNICK(R1,R2);Size(ORBS);

ERGS2:=[[[[[1]],[[1]]]]];
ERGS2[1][1];[[[1]],[[1]]];
GESAMTDILIST:=[[1]];
SCHNACK:=function(dd,CMPD)
  local jj,R,R1,R1R2,TEILDILIST,ORBI,ORB,ID,ts;
  if not SAGE then Exec("date"); fi;
  ts:=Runtime();
  ERGS2[dd]:=[];GESAMTDILIST[dd]:=[];
  for R1 in ERGS1[dd] do
    if not SAGE then Print("\n***R1=",R1); fi;
    TEILDILIST:=[];
    for jj in [1..Size(ERGS2[dd-1])] do R1R2:=ERGS2[dd-1][jj]; if R1{[1..dd-1]}=R1R2[1] then
      if not SAGE then Print("\n...R1,R1R2=\n",R1,"\n",R1R2,"\n"); fi;
      ORBI:=SCHNICK(R1,R1R2[2]);
      #1#Print("\nORBI=",ORBI,Size(ORBI),"\n",R1R2,"...\n");
      if not SAGE then Print("\nSize(ORBI)=",Size(ORBI)); fi;
      if not SAGE then Print("\n",jj," von ",Size(ERGS2[dd-1]),": Size(GESAMTDILIST[dd])=",Size(GESAMTDILIST[dd]),"\n"); fi;
      for ORB in ORBI do
        R:=R1+2*ORB;
        D:=DIAG(R);
        #a#Remove(D,1);
        #a#RV:=RVOND(dd,D);
        #a#ID:=IdSmallGroup(PcgsOfR(RV));
        ID:=CMPD(dd,D,false);
        #a#Print(" ",ID,"\c");
        if not ID in TEILDILIST then
          Add(TEILDILIST,ID);
          Add(ERGS2[dd],[R1,ORB]);
          fi;
        if not ID in GESAMTDILIST[dd] then
          Add(GESAMTDILIST[dd],ID);
          if not SAGE then Print("*\c"); fi;
          else if not SAGE then Print(".\c"); fi; fi;
        od;
      fi; od;
    od;
  Print("\n",List(GESAMTDILIST,i->Size(i)));
  Print("\n",[ 1, 6, 19, 60, 158, 442, 1122, 2945],Runtime()-ts,"\n");
  if not SAGE then Exec("date"); fi;
  end;

COMPDIAG5RR:=function(dd,D,flag) return RMINSUCH(D)[1]; end;
ProfileFunctions(SCHNACK,SCHNICK,RMINSUCH,COMPDIAG7E);
ClearProfile();

#-----------
KANTENZUEGE(10);
ERGS1[4];
ßERGS2:=[[[[[1]],[[1]]]]];
ERGS2[1][1];[[[1]],[[1]]];
GESAMTDILIST:=[[1]];
SCHNACK(2,COMPDIAG5RR);#16#6
SCHNACK(3,COMPDIAG5RR);#32#19
SCHNACK(4,COMPDIAG5RR);#64#60
#SCHNACK(5,COMPDIAG5RR);#128#158
#SCHNACK(6,COMPDIAG5RR);#256#442
#SCHNACK(7,COMPDIAG5RR);#512#1122
#SCHNACK(8,COMPDIAG5RR);#1024#2945
DisplayProfile();


--------------------neu ab 2018:

D:=[ 0, 1, 1, 2, 1, 2, 3, 2, 0, 0, 0, 2, 0, 2, 3, 3 ];
C:=COMPDIAG7E(D);
RV:=RMINSUCH(D);
[ [ [ 1 ], [ 3, 3 ], [ 3, 3, 1 ], [ 3, 2, 2, 0 ] ],
  [ rec( ALPHA := [ 0, 2, 3, 1 ], BETA := [ 0, 3, 1, 2 ], HRES := [ 7, 4, 14, 8 ],
          LD := [ , 4, 4, 2, 4, 2, 1, 4, 3, 4, 4, 3, 4, 3, 3, 4 ],
          LRES := [ 1, 7, 4, 6, 14, 12, 15, 9, 8, 2, 5, 3, 11, 13, 10, 16 ] ) ] ]
#ALPHA gibt die Umwandlung von 0,1,2,3 in neue an, BETA umgekehrt
#LD sind die verbrauchten Stellen
#LRES die Diagonale aus HRES
#D und R sind beides DK und RK, also die verkürzten D und R

R:=RV[1];
D:=DIAG(R);
RVOND(D);
RKVOND(D);

Ziel ist neues RMAXSUCH auf Basis von XSAMMEL für Folge 3,4,6,7...
oder ersteinmal RMAXSUCH2 und RMAXSUCH4 auf Basis RMAXSUCH

 D:=[ 0, 1, 1, 2, 1, 2, 3, 2, 0, 0, 0, 2, 0, 2, 3, 3 ];
D1:=[ 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1 ];
D2:=[ 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1 ];
2*D1+D2=D;

RMAXSUCH2:=function(D) #sucht RMAX 
  local SD,S,STUFE,LRES,LNEU,V,VNEU,VARIANTEN,NEUE_VARIANTEN,RR,RMIN,RNEU,
  HRES,KRES,LD,ORBZU,ORBS,ONEU;
  SD:=Size(D); S:=LogInt(SD,2); STUFE:=0; RMIN:=[];
  #ORBZU:=COMPDIAG6E(S,D,0);
  #RMINSUCH#ORBZU:=COMPDIAG7E(D);
  ORBZU:=COMPDIAGSTABERZ(D);
  #RMINSUCH#VARIANTEN:=[rec(LD:=[],HRES:=[],LRES:=[1],ALPHA:=[0],BETA:=[0])];
  VARIANTEN:=[rec(LD:=[],HRES:=[],LRES:=[1])];
  for STUFE in [1..S] do 
    #Print("\nSTUFE=",STUFE);
    NEUE_VARIANTEN:=[];
    RNEU:=[0];
    for V in VARIANTEN do
      HRES:=V.HRES;LRES:=V.LRES;LD:=V.LD;
      ORBS:=[];
      for i in [2..SD] do if not IsBound(LD[i]) then
        #RMINSUCH#ALPHA:=List(V.ALPHA);BETA:=List(V.BETA);
        KRES:=[i];
        for j in HRES do Add(KRES,XORMAT[i][j]); od;
        #RMINSUCH#RR:=List(KRES,i->DNEU(D[i]));
        RR:=List(KRES,i->D[i]);
        if RR>RNEU then NEUE_VARIANTEN:=[]; RNEU:=RR; fi;
        if RR=RNEU then
          LNEU:=List(LRES,j->XORMAT[i][j]);
          ONEU:=List(LNEU,j->ORBZU[j]);#Print("O");
          if not (ONEU in ORBS) then
            Add(ORBS,ONEU);
            VNEU:=StructuralCopy(V);
            Add(VNEU.HRES,i);
            VNEU.LRES:=Concatenation(LRES,LNEU);
            for i in LNEU do VNEU.LD[i]:=STUFE; od;
            #RMINSUCH#VNEU.ALPHA:=ALPHA; VNEU.BETA:=List(BETA);
            Add(NEUE_VARIANTEN,VNEU);
            fi;
          #Print("P");
          fi;
        fi; od;
      od;
    VARIANTEN:=NEUE_VARIANTEN;
    Add(RMIN,RNEU);
    #Print(", VARIANTEN=",Size(VARIANTEN));
    od;
  return [RMIN,VARIANTEN];
  end;

D1; RMAXSUCH2(D1);
D2; RMAXSUCH2(D2);

C1:=COMPDIAGSTABERZ(D1);
C2:=COMPDIAGSTABERZ(D2);
D1L:=List(C1); Remove(D1L,1); STABMACH(4,D1L);
D2L:=List(C2); Remove(D2L,1); STABMACH(4,D2L);

STABMACH2:=function(D) #beginnt mit D und mit neutralem Element
  local C,C1,PHITAB;
  C:=COMPDIAGSTABERZ(D);
  C1:=List(C); Remove(C1,1);
  PHITAB:=STABMACH(LogInt(Size(C),2),C1);
  PHITAB:=List(PHITAB,i->PermList(Concatenation([1],List(ListPerm(i),j->j+1))));
  return PHITAB;
  end;

STABMACH(4,D1L);
P:=STABMACH2(D1);

RVOND4:=function(D) # erwartet neutrales Element mit
  local D0,R;
  D0:=List(D);Remove(D0,1);
  R:=RKVOND(LogInt(Size(D),2),D0);
  return R;
  end;

RMAXSUCH4:=function(D)
  local D1,D2,D3,D1MVAR,D2MVAR,D3MVAR,S1,S2,S3,L,HMAX,KMAX,LMAX,i,iter,p0,q,SD,RMAX,RMAXEND;
  SD:=Size(D); RMAX:=true; RMAXEND:=true;
  D1:=List(D,i->Int(i/2));
  D2:=List(D,i->i mod 2);
  D3:=List(D,i->((i mod 2)+Int(i/2)) mod 2);
  D1MVAR:=RMAXSUCH2(D1); S1:=Group(STABMACH2(DIAG(D1MVAR[1])));
  D2MVAR:=RMAXSUCH2(D2); S2:=Group(STABMACH2(DIAG(D2MVAR[1])));
  D3MVAR:=RMAXSUCH2(D3); S3:=Group(STABMACH2(DIAG(D3MVAR[1])));
  #Print("\n",D1MVAR[1],"\n",D2MVAR[1],"\n",D3MVAR[1]);
  #if DIAG(D2MVAR[1]){[1..SD/2]}=D2{[1..SD/2]} and D2MVAR[1]>D3MVAR[1] then Print("#"); return RVOND4(D); fi;
  #Print("\n",D1MVAR[1],"\n",D2MVAR[1],"\n",D3MVAR[1],D1MVAR[1]>D2MVAR[1] and D2MVAR[1]>D3MVAR[1],"\n\n");
  HMAX:=Maximum(D1MVAR[1],D2MVAR[1],D3MVAR[1]); LMAX:=[];
  if HMAX=D1MVAR[1] then
    iter:=Iterator(S1);
    p0:=Permuted(D2,PermList(D1MVAR[2][1].LRES)^-1);
    for i in iter do if RMAX then
      q:=Permuted(p0,i); if q>D2 then Print("\n12",q); RMAX:=RMAXEND; fi;
      #q[2]:=1-q[2];
      LMAX:=Maximum(LMAX,q);
      fi; od;
    iter:=Iterator(S1);
    p0:=Permuted(D3,PermList(D1MVAR[2][1].LRES)^-1);
    for i in iter do if RMAX then
      q:=Permuted(p0,i); if q>D2 then Print("\n13",q); RMAX:=RMAXEND; fi;
      #q[2]:=1-q[2];
      LMAX:=Maximum(LMAX,q);
      fi; od;
    fi;
  if HMAX=D2MVAR[1] then 
    iter:=Iterator(S2);
    p0:=Permuted(D1,PermList(D2MVAR[2][1].LRES)^-1);
    for i in iter do if RMAX then
      q:=Permuted(p0,i); if q>D2 then Print("\n21",q); RMAX:=RMAXEND; fi;
      #q[2]:=1-q[2];
      LMAX:=Maximum(LMAX,q);
      fi; od;
    iter:=Iterator(S2);
    p0:=Permuted(D3,PermList(D2MVAR[2][1].LRES)^-1);
    for i in iter do if RMAX then
      q:=Permuted(p0,i); if q>D2 then Print("\n23",q); RMAX:=RMAXEND; fi;
      #q[2]:=1-q[2];
      LMAX:=Maximum(LMAX,q);
      fi; od;
    fi;
  if HMAX=D3MVAR[1] then 
    iter:=Iterator(S3);
    p0:=Permuted(D1,PermList(D3MVAR[2][1].LRES)^-1);
    for i in iter do if RMAX then
      q:=Permuted(p0,i); if q>D2 then Print("\n31",q); RMAX:=RMAXEND; fi;
      #q[2]:=1-q[2];
      LMAX:=Maximum(LMAX,q);
      fi; od;
    iter:=Iterator(S3);
    p0:=Permuted(D2,PermList(D3MVAR[2][1].LRES)^-1);
    for i in iter do if RMAX then
      q:=Permuted(p0,i); if q>D2 then Print("\n32",q); RMAX:=RMAXEND; fi;
      #q[2]:=1-q[2];
      LMAX:=Maximum(LMAX,q);
      fi; od;
    fi;
  #if RMAX and DIAG(HMAX)=D1 then return RVOND4(D); else return [[0]]; fi;
  KMAX:=DIAG(HMAX);
  #LMAX[2]:=1-LMAX[2];
  DMAX:=2*KMAX+LMAX;
  RMAX:=RVOND4(DMAX);
  #if D1MVAR[1]>D2MVAR[1] and D2MVAR[1]>D3MVAR[1] then Print("\n",D1,"\n",D2,"\n",D3,"\n",D1MVAR[1],"\n",D2MVAR[1],"\n",D3MVAR[1],D1MVAR[1]>D2MVAR[1] and D2MVAR[1]>D3MVAR[1],"\n",RVOND4(D),"\n",RMAX,"\n\n"); fi;
  #return [D1,D2,D3,D1MVAR,D2MVAR,D3MVAR,PP,LMAX,RMAX];
  return RMAX;
  end;

D:=[ 0, 3, 1, 0, 1, 0, 2, 1 ];
DIAG(RMAXSUCH4(D)); #[ 0, 1, 1, 3, 3, 0, 0, 0 ]
DIAG(RMINSUCH(D)[1]);#[ 0, 1, 3, 3, 3, 2, 0, 0 ]


D:=[ 0, 1, 1, 2, 1, 2, 3, 2, 0, 0, 0, 2, 0, 2, 3, 3 ];
RMINSUCH(D);#[ [ [ 1 ], [ 3, 3 ], [ 3, 3, 1 ], [ 3, 2, 2, 0 ] ],
RM:=RMAXSUCH4(D);
DX:=DIAG([ [ 0 ], [ 1, 1 ], [ 1, 1, 0 ], [ 1, 1, 1, 0 ] ]);#0011110011110000
DY:=DIAG([ [ 1 ], [ 1, 1 ], [ 1, 1, 1 ], [ 1, 0, 0, 0 ] ]);#0111111010000001

#----# 0b SCHNACK weitestgehend ohne RMAXSUCH4 geht, #-----------#
#.. dazu oben RMAXSUCH4 von [1] auf [3] machen (alle 1- raus) und 2K+L statt K+2L
#.. dann GESAMTDILIST in GM sortiert merken
#.. schließlich in ??? verwerfen wenn D3>D2 ist.

ALPHA:=[0];#global weil von DNEU veraendert
BETA:=[0];

DNEU:=function(d)
  local dneu,i;
  if not IsBound(ALPHA[d+1]) then
    dneu:=Size(BETA);
    for i in [dneu,dneu-1..1] do Add(BETA,XORMAT[d+1][BETA[i]+1]-1); od;
    for i in [1..dneu] do ALPHA[BETA[dneu+i]+1]:=dneu+i-1; od;
    fi;
  dneu:=ALPHA[d+1];
  return dneu;
  end;

ALPHA:=[0];BETA:=[0];
DNEU(2);ALPHA;BETA;
DNEU(7);ALPHA;BETA;
DNEU(6);ALPHA;BETA;


AFLAG:=true;
DGANZNEU:=function(d,D1D2D3)
  local dneu;
  dneu:=DNEU(d);
  if dneu=0 then return 0; fi;
  if dneu=1 then if D1D2D3[d]<>D1D2D3[3] then AFLAG:=false; fi; return 3; fi;
  if dneu=2 then return 1; fi;
  if dneu=3 then return 2; fi;
  end;

RMINSUCH:=function(D) #Kopie, eigentlich RMAXSUCH, beginnend mit [3] statt mit [1]
  local SD,S,STUFE,LRES,LNEU,V,VNEU,VARIANTEN,NEUE_VARIANTEN,RR,RMIN,RNEU,
  HRES,KRES,LD,ORBZU,ORBS,ONEU,RD,RBIT1,RBIT2,D1,D2,D3,D1MVAR,D2MVAR,D3MVAR;
  SD:=Size(D); S:=LogInt(SD,2); STUFE:=0; RMIN:=[]; 
  #D1:=List(D,i->Int(i/2));
  #D2:=List(D,i->i mod 2);
  #D3:=List(D,i->((i mod 2)+Int(i/2)) mod 2);
  #D1MVAR:=RMAXSUCH2(D1);
  #D2MVAR:=RMAXSUCH2(D2);
  #D3MVAR:=RMAXSUCH2(D3);
  #if D2MVAR[1]>D1MVAR[1] or D3MVAR[1]>D2MVAR[1] then return [[[0]],[]]; fi;
  D1:=Collected(COMPDIAGSTABERZ(List(D,i->Int(i/2))));
  D2:=Collected(COMPDIAGSTABERZ(List(D,i->i mod 2)));
  D3:=Collected(COMPDIAGSTABERZ(List(D,i->((i mod 2)+Int(i/2)) mod 2)));
  RD:=RVOND4(D); 
    RBIT1:=List(RD,i->List(i,j->Int(j/2))); #Print(RD,RBIT1);
    RBIT2:=List(RD,i->List(i,j->j mod 2)); #Print(RBIT2);
  #ORBZU:=COMPDIAG6E(S,D,0);
  ORBZU:=COMPDIAG7E(D);
  VARIANTEN:=[rec(LD:=[],HRES:=[],LRES:=[1],ALPHA:=[0],BETA:=[0])];
  for STUFE in [1..S] do 
    Print("\nSTUFE=",STUFE);
    NEUE_VARIANTEN:=[];
    RNEU:=[];
    for V in VARIANTEN do
      HRES:=V.HRES;LRES:=V.LRES;LD:=V.LD;
      ORBS:=[];
      for i in [2..SD] do if not IsBound(LD[i]) then
        ALPHA:=List(V.ALPHA);BETA:=List(V.BETA);
        KRES:=[i];
        for j in HRES do Add(KRES,XORMAT[i][j]); od;
        AFLAG:=true;
        RR:=List(KRES,i->DGANZNEU(D[i],[D1,D2,D3]));#Print("\n",RR,"\n",RBIT1[STUFE],"\n",RBIT2[STUFE]);
      if AFLAG then
        if List(RR,j->Int(j/2))>RBIT1[STUFE] then 
          Print("\na",RR,"\n",RBIT1[STUFE],"\n",RBIT2[STUFE],ALPHA,BETA);
          return [[[0]],[]]; fi;
        if List(RR,j->Int(j/2))=RBIT1[STUFE] and List(RR,j->j mod 2)>RBIT2[STUFE] then
          Print("\nb",RR,"\n",RBIT1[STUFE],"\n",RBIT2[STUFE],ALPHA,BETA); 
          return [[[0]],[]]; fi;
        if List(RR,j->Int(j/2))=RBIT1[STUFE] and List(RR,j->j mod 2)=RBIT2[STUFE] then
          Print("\n",RR,"\n",RBIT1[STUFE],"\n",RBIT2[STUFE],ALPHA,BETA);
          RNEU:=RR; 
          LNEU:=List(LRES,j->XORMAT[i][j]);
          ONEU:=List(LNEU,j->ORBZU[j]);#Print("O");
          if not (ONEU in ORBS) then
            Add(ORBS,ONEU);
            VNEU:=StructuralCopy(V);
            Add(VNEU.HRES,i);
            VNEU.LRES:=Concatenation(LRES,LNEU);
            for i in LNEU do VNEU.LD[i]:=STUFE; od;
            VNEU.ALPHA:=ALPHA; VNEU.BETA:=List(BETA);
            Add(NEUE_VARIANTEN,VNEU);
            fi;
          #Print("P");
          fi;
         fi;
        fi; od;
      od;
    VARIANTEN:=NEUE_VARIANTEN;
    if RNEU<>[] then Add(RMIN,RNEU); fi;
    #Print(", VARIANTEN=",Size(VARIANTEN));
    od;
  return [RMIN,VARIANTEN];
  end;

SCHNICK:=function(R1,R2)#alle Fortsetzungen von R1 konstant und R2 ergaenzt
  #global COMPDIAGSTABERZ,STABMACH,DOPPELSTAB,HMACH,RKVOND;
  local D0,D1,D2,DD,DDD,S0,S1,S2,SD,SD1,SD2,H,K,t,ORBS,dd;
  dd:=Size(R1);
  D0:=DIAG(R1);
  D1:=DIAG(R1{[1..dd-1]});
  D2:=DIAG(R2);
  #folgendes aus S:=STABAUSD4(dd-1,D);
  D1:=COMPDIAGSTABERZ(D1);Remove(D1,1);
  D2:=COMPDIAGSTABERZ(D2);Remove(D2,1);
  S1:=STABMACH(dd-1,D1);
  if not SAGE then Print("\nDOPPELSTAB S1: \c"); t:=Runtime(); fi;
  SD1:=DOPPELSTAB(dd,S1);
  if not SAGE then Print(Runtime()-t); fi;
  S2:=STABMACH(dd-1,D2);
  if not SAGE then Print("\nDOPPELSTAB S2: \c"); t:=Runtime(); fi;
  SD2:=DOPPELSTAB(dd,S2);
  if not SAGE then Print(Runtime()-t); fi;
  if not SAGE then Print("\nIntersection(S1,S2): \c"); t:=Runtime(); fi;
  S:=Intersection(Group(SD1),Group(SD2));
  if not SAGE then Print(Runtime()-t); fi;
  if not SAGE then Print("\nHMACH: \c"); t:=Runtime(); fi;
  H:=HMACH(dd);
  if not SAGE then Print(Runtime()-t); fi;
  if not SAGE then Print("\nConcatenation(List(S),H): \c"); t:=Runtime(); fi;
  K:=Group(Concatenation(SmallGeneratingSet(S),H));
  if not SAGE then Print(Runtime()-t); fi;
  D0:=COMPDIAGSTABERZ(D0);Remove(D0,1);
  S0:=STABMACH(dd,D0);
  if not SAGE then Print("\nIntersection(S0,K): \c"); t:=Runtime(); fi;
  K:=Intersection(Group(S0),K);
  if not SAGE then Print(Runtime()-t); fi;

  DD:=Tuples([0..1],dd);;#Print(Size(DD));
  DDD:=[];
  for i in [1..2^dd] do
    DDD[i]:=DIAG(Concatenation(R2,[DD[i]])){[2..2^dd]};
    od;
  ORBS:=OrbitsDomain(K,DDD,Permuted);;#Print(Size(ORBS));
  Add(OM,ORBS);
  #Print(List(ORBS,i->Size(i)));Print("\c");
  D0:=DIAG(R1);Remove(D0,1);
  #List(ORBS,i->IdSmallGroup(PcgsOfR(RVOND(dd,D0+2*i[1]))));
  #Print(Collected(List(ORBS,i->IdSmallGroup(PcgsOfR(R03/04/2018(dd,D0+2*i[1]))))));
  return Reversed(List(ORBS,i->RKVOND(dd,Maximum(i))));
  end;

SCHNACK:=function(dd,CMPD)
  local jj,R,R1,R1R2,TEILDILIST,ORBI,ORB,ID,ts,ZM;
  if not SAGE then Exec("date"); fi;
  ts:=Runtime(); ZM:=0;
  ERGS2[dd]:=[];GESAMTDILIST[dd]:=[];
  for R1 in Reversed(ERGS1[dd]) do
    if not SAGE then Print("\n***R1=",R1); fi;
    TEILDILIST:=[];
    for jj in [1..Size(ERGS2[dd-1])] do R1R2:=ERGS2[dd-1][jj]; if R1{[1..dd-1]}=R1R2[1] then
      if not SAGE then Print("\n...R1,R1R2=\n",R1,"\n",R1R2,"\n"); fi;
      ORBI:=SCHNICK(R1,R1R2[2]); ZM:=ZM+Size(ORBI);
      #1#Print("\nORBI=",ORBI,Size(ORBI),"\n",R1R2,"...\n");
      if not SAGE then Print("\nSize(ORBI)=",Size(ORBI)); fi;
      if not SAGE then Print("\n",jj," von ",Size(ERGS2[dd-1]),": Size(GESAMTDILIST[dd])=",Size(GESAMTDILIST[dd]),"\n"); fi;
      for ORB in ORBI do
        R:=2*R1+ORB;
        D:=DIAG(R);
        #a#Remove(D,1);
        #a#RV:=RVOND(dd,D);
        #a#ID:=IdSmallGroup(PcgsOfR(RV));
        ID:=CMPD(dd,D,false);
        #a#Print(" ",ID,"\c");
        if DIAG(ID) then
          Add(ERGS2[dd],[R1,ORB]);
          Add(GESAMTDILIST[dd],ID);
          if not SAGE then Print("*\c"); fi;
          else if not SAGE then Print(".\c"); fi; fi;
        od;
      fi; od;
    od;
  Print("\n",List(GESAMTDILIST,i->Size(i)),ZM);
  Print("\n",[ 1, 6, 19, 60, 158, 442, 1122, 2945],Runtime()-ts,"\n");
  if not SAGE then Exec("date"); fi;
  end;

b[ 3, 2, 3, 3 ]
[ 1, 1, 1, 1 ]
[ 0, 0, 1, 0 ][ 0, 1, 2, 3 ][ 0, 1, 2, 3 ][ [ 0 ] ]
brk> D; RMAXSUCH4(D); #RMINSUCH(D)[1];
[ 0, 3, 3, 3, 3, 3, 2, 1, 2, 2, 3, 0, 2, 1, 1, 1, 2, 2, 2, 1, 3, 0, 1, 1, 3, 0, 1, 1, 1, 1, 1, 2 ]
[ [ 1 ], [ 1, 1 ], [ 1, 1, 1 ], [ 1, 1, 1, 1 ], [ 1, 1, 1, 1, 1 ] ]
[ [ 1 ], [ 1, 1 ], [ 1, 1, 1 ], [ 1, 1, 1, 1 ], [ 1, 1, 1, 1, 0 ] ]
[ [ 1 ], [ 1, 1 ], [ 1, 1, 1 ], [ 1, 1, 1, 1 ], [ 1, 1, 1, 1, 0 ] ][ [ 3 ], [ 3, 3 ], [ 3, 3, 2 ], [ 2, 2, 3, 2 ], [ 2, 2, 2, 3, 3 ] ]

COMPDIAG5RS:=function(dd,D,flag) if RMAXSUCH4(D)<>RMINSUCH(D)[1] then Error(); fi; return RMAXSUCH4(D); end;
COMPDIAG5RS:=function(dd,D,flag) return RMINSUCH(D)[1]; end;
COMPDIAG5RS:=function(dd,D,flag) return RMAXSUCH4(D); end;

ProfileFunctions(SCHNACK,SCHNICK,RMAXSUCH4,RMINSUCH,COMPDIAGSTABERZ,STABMACH2,RMAXSUCH2);

#-----------
KANTENZUEGE(10);
ERGS1[4];
ERGS2:=[[[[[1]],[[1]]]]];
ERGS2[1][1];[[[1]],[[1]]];
GESAMTDILIST:=[[[[3]]]];
ClearProfile();ZM:=0;
SCHNACK(2,COMPDIAG5RS);#16#6
SCHNACK(3,COMPDIAG5RS);#32#19
SCHNACK(4,COMPDIAG5RS);#64#60
#SCHNACK(5,COMPDIAG5RS);#128#158
#SCHNACK(6,COMPDIAG5RS);#256#442
#SCHNACK(7,COMPDIAG5RS);#512#1122
#SCHNACK(8,COMPDIAG5RS);#1024#2945
DisplayProfile();

#---# also bis hierher geht nur RMAXSUCH4(D), RMINSUCH ist mit AFLAG verbastelt.
#---# deshalb das Sortieren neu überlegen.

RMAXSUCH25:=function(D) #sucht RMAX und zwar so daß D1 erhalten bleibt
  local SD,S,STUFE,LRES,LNEU,V,VNEU,VARIANTEN,NEUE_VARIANTEN,RR,RMIN,RNEU,
  HRES,KRES,LD,ORBZU,ORBS,ONEU,RVERGLEICH;
  SD:=Size(D); S:=LogInt(SD,2); STUFE:=0; RMIN:=[]; 
  RVERGLEICH:=List(RVOND4(D),i->List(i,j->Int(j/2)));
  #ORBZU:=COMPDIAG6E(S,D,0);
  #RMINSUCH#ORBZU:=COMPDIAG7E(D);
  ORBZU:=COMPDIAG7E(D); Print("\nORBZU:",ORBZU,RVERGLEICH); #wieso stand da COMPDIAGSTABERZ?, 
  #RMINSUCH#VARIANTEN:=[rec(LD:=[],HRES:=[],LRES:=[1],ALPHA:=[0],BETA:=[0])];
  VARIANTEN:=[rec(LD:=[],HRES:=[],LRES:=[1])];
  for STUFE in [1..S] do 
    Print("\nSTUFE=",STUFE);
    NEUE_VARIANTEN:=[];
    RNEU:=[0];
    for V in VARIANTEN do
      HRES:=V.HRES;LRES:=V.LRES;LD:=V.LD;
      ORBS:=[];
      for i in [2..SD] do if not IsBound(LD[i]) then
        #RMINSUCH#ALPHA:=List(V.ALPHA);BETA:=List(V.BETA);
        KRES:=[i];
        for j in HRES do Add(KRES,XORMAT[i][j]); od;
        #RMINSUCH#RR:=List(KRES,i->DNEU(D[i]));
        RR:=List(KRES,i->D[i]);#Print("\n",RR,KRES);
    #if List(RR,i->Int(i/2))=RVERGLEICH[STUFE] then
        if RR>RNEU then NEUE_VARIANTEN:=[]; RNEU:=RR; fi;
        if RR=RNEU then
          LNEU:=List(LRES,j->XORMAT[i][j]);
          ONEU:=List(LNEU,j->ORBZU[j]);#Print("O");
          ONEU:=List(LNEU,j->j);
          if not (ONEU in ORBS) then
            Add(ORBS,ONEU);
            VNEU:=StructuralCopy(V);
            Add(VNEU.HRES,i);
            VNEU.LRES:=Concatenation(LRES,LNEU);
            for i in LNEU do VNEU.LD[i]:=STUFE; od;
            #RMINSUCH#VNEU.ALPHA:=ALPHA; VNEU.BETA:=List(BETA);
            Add(NEUE_VARIANTEN,VNEU);
            fi;
          #Print("P");
          fi;
      #fi;
        fi; od;
      od;
    VARIANTEN:=NEUE_VARIANTEN;
    Add(RMIN,RNEU);
    Print(", VARIANTEN=",Size(VARIANTEN));
    od;
  return [RMIN,VARIANTEN];
  end;

RMAXSUCH5:=function(D)
  local D1,D2,D3,D1MVAR,D2MVAR,D3MVAR,S1,S2,S3,L,HMAX,KMAX,LMAX,i,iter,p0,q,SD,RMAX,RNEU;
  SD:=Size(D); RMAX:=[[0]];
  D1:=List(D,i->Int(i/2));
  D2:=List(D,i->i mod 2);
  D3:=List(D,i->((i mod 2)+Int(i/2)) mod 2);
  D1MVAR:=RMAXSUCH2(D1);
  D2MVAR:=RMAXSUCH2(D2);
  D3MVAR:=RMAXSUCH2(D3);
  Print("\n",D,"\n",D1,"\n",D2,"\n",D3,"\n",D1MVAR[1],"\n",D2MVAR[1],"\n",D3MVAR[1],"\n");
  HMAX:=Maximum(D1MVAR[1],D2MVAR[1],D3MVAR[1]); LMAX:=[];
  if HMAX=D1MVAR[1] then Print("\n1");
    p0:=Permuted(D2,PermList(D1MVAR[2][1].LRES)^-1);
    RNEU:=RMAXSUCH25(2*DIAG(HMAX)+p0)[1];#Print(2*DIAG(HMAX)+p0,RNEU);
    if RNEU>RMAX then RMAX:=RNEU; fi;Print(RMAX);
    p0:=Permuted(D3,PermList(D1MVAR[2][1].LRES)^-1);
    RNEU:=RMAXSUCH25(2*DIAG(HMAX)+p0)[1];#Print(2*DIAG(HMAX)+p0,RNEU);
    if RNEU>RMAX then RMAX:=RNEU; fi;Print(RMAX);
    fi;
  if HMAX=D2MVAR[1] then Print("\n2");
    p0:=Permuted(D1,PermList(D2MVAR[2][1].LRES)^-1);
    RNEU:=RMAXSUCH25(2*DIAG(HMAX)+p0)[1];
    if RNEU>RMAX then RMAX:=RNEU; fi;Print(RMAX);
    p0:=Permuted(D3,PermList(D2MVAR[2][1].LRES)^-1);
    RNEU:=RMAXSUCH25(2*DIAG(HMAX)+p0)[1];
    if RNEU>RMAX then RMAX:=RNEU; fi;Print(RMAX);
    fi;
  if HMAX=D3MVAR[1] then Print("\n3");
    p0:=Permuted(D1,PermList(D3MVAR[2][1].LRES)^-1);
    RNEU:=RMAXSUCH25(2*DIAG(HMAX)+p0)[1];
    if RNEU>RMAX then RMAX:=RNEU; fi;Print(RMAX);
    p0:=Permuted(D2,PermList(D3MVAR[2][1].LRES)^-1);
    RNEU:=RMAXSUCH25(2*DIAG(HMAX)+p0)[1];
    if RNEU>RMAX then RMAX:=RNEU; fi;Print(RMAX);
    fi;
  return RMAX;
  end;

DGANZNEU:=function(d)
  local dneu;
  dneu:=DNEU(d);
  if dneu=0 then return 0; fi;
  if dneu=1 then return 3; fi;
  if dneu=2 then return 1; fi;
  if dneu=3 then return 2; fi;
  end;

RMAXSUCH:=function(D) # aus RMINSUCH, aber beginnend mit [3]
  local SD,S,STUFE,LRES,LNEU,V,VNEU,VARIANTEN,NEUE_VARIANTEN,RR,RMIN,RNEU,
  HRES,KRES,LD,ORBZU,ORBS,ONEU;
  SD:=Size(D); S:=LogInt(SD,2); STUFE:=0; RMIN:=[];
  #ORBZU:=COMPDIAG6E(S,D,0);
  ORBZU:=COMPDIAG7E(D);
  VARIANTEN:=[rec(LD:=[],HRES:=[],LRES:=[1],ALPHA:=[0],BETA:=[0])];
  for STUFE in [1..S] do 
    #Print("\nSTUFE=",STUFE);
    NEUE_VARIANTEN:=[];
    RNEU:=[0];
    for V in VARIANTEN do
      HRES:=V.HRES;LRES:=V.LRES;LD:=V.LD;
      ORBS:=[];
      for i in [2..SD] do if not IsBound(LD[i]) then
        ALPHA:=List(V.ALPHA);BETA:=List(V.BETA);
        KRES:=[i];
        for j in HRES do Add(KRES,XORMAT[i][j]); od;
        RR:=List(KRES,i->DGANZNEU(D[i]));
        if RR>RNEU then NEUE_VARIANTEN:=[]; RNEU:=RR; fi;#max geht schneller als min
        if RR=RNEU then
          LNEU:=List(LRES,j->XORMAT[i][j]);
          ONEU:=List(LNEU,j->ORBZU[j]);#Print("O");
          if not (ONEU in ORBS) then
            Add(ORBS,ONEU);
            VNEU:=StructuralCopy(V);
            Add(VNEU.HRES,i);
            VNEU.LRES:=Concatenation(LRES,LNEU);
            for i in LNEU do VNEU.LD[i]:=STUFE; od;
            VNEU.ALPHA:=ALPHA; VNEU.BETA:=List(BETA);
            Add(NEUE_VARIANTEN,VNEU);
            fi;
          #Print("P");
          fi;
        fi; od;
      od;
    VARIANTEN:=NEUE_VARIANTEN;
    Add(RMIN,RNEU);
    #Print(", VARIANTEN=",Size(VARIANTEN));
    od;
  return [RMIN,VARIANTEN];
  end;

SCHNICK:=function(R1,R2)#alle Fortsetzungen von R1 konstant und R2 ergaenzt
  #global COMPDIAGSTABERZ,STABMACH,DOPPELSTAB,HMACH,RKVOND;
  local D0,D1,D2,DD,DDD,S0,S1,S2,SD,SD1,SD2,H,K,t,ORBS,dd;
  dd:=Size(R1);
  D0:=DIAG(R1);
  D1:=DIAG(R1{[1..dd-1]});
  D2:=DIAG(R2);
  #folgendes aus S:=STABAUSD4(dd-1,D);
  D1:=COMPDIAGSTABERZ(D1);Remove(D1,1);
  D2:=COMPDIAGSTABERZ(D2);Remove(D2,1);
  S1:=STABMACH(dd-1,D1);
  if not SAGE then Print("\nDOPPELSTAB S1: \c"); t:=Runtime(); fi;
  SD1:=DOPPELSTAB(dd,S1);
  if not SAGE then Print(Runtime()-t); fi;
  S2:=STABMACH(dd-1,D2);
  if not SAGE then Print("\nDOPPELSTAB S2: \c"); t:=Runtime(); fi;
  SD2:=DOPPELSTAB(dd,S2);
  if not SAGE then Print(Runtime()-t); fi;
  if not SAGE then Print("\nIntersection(S1,S2): \c"); t:=Runtime(); fi;
  S:=Intersection(Group(SD1),Group(SD2));
  if not SAGE then Print(Runtime()-t); fi;
  if not SAGE then Print("\nHMACH: \c"); t:=Runtime(); fi;
  H:=HMACH(dd);
  if not SAGE then Print(Runtime()-t); fi;
  if not SAGE then Print("\nConcatenation(List(S),H): \c"); t:=Runtime(); fi;
  K:=Group(Concatenation(SmallGeneratingSet(S),H));
  if not SAGE then Print(Runtime()-t); fi;
  D0:=COMPDIAGSTABERZ(D0);Remove(D0,1);
  S0:=STABMACH(dd,D0);
  if not SAGE then Print("\nIntersection(S0,K): \c"); t:=Runtime(); fi;
  K:=Intersection(Group(S0),K);
  if not SAGE then Print(Runtime()-t); fi;

  DD:=Tuples([0..1],dd);;#Print(Size(DD));
  DDD:=[];
  for i in [1..2^dd] do
    DDD[i]:=DIAG(Concatenation(R2,[DD[i]])){[2..2^dd]};
    od;
  ORBS:=OrbitsDomain(K,DDD,Permuted);;#Print(Size(ORBS));
  Add(OM,ORBS);
  #Print(List(ORBS,i->Size(i)));Print("\c");
  D0:=DIAG(R1);Remove(D0,1);
  #List(ORBS,i->IdSmallGroup(PcgsOfR(RVOND(dd,D0+2*i[1]))));
  #Print(Collected(List(ORBS,i->IdSmallGroup(PcgsOfR(R03/04/2018(dd,D0+2*i[1]))))));
  return Reversed(SortedList(List(ORBS,i->RKVOND(dd,Maximum(i)))));
  end;

SCHNACK:=function(dd,CMPD)
  local jj,R,R1,R1R2,TEILDILIST,ORBI,ORB,ID,ts,ZM,rr;
  if not SAGE then Exec("date"); fi;
  ts:=Runtime(); ZM:=0;
  ERGS2[dd]:=[];GESAMTDILIST[dd]:=[];
  for rr in [1..Size(ERGS1[dd])] do
    R1:=Reversed(ERGS1[dd])[rr];
    if not SAGE then Print("\n***R1=",R1); fi;
    TEILDILIST:=[];
    for jj in [1..Size(ERGS2[dd-1])] do R1R2:=ERGS2[dd-1][jj]; if R1{[1..dd-1]}=R1R2[1] then
      if not SAGE then Print("\n...R1,R1R2=\n",R1,"\n",R1R2,"\n"); fi;
      ORBI:=SCHNICK(R1,R1R2[2]); ZM:=ZM+Size(ORBI);
      #1#Print("\nORBI=",ORBI,Size(ORBI),"\n",R1R2,"...\n");
      if not SAGE then Print("\nSize(ORBI)=",Size(ORBI)); fi;
      if not SAGE then Print("\n",jj," von ",Size(ERGS2[dd-1])," in ",rr," von ",Size(ERGS1[dd]),": Size(GESAMTDILIST[dd])=",Size(GESAMTDILIST[dd]),"\n"); fi;
      for ORB in ORBI do
        R:=2*R1+ORB;
        D:=DIAG(R);
        #a#Remove(D,1);
        #a#RV:=RVOND(dd,D);
        #a#ID:=IdSmallGroup(PcgsOfR(RV));
        ID:=CMPD(dd,D,false);
        #a#Print(" ",ID,"\c");
        if not ID in GESAMTDILIST[dd] then
         #if DIAG(ID)<>D then Print("\n",ID,DIAG(ID),D); fi;
          Add(ERGS2[dd],[R1,ORB]); 
          Add(GESAMTDILIST[dd],ID);
          if not SAGE then Print("*\c"); fi;
          else if not SAGE then Print(".\c"); fi; fi;
        od;
      fi; od;
    od;
  Print("\n",List(GESAMTDILIST,i->Size(i)),ZM);
  Print("\n",[ 1, 6, 19, 60, 158, 442, 1122, 2945],Runtime()-ts,"\n");
  if not SAGE then Exec("date"); fi;
  end;

COMPDIAG5RS:=function(dd,D,flag) if RMAXSUCH4(D)<>[[0]] and RMAXSUCH4(D)<>RMAXSUCH5(D) then Error(); fi; return RMAXSUCH5(D); end;
COMPDIAG5RS:=function(dd,D,flag) if RMAXSUCH4(D)=[[0]] and D=DIAG(RMAXSUCH5(D)) then Error(); fi; return RMAXSUCH5(D); end;
COMPDIAG5RS:=function(dd,D,flag) return RMINSUCH(D)[1]; end;
COMPDIAG5RS:=function(dd,D,flag) return RMAXSUCH5(D); end;
COMPDIAG5RS:=function(dd,D,flag) return RMAXSUCH(D)[1]; end;

ProfileFunctions(SCHNACK,SCHNICK,RMAXSUCH4,RMINSUCH,COMPDIAGSTABERZ,STABMACH2,RMAXSUCH2,RMAXSUCH5,RMAXSUCH);

#-----------
KANTENZUEGE(10);
ERGS1[4];
ERGS2:=[[[[[1]],[[1]]]]];
ERGS2[1][1];[[[1]],[[1]]];
GESAMTDILIST:=[[[[3]]]];
ClearProfile();ZM:=0;
SCHNACK(2,COMPDIAG5RS);#16#6
SCHNACK(3,COMPDIAG5RS);#32#19
SCHNACK(4,COMPDIAG5RS);#64#60
#SCHNACK(5,COMPDIAG5RS);#128#158
#SCHNACK(6,COMPDIAG5RS);#256#442
#SCHNACK(7,COMPDIAG5RS);#512#1122
#SCHNACK(8,COMPDIAG5RS);#1024#2945
DisplayProfile();

#---Fehlersuche 1226 statt 1222
GM:=[];
for ERGEBNIS in ERGS2[7] do
  R:=2*ERGEBNIS[1]+ERGEBNIS[2];
  RMAX:=RMINSUCH(DIAG(R))[1];
  if not RMAX in GM then Add(GM,RMAX); else Error(R); fi;
  od;

R:=[ [ 3 ], [ 3, 3 ], [ 3, 3, 3 ], [ 3, 3, 3, 3 ], [ 3, 3, 3, 2, 2 ], [ 3, 2, 2, 3, 3, 3 ],
  [ 3, 2, 2, 2, 2, 0, 0 ] ];
R1:=2*ERGS2[7][506][1]+ERGS2[7][506][2];
R2:=2*ERGS2[7][627][1]+ERGS2[7][627][2];
RMINSUCH(DIAG(R1))[1]=RMINSUCH(DIAG(R2))[1];#true
RMAXSUCH(DIAG(R1))[1]=RMAXSUCH(DIAG(R2))[1];#false
RMAXSUCH5(DIAG(R1))=RMAXSUCH5(DIAG(R2));#false
RMAXSUCH5(DIAG(R1))=RMAXSUCH(DIAG(R1))[1];#true
RMAXSUCH5(DIAG(R2))=RMAXSUCH(DIAG(R2))[1];#true

#mit
R1:=[ [ 3 ], [ 3, 3 ], [ 3, 3, 3 ], [ 3, 3, 3, 3 ], [ 3, 3, 3, 3, 3 ], [ 3, 3, 2, 2, 2, 2 ], [ 3, 3, 3, 2, 2, 0, 0 ] ];
R2:=[ [ 3 ], [ 3, 3 ], [ 3, 3, 3 ], [ 3, 3, 3, 3 ], [ 3, 3, 3, 2, 2 ], [ 3, 2, 2, 3, 3, 3 ], [ 3, 2, 2, 2, 2, 0, 0 ] ];

RMAXSUCH25(DIAG(2*ERGS2[7][506][1]+ERGS2[7][506][2]))[1];#..23012
RMAXSUCH25(DIAG(ERGS2[7][506][1]+2*ERGS2[7][506][2]))[1];#..23012
RMAXSUCH25(DIAG(2*ERGS2[7][627][1]+ERGS2[7][627][2]))[1];#..22122
RMAXSUCH25(DIAG(ERGS2[7][627][1]+2*ERGS2[7][627][2]))[1];#..22112

