FORTSETZ:=function(HRES,y,D) #setzt HRES,y zu einem gültigen pcgs fort und macht ein PHI daraus
  local PHI,i,j,k,HRESNEU,nochnichtgefunden;
  PHI:=[];HRESNEU:=[];
  i:=1;
  repeat
    if i<=Size(HRES) then HRESNEU[i]:=HRES[i]; fi;
    if i=Size(HRES)+1 then HRESNEU[i]:=y; fi;
    if i>Size(HRES)+1 then
      nochnichtgefunden:=true;
      for k in [1..Size(D)] do if nochnichtgefunden and not k in PHI then
        if D[k]=D[2^(i-1)] then 
          nochnichtgefunden:=false;
          for j in [1..Size(PHI)] do if nochnichtgefunden=false then 
            if D[XORMAT[PHI[j]+1][k+1]-1]<>D[2^(i-1)+j] then nochnichtgefunden:=true; fi;
            fi; od;
          if nochnichtgefunden=false then HRESNEU[i]:=k; fi;
          fi; fi; od;
      fi;
    PHI[2^(i-1)]:=HRESNEU[i];#ja!!!
    for j in [1..2^(i-1)-1] do
      PHI[2^(i-1)+j]:=XORMAT[PHI[j]+1][PHI[2^(i-1)]+1]-1;#ja!!!
      od;
    i:=i+1;
    until 2^(i-1)=Size(D)+1;
  return PermList(PHI);
  end;

FORTSETZ([1,2],4,[1,0,0,1,1,3,0]);();
FORTSETZ([1],3,[1,0,0,1,1,3,0]);(2,3)(4,5);
FORTSETZ([], 4,[1,0,0,1,1,3,0]);(1,4,5)(2,3,7);

LRESAUSHRES:=function(HRES)
  local LRES,i,j;
  LRES:=[];
  for i in [1..Size(HRES)] do
    LRES[2^(i-1)]:=HRES[i];
    for j in [1..Size(LRES)-1] do
      LRES[2^(i-1)+j]:=XORMAT[LRES[j]+1][HRES[i]+1]-1;
      od;
    od;
  return LRES;
  end;
LRESAUSHRES([1,2,27]);[ 1, 2, 3, 27, 26, 25, 24 ];
  
STABERZ:=function(MENGE,HRES,STAB,D)
  local MENGENEU,STABNEU,x,y,i,DRIN,PHI,DK,PHI0;
  #1
  x:=MENGE[1];STABNEU:=STAB;
  LRES:=LRESAUSHRES(HRES);
  #2
  MENGENEU:=[];
  for y in MENGE do
    DRIN:=true;
    ##Print("\ny=",y," ",D[y]," ",D[x]);
    if D[y]<>D[x] then DRIN:=false; fi;
    for i in [1..Size(LRES)] do
     ##Print(" i=",i," ",D[XORMAT[HRES[i]+1][y+1]-1]," ",D[XORMAT[HRES[i]+1][x+1]-1]);
      if D[XORMAT[LRES[i]+1][y+1]-1]<>D[XORMAT[LRES[i]+1][x+1]-1] then DRIN:=false; fi;
      od;
    if DRIN then Add(MENGENEU,y); fi;
    od;
  ##Print("\nMENGENEU=",MENGENEU,"\n\c");
  #3
  repeat
    y:=MENGENEU[1];
    #4
    DK:=List(D);Remove(DK,1);
    ##Print("\n",MENGENEU,HRES,y,D,"\n\c");
    PHI:=FORTSETZ(HRES,y,D);
    #5
    if not PHI in STABNEU then Add(STABNEU,PHI); fi;
    ##Print("\n",PHI,STABNEU,"\n\c");
    #6
    MENGENEU:=Difference(MENGENEU,Orbit(Group(STABNEU),x));
  #7
    until MENGENEU=[];
  #8
  return STABNEU;
  end;
 
STAB:=[];
# 0  1  2  3  4  5  6  7
# e  a  b ab  c ac bc abc
D:=[ 1, 0, 0, 1, 1, 3, 0];#D
STAB:=STABERZ([4..7],[1,2],STAB,D);
STAB:=STABERZ([2..7],[1],STAB,D);
STAB:=STABERZ([1..7],[],STAB,D);
Size(STAB);
Size(Group(STAB));#6 laut 4788 und 4752R

STAB:=[];
#  0  1  2  3  4  5  6  7  8  9 10  11 12  13  14   15
#  e  a  b ab  c ac bc abc d ad bd abd cd acd bcd abcd
D:=[ 1, 0, 0, 1, 1, 1, 0, 0, 0, 0,  1, 0,  1,  0,   0];#F
STAB:=STABERZ([8..15],[1,2,4],STAB,D);
STAB:=STABERZ([4..15],[1,2],STAB,D);
STAB:=STABERZ([2..15],[1],STAB,D);
STAB:=STABERZ([1..15],[],STAB,D);
Size(STAB);
Size(Group(STAB));#72

STAB:=[];
#  0 1  2  3  4  5  6  7  8  9 10  11 12  13  14   15
#  e a  b ab  c ac bc abc d ad bd abd cd acd bcd abcd
D:=[ 1, 0, 0, 1, 1, 1, 0, 1, 1, 1,  0, 1,  0,  1,   1];#G
STAB:=STABERZ([8..15],[1,2,4],STAB,D);
STAB:=STABERZ([4..15],[1,2],STAB,D);
STAB:=STABERZ([2..15],[1],STAB,D);
STAB:=STABERZ([1..15],[],STAB,D);
Size(STAB);
Size(Group(STAB));#120

STAB:=[];
#  0 1  2  3  4  5  6  7  8  9 10  11 12  13  14   15
#  e a  b ab  c ac bc abc d ad bd abd cd acd bcd abcd
D:=[ 1, 1, 1];#C
#STAB:=STABERZ([8..15],[1,2,4],STAB,D);
#STAB:=STABERZ([4..15],[1,2],STAB,D);
STAB:=STABERZ([2..3],[1],STAB,D);
STAB:=STABERZ([1..3],[],STAB,D);
Size(STAB);
Size(Group(STAB));#6

STAB:=[];
#  0 1  2  3  4  5  6  7  8  9 10  11 12  13  14   15
#  e a  b ab  c ac bc abc d ad bd abd cd acd bcd abcd
D:=[ 1, 0, 0];#B
#STAB:=STABERZ([8..15],[1,2,4],STAB,D);
#STAB:=STABERZ([4..15],[1,2],STAB,D);
STAB:=STABERZ([2..3],[1],STAB,D);
STAB:=STABERZ([1..3],[],STAB,D);
Size(STAB);
Size(Group(STAB));#2

STAB:=[];
# 0  1  2  3  4  5  6  7  8  9 10  11 12  13  14   15
# e  a  b ab  c ac bc abc d ad bd abd cd acd bcd abcd
D:=[ 1, 0, 0, 1, 1, 3, 0, 2, 1, 0, 0, 1, 1, 3, 0];#D'
STAB:=STABERZ([8..15],[1,2,4],STAB,D);
STAB:=STABERZ([4..15],[1,2],STAB,D);
STAB:=STABERZ([2..15],[1],STAB,D);
STAB:=STABERZ([1..15],[],STAB,D);
Size(STAB);
Size(Group(STAB));#48

STAB:=[];
# 0  1  2  3  4  5  6  7  8  9 10  11 12  13  14   15
# e  a  b ab  c ac bc abc d ad bd abd cd acd bcd abcd
D:=[ 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1];#C''
STAB:=STABERZ([8..15],[1,2,4],STAB,D);
STAB:=STABERZ([4..15],[1,2],STAB,D);
STAB:=STABERZ([2..15],[1],STAB,D);
STAB:=STABERZ([1..15],[],STAB,D);
Size(STAB);
Size(Group(STAB));#576

#-----------
#Test STABERZ mit P25: Ergebnis Size(STAB)=16 22 29 37 46
COMPDIAGSTABERZ:=function(D)#aus COMPDIAG4 mit geändertem RETURN
  local RET,i,j,k,l,jkl,jkli,dj,dk,dl,RET2,reti,SD,DD;
  SD:=Size(D);DD:=[];
  for i in [1..SD] do DD[i]:=D[i]+2; od;
  for jkli in [1..(SD-1)*(SD-2)/6] do
    jkl:=JKLLISTE[jkli];
    j:=jkl[1];k:=jkl[2];l:=jkl[3];
    dj:=D[j];dk:=D[k];dl:=D[l];
#Print("\n",jkl," ",dj," ",dk," ",dl);
    if dj=1 and dk=dl then DD[j]:=1; fi;
    if dj=0 and dk<>dl then DD[j]:=0; fi;
    if dk=1 and dj=dl then DD[k]:=1; fi;
    if dk=0 and dj<>dl then DD[k]:=0; fi;
    if dl=1 and dk=dj then DD[l]:=1; fi;
    if dl=0 and dk<>dj then DD[l]:=0; fi;
    od;
#Print("\n",DD);
  return DD;
  end;

STABMACH:=function(dd,D)
  local STAB,ddd;
  STAB:=[];
  for ddd in [dd,dd-1..1] do 
    STAB:=STABERZ([2^(ddd-1)..2^dd-1],List([1..ddd-1],i->2^(i-1)),STAB,D);
    od;
  return STAB;
  end;

STABTAB:=[];
GRUPTAB:=[];
for dd in [1..10] do
  STABTAB[dd]:=[];
  GRUPTAB[dd]:=[];
  Print("\n\ndd=",dd);
  for kd in [1..a[dd]] do
    x:=DIAG(KANTENZUG(dd,kd));
    x:=COMPDIAGSTABERZ(x);
    Remove(x,1);
    D:=x;
    STABTAB[dd][kd]:=STABMACH(dd,D);
    GRUPTAB[dd][kd]:=Group(STABTAB[dd][kd]);
    Print("\n",kd," ",Size(STABTAB[dd][kd])," ",Size(Group(STABTAB[dd][kd])));#576
    od;
  od;

dd=1
1 1 1

dd=2
1 2 2
2 2 2
3 3 6

dd=3
1 4 8
2 4 24
3 3 6
4 4 24

dd=4
1 7 192
2 7 1344
3 6 72
4 5 48
5 6 576
6 5 120

dd=5
1 11 21504
2 11 322560
3 9 1152
4 8 2304
5 9 64512
6 6 1920
7 6 720

dd=6
1 16 10321920
2 16 319979520
3 13 110592
4 12 516096
5 13 30965760
6 8 184320
7 8 51840
8 7 23040
9 8 40320

dd=7
1 22 20478689280
2 22 1290157424640
3 18 49545216
4 17 495452160
5 18 61436067840
6 11 82575360
7 10 3317760
8 9 4423680
9 9 1451520
10 9 2580480

dd=8
1 29 165140150353920
2 29 20972799094947840
3 24 95126814720
4 23 1965954170880
5 24 495420451061760
6 15 158544691200
7 13 1274019840
8 12 3963617280
9 11 394813440
10 11 185794560
11 11 990904320
12 10 348364800



D1:=[1,0,0,1,0,1,1,0,1,1,1,0,1,1,1];
D2:=[0,0,1,0,1,1,1,0,1,1,1,1,1,1,0];
S1:=STABMACH(4,D1);
S2:=STABMACH(4,D2);
G1:=Group(S1);
G2:=Group(S2);
I1:=Intersection(G1,G2);

D1:=[1,0,0,1,0,1,1,0,1,1,1,0,1,1,1];
D2:=[0,0,1,0,1,1,1];
S1:=STABMACH(4,D1);
S2:=STABMACH(3,D2);
G1:=Group(S1);
G2:=Group(S2);
I1:=Intersection(G1,G2);

D1:=[1,0,0,1,0,1,1,0,1,1,1,0,1,1,1];
D2:=[0,0,1,0,1,1,1,0,1,1,1,1,1,1,0];
S1:=STABMACH(4,D1);
G1:=Group(S1);
ORB:=Orbit(G1,D2,Permuted);;
Size(ORB);
Filtered(ORB,i->i{[1..7]}=[0,0,1,0,1,1,1]);

ORB:=Orbit(G1,D2,Permuted);;Size(ORB);#60
ORB1:=Orbit(A[4],D1,Permuted);#168
ORB12:=Orbit(A[4],[1,0,2,1,2,3,3,0,3,3,3,2,3,3,1],Permuted);;Size(ORB12);#10080=168*60
#also ist das ORB schon mal vollständig.
DIAG(R5([ [ [ 0, 2 ], [ 1, 2, 3 ] ], [ 0, 3, 3, 2 ] ]));
STAB12:=Stabiliser(A[4],[1,0,2,1,2,3,3,0,3,3,3,2,3,3,1],Permuted);
#=Group([ (1,4)(2,8)(3,12)(6,9)(7,13)(11,14) ])

i1:=1;i2:=2;dd:=4;
I1:=Intersection(GRUPTAB[dd][i1],GRUPTAB[dd][i2]);Size(I1);
SGSI1:=SmallGeneratingSet(I1);;Size(SGSI1);
I1:=Group(SGSI1);
RT:=RightTransversal(A[dd],I1);Size(RT);#210
DX1:=DIAG(KANTENZUG(dd,i1));
DX2:=DIAG(KANTENZUG(dd,i2));
DX:=[]; for i in [2..Size(DX1)] do DX[i-1]:=DX1[i]+2*DX2[i]; od; DX;
ORB:=Orbit(A[dd],DX,Permuted);;Size(ORB);#210
Size(RT)=Size(ORB);
R:=[
  [0],
  [0,0],
  [DX[1],DX[1],DX[1]],
  [DX[2],DX[2],DX[2],DX[3]],
  [DX[4],DX[4],DX[4],DX[5],DX[6]],
  [DX[8],DX[8],DX[8],DX[9],DX[10],DX[12]]
  ];

G:=PcgsOfR(R);AU:=AutomorphismGroup(G);Size(AU)/Size(I1);

############################
dd:=4;
D1:=[1,0,0,1,0,1,1,0,1,1,1,0,1,1,1];
D2:=[0,0,1,0,1,1,1,0,1,1,1,1,1,1,0];
XY:=[1,0,2,1,2,3,3,0,3,3,3,2,3,3,1];
ORB:=Orbit(A[dd],XY,Permuted);;Size(ORB);#10080
ORB:=Collected(List(A[dd],a->Permuted(XY,a)));;Size(ORB);#auch 10080
ORB:=Collected(Filtered(List(A[dd],a->Permuted(XY,a)),xy->xy{[1..7]}=XY{[1..7]}));;Size(ORB);#
S1:=STABMACH(4,D1);
S2:=STABMACH(4,D2);
G1:=Group(S1);
G2:=Group(S2);
I1:=Intersection(G1,G2);

R:=[[ 1 ],[ 0, 2 ],[ 0, 1, 0 ],[ 0, 0, 0, 1 ]];#227 später
R:=[[ 1 ],[ 0, 2 ],[ 0, 1, 0 ],[ 0, 0, 0, 2 ]];#1<->2
XY:=DIAG(R);
XY:=[ 0, 1, 0, 2, 0, 1, 0, 2, 0, 0, 0, 3, 1, 1, 1, 2 ];
Remove(XY,1);XY;
ORB:=Orbit(A[dd],XY,Permuted);;Size(ORB);#10080
ORB:=Collected(List(A[dd],a->Permuted(XY,a)));;Size(ORB);#auch 10080
ORB:=Collected(Filtered(List(A[dd],a->Permuted(XY,a)),xy->xy{[1..7]}=XY{[1..7]}));;Size(ORB);
?Gibt es also nicht mehr als 6 ===> ? Das wäre sensationell!!!
Doch, bei R:=[[ 1 ],[ 0, 2 ],[ 0, 1, 0 ],[ 0, 0, 0, 1 ]];#227 später
D1:=                       #  #  #     #
 [ 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0 ];
                                    u  u  u  u
[ [ [ 1, 0, 2, 0, 1, 0, 2, 0, 0, 0, 3, 1, 1, 1, 2 ], 2 ], #
  [ [ 1, 0, 2, 0, 1, 0, 2, 0, 0, 1, 2, 1, 1, 0, 3 ], 2 ], +
  [ [ 1, 0, 2, 0, 1, 0, 2, 0, 0, 2, 1, 1, 1, 3, 0 ], 2 ], #
  [ [ 1, 0, 2, 0, 1, 0, 2, 0, 0, 3, 0, 1, 1, 2, 1 ], 2 ], +
  [ [ 1, 0, 2, 0, 1, 0, 2, 0, 1, 0, 2, 1, 0, 1, 3 ], 2 ], 
  [ [ 1, 0, 2, 0, 1, 0, 2, 0, 1, 1, 3, 1, 0, 0, 2 ], 2 ], 
  [ [ 1, 0, 2, 0, 1, 0, 2, 0, 1, 2, 0, 1, 0, 3, 1 ], 2 ], 
  [ [ 1, 0, 2, 0, 1, 0, 2, 0, 1, 3, 1, 1, 0, 2, 0 ], 2 ], 
  [ [ 1, 0, 2, 0, 1, 0, 2, 0, 2, 0, 1, 1, 3, 1, 0 ], 2 ], #
  [ [ 1, 0, 2, 0, 1, 0, 2, 0, 2, 1, 0, 1, 3, 0, 1 ], 2 ], +
  [ [ 1, 0, 2, 0, 1, 0, 2, 0, 3, 0, 0, 1, 2, 1, 1 ], 2 ], 
  [ [ 1, 0, 2, 0, 1, 0, 2, 0, 3, 1, 1, 1, 2, 0, 0 ], 2 ], 
  [ [ 1, 0, 2, 0, 1, 0, 2, 1, 0, 0, 2, 0, 1, 1, 3 ], 2 ], 
  [ [ 1, 0, 2, 0, 1, 0, 2, 1, 0, 1, 3, 0, 1, 0, 2 ], 2 ], 
  [ [ 1, 0, 2, 0, 1, 0, 2, 1, 0, 2, 0, 0, 1, 3, 1 ], 2 ], 
  [ [ 1, 0, 2, 0, 1, 0, 2, 1, 0, 3, 1, 0, 1, 2, 0 ], 2 ], 
  [ [ 1, 0, 2, 0, 1, 0, 2, 1, 1, 0, 3, 0, 0, 1, 2 ], 2 ], +
  [ [ 1, 0, 2, 0, 1, 0, 2, 1, 1, 1, 2, 0, 0, 0, 3 ], 2 ], +
  [ [ 1, 0, 2, 0, 1, 0, 2, 1, 1, 2, 1, 0, 0, 3, 0 ], 2 ], +
  [ [ 1, 0, 2, 0, 1, 0, 2, 1, 1, 3, 0, 0, 0, 2, 1 ], 2 ], +
  [ [ 1, 0, 2, 0, 1, 0, 2, 1, 2, 0, 0, 0, 3, 1, 1 ], 2 ], 
  [ [ 1, 0, 2, 0, 1, 0, 2, 1, 2, 1, 1, 0, 3, 0, 0 ], 2 ], 
  [ [ 1, 0, 2, 0, 1, 0, 2, 1, 3, 0, 1, 0, 2, 1, 0 ], 2 ], +
  [ [ 1, 0, 2, 0, 1, 0, 2, 1, 3, 1, 0, 0, 2, 0, 1 ], 2 ], +
  [ [ 1, 0, 2, 0, 1, 0, 2, 2, 0, 0, 1, 3, 1, 1, 0 ], 2 ], #
  [ [ 1, 0, 2, 0, 1, 0, 2, 2, 0, 1, 0, 3, 1, 0, 1 ], 2 ], +
  [ [ 1, 0, 2, 0, 1, 0, 2, 2, 1, 0, 0, 3, 0, 1, 1 ], 2 ], 
  [ [ 1, 0, 2, 0, 1, 0, 2, 2, 1, 1, 1, 3, 0, 0, 0 ], 2 ], 
  [ [ 1, 0, 2, 0, 1, 0, 2, 3, 0, 0, 0, 2, 1, 1, 1 ], 2 ], 
  [ [ 1, 0, 2, 0, 1, 0, 2, 3, 0, 1, 1, 2, 1, 0, 0 ], 2 ], 
  [ [ 1, 0, 2, 0, 1, 0, 2, 3, 1, 0, 1, 2, 0, 1, 0 ], 2 ], +
  [ [ 1, 0, 2, 0, 1, 0, 2, 3, 1, 1, 0, 2, 0, 0, 1 ], 2 ] ]+
XY:=DIAG(R);
XY:=[ 0, 1, 0, 2, 0, 1, 0, 2, 0, 0, 0, 3, 1, 1, 1, 2 ];
D1:=[ 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0 ];
D2:=[ 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
D3:=[ 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1 ];
D1:=COMPDIAGSTABERZ(D1);
D2:=COMPDIAGSTABERZ(D2);
Remove(D1,1);D1;
Remove(D2,1);D2;
Remove(XY,1);XY;
S1:=STABMACH(4,D1);
S2:=STABMACH(4,D2);
G1:=Group(S1);
G2:=Group(S2);
I1:=Intersection(G1,G2);
ORB:=Collected(Filtered(List(S1,a->Permuted(D2,a)),xy->xy{[1..7]}=D2{[1..7]}));;Size(ORB);
S1A:=Filtered(S1,a->Permuted(D2,a){[1..7]}=D2{[1..7]});;Size(S1A);
S1B:=Filtered(S1,a->Permuted(D3,a){[1..7]}=D3{[1..7]});;Size(S1A);
S2A:=Filtered(S2,a->Permuted(D1,a){[1..7]}=D1{[1..7]});;Size(S1A);
S12:=Group(Concatenation(S1A,S2A));Size(S12);
ORB:=SortedList(Orbit(S12,XY,Permuted));Size(ORB);#schafft # und +, die ersten 16
REST:=Group((8,9)(10,11)(12,13)(14,15),
            (8,10)(9,11)(12,14)(13,15),
            (8,12)(9,13)(10,14)(11,15));
S12:=Group(Concatenation(S1A,S2A,List(REST)));Size(S12);
ORB:=SortedList(Orbit(S12,XY,Permuted));Size(ORB);#schafft # und +, die ersten 16
#mit REST alle 32 geschafft!!! Feierabend! Jetzt noch zu den 64 schaffen
#die 64 entstehen aus 32 dur Umbenennen 1 gegen 2, 
#1 gegen 3 umbenennen geht nicht, weil nur eine 3 da, fürs erste D/2 werden 2 gebraucht
#So, und den benötigten Teilstabilisator kann ich ja aus XSAMMEL für Folge 3_4_6 holen!
  2 [ 1, 1 ] 2 <=== [ 4, 1 ] (2) 

#### [32,48 ] mit P22 ausgerechnet ####
1 [ 0 ] 1 <=== [ 2, 1 ] (1) 
  2 [ 1, 1 ] 2 <=== [ 4, 1 ] (2) 
    3 [ 0, 0, 1 ] 2 <=== [ 8, 2 ] (2) 
      4 [ 0, 0, 1, 0 ] 3 <=== [ 16, 10 ] (3) 
        5 [ 0, 0, 0, 0, 1 ] 2 ===> [ 32, 48 ] (2) 
        5 [ 1, 1, 1, 1, 0 ] 15 2 [ 32, 48 ] (15) 
        5 [ 0, 0, 0, 1, 0 ] 3 ===> [ 32, 48 ] (3) 
        5 [ 0, 0, 0, 1, 1 ] 4 3 [ 32, 48 ] (4) 
        5 [ 1, 1, 1, 0, 0 ] 13 3 [ 32, 48 ] (13) 
        5 [ 1, 1, 1, 0, 1 ] 14 3 [ 32, 48 ] (14) 
        5 [ 0, 0, 1, 0, 0 ] 5 <=== [ 32, 45 ] (5) 
        5 [ 1, 1, 0, 1, 1 ] 12 5 [ 32, 45 ] (12) 
        5 [ 0, 0, 1, 0, 1 ] 6 ===> [ 32, 48 ] (6) 
        5 [ 1, 1, 0, 1, 0 ] 11 6 [ 32, 48 ] (11) 
        5 [ 0, 0, 1, 1, 0 ] 7 ===> [ 32, 48 ] (7) 
        5 [ 0, 0, 1, 1, 1 ] 8 7 [ 32, 48 ] (8) 
        5 [ 1, 1, 0, 0, 0 ] 9 7 [ 32, 48 ] (9) 
        5 [ 1, 1, 0, 0, 1 ] 10 7 [ 32, 48 ] (10) 

RV:=[
[[ 1 ], [ 0, 1 ], [ 0, 1, 0 ], [ 0, 0, 0, 1 ]],#2#[ 0, 0, 0, 0, 1, 1, 1, 1 ]
[[ 1 ], [ 0, 1 ], [ 0, 1, 0 ], [ 1, 1, 1, 0 ]],  #[ 1, 1, 1, 1, 0, 0, 0, 0 ]
[[ 1 ], [ 0, 1 ], [ 0, 1, 0 ], [ 0, 0, 1, 0 ]],#3#[ 0, 0, 1, 1, 0, 0, 1, 1 ]
[[ 1 ], [ 0, 1 ], [ 0, 1, 0 ], [ 0, 0, 1, 1 ]],  #[ 0, 0, 1, 1, 1, 1, 0, 0 ]
[[ 1 ], [ 0, 1 ], [ 0, 1, 0 ], [ 1, 1, 0, 0 ]],  #[ 1, 1, 0, 0, 0, 0, 1, 1 ]
[[ 1 ], [ 0, 1 ], [ 0, 1, 0 ], [ 1, 1, 0, 1 ]],  #[ 1, 1, 0, 0, 1, 1, 0, 0 ]
[[ 1 ], [ 0, 1 ], [ 0, 1, 0 ], [ 0, 1, 0, 1 ]],#6#[ 0, 1, 0, 1, 1, 0, 1, 0 ]
[[ 1 ], [ 0, 1 ], [ 0, 1, 0 ], [ 1, 0, 1, 0 ]],  #[ 1, 0, 1, 0, 0, 1, 0, 1 ]
[[ 1 ], [ 0, 1 ], [ 0, 1, 0 ], [ 0, 1, 1, 0 ]],#7#[ 0, 1, 1, 0, 0, 1, 1, 0 ]
[[ 1 ], [ 0, 1 ], [ 0, 1, 0 ], [ 0, 1, 1, 1 ]],  #[ 0, 1, 1, 0, 1, 0, 0, 1 ]
[[ 1 ], [ 0, 1 ], [ 0, 1, 0 ], [ 1, 0, 0, 0 ]],  #[ 1, 0, 0, 1, 0, 1, 1, 0 ]
[[ 1 ], [ 0, 1 ], [ 0, 1, 0 ], [ 1, 0, 0, 1 ]]   #[ 1, 0, 0, 1, 1, 0, 0, 1 ]
  ];

for i in [1..14] do Print("\n",DIAG(RV[i]){[9..16]}); od;
DX:=COMPDIAGSTABERZ(DIAG(RV[3])){[2..16]};
#[ 1, 0, 3, 2, 1, 0, 3, 0, 0, 1, 1, 0, 0, 1, 1 ]
S:=STABMACH(4,DX);
#[ (), (8,9)(10,11)(12,13)(14,15), (8,12)(9,13)(10,14)(11,15), 
  (2,6)(3,7)(10,14)(11,15), (1,5)(3,7)(9,13)(11,15), 
  (1,10,11)(2,9,8)(5,14,15)(6,13,12) ]
ORB:=Orbit(Group(S),DX,Permuted);
SX:=Group(Concatenation(S,List(REST)));
ORB:=Orbit(SX,DX,Permuted);
#[ [ 1, 0, 3, 2, 1, 0, 3, 0, 0, 1, 1, 0, 0, 1, 1 ], 
  [ 1, 0, 3, 2, 1, 0, 3, 1, 1, 0, 0, 1, 1, 0, 0 ], 
  [ 0, 1, 3, 2, 0, 1, 3, 1, 0, 1, 0, 1, 0, 1, 0 ], 
  [ 0, 1, 3, 2, 0, 1, 3, 0, 1, 0, 1, 0, 1, 0, 1 ] ]
#da fehlen 2, also hole ich erstmal die PHI aus XSAMMEL heraus.

ISOD1D2:=function (D0,D)
  local i,HRESNEU,PHI,nochnichtgefunden;
  i:=1;HRESNEU:=[];PHI:=[];
  repeat

      nochnichtgefunden:=true;
      for k in [1..Size(D)] do if nochnichtgefunden and not k in PHI then
        if D[k]=D0[2^(i-1)] then 
          nochnichtgefunden:=false;
          for j in [1..Size(PHI)] do if nochnichtgefunden=false then 
            if D[XORMAT[PHI[j]+1][k+1]-1]<>D0[2^(i-1)+j] then nochnichtgefunden:=true; fi;
            fi; od;
          if nochnichtgefunden=false then HRESNEU[i]:=k; fi;
          fi; fi; od;

    PHI[2^(i-1)]:=HRESNEU[i];#ja!!!
    for j in [1..2^(i-1)-1] do
      PHI[2^(i-1)+j]:=XORMAT[PHI[j]+1][PHI[2^(i-1)]+1]-1;#ja!!!
      od;

    #Print("\ni=",i,HRESNEU);
    i:=i+1;
    until 2^i>Size(D1)+1;
  return PermList(PHI);
  end;

D1:=COMPDIAGSTABERZ(DIAG(RV[1]));;Remove(D1,1);D1;
D2:=COMPDIAGSTABERZ(DIAG(RV[2]));;Remove(D2,1);D2;
ISOD1D2(D1,D2);

PHIMENGE:=[];
D1:=COMPDIAGSTABERZ(DIAG(RV[1]));;Remove(D1,1);D1;
for i in [1..12] do
  D2:=COMPDIAGSTABERZ(DIAG(RV[i]));Remove(D2,1);Print(D2);
  Add(PHIMENGE,ISOD1D2(D1,D2));
  od;

D1:=COMPDIAGSTABERZ(DIAG(RV[1]));;Remove(D1,1);D1;
#D1:=DIAG(RV[1]);;Remove(D1,1);D1;
List(PHIMENGE,i->Permuted(D1,i));
[ [ 1, 2, 1, 0, 3, 0, 3, 0, 0, 0, 0, 1, 1, 1, 1 ], #()
  [ 1, 2, 1, 0, 3, 0, 3, 1, 1, 1, 1, 0, 0, 0, 0 ], #(8,12)(9,13)(10,14)(11,15), 
  [ 1, 0, 3, 2, 1, 0, 3, 0, 0, 1, 1, 0, 0, 1, 1 ], #(2,4)(3,5)(10,12)(11,13)
  [ 1, 0, 3, 0, 3, 2, 1, 0, 0, 1, 1, 1, 1, 0, 0 ], #(2,6,4)(3,7,5)(10,14,12)(11,15,13)
  [ 1, 0, 3, 0, 3, 2, 1, 1, 1, 0, 0, 0, 0, 1, 1 ], #(2,6,4)(3,7,5)(8,10,12)(9,11,13)
  [ 1, 0, 3, 2, 1, 0, 3, 1, 1, 0, 0, 1, 1, 0, 0 ], #(2,4)(3,5)(8,10,14,12)(9,11,15,13)
  [ 3, 2, 3, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0 ], #(1,5)(3,7)(9,13)(11,15)
  [ 3, 2, 3, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1 ], #(1,5)(3,7)(8,9,12,13)(10,11,14,15)
  [ 3, 0, 1, 2, 3, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0 ], #(1,3,7,5)(2,4)(9,11,15,13)(10,12)
  [ 3, 0, 1, 0, 1, 2, 3, 0, 1, 1, 0, 1, 0, 0, 1 ], #(1,3,5)(2,6,4)(9,11,13)(10,14,12)
  [ 3, 0, 1, 0, 1, 2, 3, 1, 0, 0, 1, 0, 1, 1, 0 ], #(1,3,5)(2,6,4)(8,9,10,15,14,13)(11,12)
  [ 3, 0, 1, 2, 3, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1 ] ] #(1,3,7,5)(2,4)(8,9,10,13)(11,14,15,12)
  
D1:=COMPDIAGSTABERZ(DIAG(RV[1]){[1..8]});;Remove(D1,1);D1;
S:=STABMACH(3,D1);
G:=Group(S);Size(G);
Orbit(G,[ 1, 2, 1, 0, 3, 0, 3]);
[ [ 1, 2, 1, 0, 3, 0, 3 ], 
  [ 1, 0, 3, 2, 1, 0, 3 ], 
  [ 1, 0, 3, 0, 3, 2, 1 ], 
  [ 3, 0, 1, 2, 3, 0, 1 ], 
  [ 3, 0, 1, 0, 1, 2, 3 ], 
  [ 3, 2, 3, 0, 1, 0, 1 ] ]
#aha, ich muss Stab(D/2) erweitert anwenden.

############jetzt alles zu RV[1] durchlaufenlassen
R:=RV[1]{[1..3]};
ENUM:=EnumeratorOfTuples([0,1],4);
SCHONFERTIG:=[];
for i in [1..16] do if not IsBound(SCHONFERTIG) then
  Print("\ni=",i," R[4]=",R[4]);
  R[4]:=ENUM[i];
  D1:=DIAG(R);Remove(D1,1);
  for PHI in PHIMENGE do
    SCHONFERTIG[PositionSorted(ENUM,Permuted(D2,PHI){[8,9,10,12]})]:=1;
    od;
  fi; od;

##########jetzt mit ListPerm
dd:=4;
R:=[[1],[2,3],[0,0,0],[0,0,1,0]];#===>[ 64, 216 ]#[ (), (4,5)(6,7), (4,6)(5,7) ]#16
R:=[[1],[2,3],[0,1,2],[0,2,0,0]];#===>[ 64, 216 ]#[ (), (4,5)(6,7), (4,6)(5,7) ]#32
D:=DIAG(R);Remove(D,1);
S:=STABMACH(3,D{[1..7]});[ (), (4,5)(6,7), (4,6)(5,7) ];
L:=List(S,s->ListPerm(s,2^(dd-1)-1));
for LL in L do LL[2^(dd-1)]:=2^(dd-1); 
  for i in [2^(dd-1)+1..2^dd-1] do
    LL[i]:=LL[i-2^(dd-1)]+2^(dd-1);
    od;
  od; L;
SD:=List(L,s->PermList(s));[ (), (4,5)(6,7)(12,13)(14,15), (4,6)(5,7)(12,14)(13,15) ];
H:=Group(
  (8,9)(10,11)(12,13)(14,15),
  (8,10)(9,11)(12,14)(13,15),
  (8,12)(9,13)(10,14)(11,15)
  );
K:=Group(Concatenation(SD,List(H)));Size(K);
ORB:=Orbit(K,D,Permuted);
SortedList(List(ORB,i->i{[8,8,8,9,10,12]}));
Size(Orbit(K,D,Permuted));16;
#so, beim zweiten R fehlt wieder was
gap> Orbit(K,D,Permuted);
[ [ 1, 2, 3, 0, 0, 0, 0, 0, 2, 0, 2, 0, 3, 2, 1 ], 
  [ 1, 2, 3, 0, 0, 0, 0, 0, 2, 0, 2, 3, 0, 1, 2 ], 
  [ 1, 2, 3, 0, 0, 0, 0, 0, 2, 0, 2, 2, 1, 0, 3 ], 
  [ 1, 2, 3, 0, 0, 0, 0, 2, 0, 2, 0, 3, 0, 1, 2 ], 
  [ 1, 2, 3, 0, 0, 0, 0, 2, 0, 2, 0, 1, 2, 3, 0 ], 
  [ 1, 2, 3, 0, 0, 0, 0, 0, 3, 2, 1, 0, 2, 0, 2 ], 
  [ 1, 2, 3, 0, 0, 0, 0, 3, 0, 1, 2, 2, 0, 2, 0 ], 
  [ 1, 2, 3, 0, 0, 0, 0, 2, 1, 0, 3, 0, 2, 0, 2 ], 
  [ 1, 2, 3, 0, 0, 0, 0, 1, 2, 3, 0, 2, 0, 2, 0 ], 
  [ 1, 2, 3, 0, 0, 0, 0, 0, 2, 0, 2, 1, 2, 3, 0 ], 
  [ 1, 2, 3, 0, 0, 0, 0, 2, 0, 2, 0, 0, 3, 2, 1 ], 
  [ 1, 2, 3, 0, 0, 0, 0, 2, 0, 2, 0, 2, 1, 0, 3 ], 
  [ 1, 2, 3, 0, 0, 0, 0, 3, 0, 1, 2, 0, 2, 0, 2 ], 
  [ 1, 2, 3, 0, 0, 0, 0, 0, 3, 2, 1, 2, 0, 2, 0 ], 
  [ 1, 2, 3, 0, 0, 0, 0, 1, 2, 3, 0, 0, 2, 0, 2 ], 
  [ 1, 2, 3, 0, 0, 0, 0, 2, 1, 0, 3, 2, 0, 2, 0 ] ]

#########gleich ganze Orbits
R:=[[1]];#<=== [ 8, 2 ]#
R:=[[1],[0,2]];#<=== [ 16, 3 ]#
R:=[[1],[1,2]];#<=== [ 16, 4 ]#
R:=[[1],[2,3]];#<=== [ 16, 2 ]#
R:=[[1],[0,2],[0,0,0]];#<=== [ 32, 27 ]#ok
R:=[[1],[0,2],[0,0,1]];#<=== [ 32, 28 ]#ok
R:=[[1],[0,2],[0,1,0]];#<=== [ 32, 22 ]#ok
R:=[[1],[0,2],[0,1,1]];#<=== [ 32, 30 ]#mit D1,D2 ok
R:=[[1],[0,2],[0,1,3]];#<=== [ 32, 25 ]#mit D1,D2 ok
R:=[[1],[0,2],[0,2,2]];#<=== [ 32, 31 ]#ok
R:=[[1],[0,2],[1,1,1]];#<=== [ 32, 29 ]#mit D1,D2 ok
R:=[[1],[0,2],[1,2,3]];#<=== [ 32, 33 ]#mit D1,D2 ok
R:=[[1],[0,2],[1,3,2]];#<=== [ 32, 24 ]#ok
R:=[[1],[1,2],[0,1,1]];#<=== [ 32, 23 ]#ok
R:=[[1],[1,2],[1,1,1]];#<=== [ 32, 35 ]#mit D1,D2 ok
R:=[[1],[1,2],[1,2,2]];#<=== [ 32, 26 ]#ok
R:=[[1],[1,2],[1,2,3]];#<=== [ 32, 32 ]#mit D1,D2 ok
R:=[[1],[2,3],[0,0,0]];#<=== [ 32, 34 ]#ok
R:=[[1],[2,3],[0,1,2]];#<=== [ 32, 21 ]#ok

STABAUSD4:=function(dd,D)#aufpass, Input mit 0, Output ohne 0!
  local S,D1,D2,i,S1,S2;
  D1:=[];D2:=[];
  for i in [1..Size(D)] do
    if D[i]=1 or D[i]=3 then D1[i]:=1; else D1[i]:=0; fi;
    if D[i]=2 or D[i]=3 then D2[i]:=1; else D2[i]:=0; fi;
    od;
  D1:=COMPDIAGSTABERZ(D1);Remove(D1,1);
  D2:=COMPDIAGSTABERZ(D2);Remove(D2,1);
  S1:=STABMACH(dd,D1);
  S2:=STABMACH(dd,D2);
  S:=Intersection(Group(S1),Group(S2));
  return S;
  end;

DOPPELSTAB:=function(dd,S)
  local L,LL;
  L:=List(S,s->ListPerm(s,2^(dd-1)-1));
  for LL in L do LL[2^(dd-1)]:=2^(dd-1); 
    for i in [2^(dd-1)+1..2^dd-1] do
      LL[i]:=LL[i-2^(dd-1)]+2^(dd-1);
      od;
    od; #Display(L);
  SD:=List(L,s->PermList(s));
  return SD;
  end;

HMACH:=function(dd)
  local d,ddd,dddd,i,j,H,L;
  H:=[];ddd:=2^(dd-1);dddd:=2^dd;
  for d in [1..dd-1] do
    L:=[];
    for j in [1..ddd-1] do L[j]:=j; od;
    for j in [ddd..dddd-1] do
      if not IsBound(L[j]) then
        L[j]:=j+2^(d-1);
        L[j+2^(d-1)]:=j;
        fi;
      od;
    Add(H,PermList(L));
    od;
  return H;
  end;
HMACH(4);

RVOND:=function(dd,D)
  local d,j,R,RI;
  R:=[[0],[0,0]];
  for d in [1..dd] do
    RI:=[D[2^(d-1)],D[2^(d-1)],D[2^(d-1)]];
    for j in [2..d] do
      Add(RI,D[2^(d-1)+2^(j-2)]);
      od;
    Add(R,RI);
    od;
  return R;
  end;
RVOND(4,[ 1, 1, 2, 1, 2, 3, 2, 0, 0, 0, 2, 0, 2, 3, 3 ]);[[0],[0,0],[1,1,1],[1,1,1,2],[1,1,1,2,3],[0,0,0,0,0,0]];

RKVOND:=function(dd,D)
  local d,j,R,RI;
  R:=[];
  for d in [1..dd] do
    RI:=[D[2^(d-1)]];
    for j in [2..d] do
      Add(RI,D[2^(d-1)+2^(j-2)]);
      od;
    Add(R,RI);
    od;
  return R;
  end;
RKVOND(4,[ 1, 1, 2, 1, 2, 3, 2, 0, 0, 0, 2, 0, 2, 3, 3 ]);[[1],[1,2],[1,2,3],[0,0,0,0]];


TESTL:=function(R)#alle Fortsetzungen von R
dd:=Size(R)+1;
D:=DIAG(R);#Remove(D,1);
S:=STABAUSD4(dd-1,D);
SD:=DOPPELSTAB(dd,S);
H:=HMACH(dd);
K:=Group(Concatenation(SD,H));Print(Size(K));

DD:=Tuples([0..3],dd);;Print(Size(DD));
DDD:=[];
for i in [1..4^dd] do
  DDD[i]:=DIAG(Concatenation(R,[DD[i]])){[2..2^dd]};
  od;
ORBS:=OrbitsDomain(K,DDD,Permuted);;Print(Size(ORBS));
Print(List(ORBS,i->Size(i)));Print("\c");
Print(Collected(List(ORBS,i->IdSmallGroup(PcgsOfR(RVOND(dd,i[1]))))));
  return ORBS;
  end;

###jetzt Id bestimmen
DMITNULL:=StructuralCopy(List(DDD[8]));Add(DMITNULL,0,1);DMITNULL;
S:=STABAUSD4(DMITNULL);Size(S);
Orbits(S,[1..15]);

############dann wieder ganzes ERGS
ERGS:=[
  [[[1]]],#dd=1
  [[[1],[0,2]],#dd=2
   [[1],[1,2]],
   [[1],[2,3]]],
  ];
dd:=3;
dd:=4;
dd:=5;
dd:=6;
dd:=7;
dd:=8;
ERGS[dd]:=[];GESAMTDILIST:=[];
for ERG in ERGS[dd-1] do
  ORBS:=TESTL(ERG);
  Print("\nSize(ORBS)=",Size(ORBS)," ");
  for oi in ORBS do
    ID:=IdSmallGroup(PcgsOfR(RVOND(dd,oi[1])))[2];
    if not IsBound(GESAMTDILIST[ID]) then 
      GESAMTDILIST[ID]:=ID;
      Add(ERGS[dd],RKVOND(dd,oi[1]));
      Print("\n",Size(ERGS[dd]),"<===",ID," ");
      fi;
    od;
  od;#ok bis dd:=4 schonmal gleiches Ergebnis wie XSAMMELVIEWER4;

############ERGS12
ERGS1:=[
  [[[1]]],#dd=1
  [[[1],[0,0]],#dd=2
   [[1],[0,1]],
   [[1],[1,1]]],
  ];

dd:=3;
R:=[[1],[0,2],[0,1,0]];#[ 32, 22 ]
R:=[[1],[0,2],[0,1,2]];#[ 32, 28 ]
R:=[[1],[0,2],[0,3,0]];#[ 32, 27 ]
R:=[[1],[0,2],[0,3,2]];#[ 32, 30 ]
R:=[[1],[0,2],[2,1,0]];#[ 32, 28 ]
R:=[[1],[0,2],[2,1,2]];#[ 32, 29 ]
R:=[[1],[0,2],[2,3,0]];#[ 32, 31 ]
R:=[[1],[0,2],[2,3,2]];#[ 32, 25 ]#das geht ja wie Brezelbacken
R:=[[1],[2,2],[0,1,0]];#[ 32, 28 ]
R:=[[1],[2,2],[0,1,2]];#[ 32, 23 ]
R:=[[1],[2,2],[0,3,0]];#[ 32, 30 ]
R:=[[1],[2,2],[0,3,2]];#[ 32, 30 ]
R:=[[1],[2,2],[2,1,0]];#[ 32, 29 ]
R:=[[1],[2,2],[2,1,2]];#[ 32, 29 ]
R:=[[1],[2,2],[2,3,0]];#[ 32, 25 ]
R:=[[1],[2,2],[2,3,2]];#[ 32, 35 ]
DIAG(R);[ 0, 1, 0, 2, 0, 1, 0, 2 ];
ID:=IdSmallGroup(PcgsOfR(RVOND(dd,DIAG(R){[2..2^dd]})));


R1:=[[1],[0,0],[0,1,0]];
R2:=[[1],[1,1]];
SCHNICK:=function(R1,R2)#alle Fortsetzungen von R1 konstant und R2 ergänzt
  dd:=Size(R1);
  D0:=DIAG(R1);
  D1:=DIAG(R1{[1..dd-1]});
  D2:=DIAG(R2);
  #folgendes aus S:=STABAUSD4(dd-1,D);
  D1:=COMPDIAGSTABERZ(D1);Remove(D1,1);
  D2:=COMPDIAGSTABERZ(D2);Remove(D2,1);
  S1:=STABMACH(dd-1,D1);
  Print("\nDOPPELSTAB S1: \c");t:=Runtime();
  SD1:=DOPPELSTAB(dd,S1);Print(Runtime()-t);
  S2:=STABMACH(dd-1,D2);
  Print("\nDOPPELSTAB S2: \c");t:=Runtime();
  SD2:=DOPPELSTAB(dd,S2);Print(Runtime()-t);
  Print("\nIntersection(S1,S2): \c");t:=Runtime();
  S:=Intersection(Group(SD1),Group(SD2));Print(Runtime()-t);
  Print("\nHMACH: \c");t:=Runtime();
  H:=HMACH(dd);Print(Runtime()-t);
  Print("\nConcatenation(SD,H): \c");t:=Runtime();
  K:=Group(Concatenation(SD,H));Print(Runtime()-t);
  D0:=COMPDIAGSTABERZ(D0);Remove(D0,1);
  S0:=STABMACH(dd,D0);
  Print("\nIntersection(S0,K): \c");t:=Runtime();
  K:=Intersection(Group(S0),K);Print(Runtime()-t);

  DD:=Tuples([0..1],dd);;#Print(Size(DD));
  DDD:=[];
  for i in [1..2^dd] do
    DDD[i]:=DIAG(Concatenation(R2,[DD[i]])){[2..2^dd]};
    od;
  ORBS:=OrbitsDomain(K,DDD,Permuted);;#Print(Size(ORBS));
  #Print(List(ORBS,i->Size(i)));Print("\c");
  D0:=DIAG(R1);Remove(D0,1);
  #List(ORBS,i->IdSmallGroup(PcgsOfR(RVOND(dd,D0+2*i[1]))));
  #Print(Collected(List(ORBS,i->IdSmallGroup(PcgsOfR(RVOND(dd,D0+2*i[1]))))));
  return List(ORBS,i->RKVOND(dd,i[1]));
  end;

R1:=[[1],[0,0],[0,1,0]];
R2:=[[1],[0,1]];ORBS:=SCHNICK(R1,R2);Size(ORBS);
R2:=[[1],[1,1]];ORBS:=SCHNICK(R1,R2);Size(ORBS);



#########weiter mit ERGS2
ok R1<>ORB geht nicht weil eine von 60 wohl auf ERGS1 aufbaut
ok SD:=Intersect(S0,SD) und H:=... geht nicht weil Group(A,B)*C nicht 
Group(A*C,B*C ) ist.
ok aber DOPPELSTAB vor Intersection in SCHNICK hat den entscheidenden Schwung gebracht. Das ist jetzt gelaufen ok

KANTENZUEGE:=function(ddmax)
  ERGS1:=[];
  for dd in [1..ddmax] do
    ERGS1[dd]:=[];
    for i in [1..a[dd]] do ERGS1[dd][i]:=KANTENZUG(dd,i); od;
    od;
  end;
KANTENZUEGE(10);
ERGS1[4];
ERGS2:=[[[[[1]],[[1]]]]];
ERGS2[1][1];[[[1]],[[1]]];
GESAMTDILIST:=[[1]];
dd:=2;
Exec("date");
ERGS2[dd]:=[];GESAMTDILIST[dd]:=[];
for R1 in ERGS1[dd] do
  Print("\n***R1=",R1);
  TEILDILIST:=[];
  for jj in [1..Size(ERGS2[dd-1])] do R1R2:=ERGS2[dd-1][jj]; if R1{[1..dd-1]}=R1R2[1] then
    Print("\n...R1,R1R2=\n",R1,"\n",R1R2,"\n");
    ORBI:=SCHNICK(R1,R1R2[2]);
    #1#Print("\nORBI=",ORBI,Size(ORBI),"\n",R1R2,"...\n");
    Print("\nSize(ORBI)=",Size(ORBI));
    Print("\n",jj," von ",Size(ERGS2[dd-1]),": Size(GESAMTDILIST[dd]=",Size(GESAMTDILIST[dd]));
    for ORB in ORBI do
      R:=R1+2*ORB;
      D:=DIAG(R);
      #a#Remove(D,1);
      #a#RV:=RVOND(dd,D);
      #a#ID:=IdSmallGroup(PcgsOfR(RV));
      ID:=COMPDIAG5(D,false);
      #a#Print(" ",ID,"\c");
      if not ID in TEILDILIST then
        Add(TEILDILIST,ID);
        Add(ERGS2[dd],[R1,ORB]);
        fi;
      if not ID in GESAMTDILIST[dd] then
        Add(GESAMTDILIST[dd],ID);
        Print("*\c");
        else Print(".\c"); fi;
      od;
    fi; od;
  od;

GESAMTDILIST;;List(GESAMTDILIST,i->Size(i));[ 1, 6, 19, 60, 158, 442, 1122, 2945];Exec("date");

##########nochmal als SCHNACK mit Argument dd
COMPDIAG5dd:=function(dd,D,flag)#neu
  local RET,i,j,k,l,jkl,jkli,dj,dk,dl,SD,DD,DDD,D0,D1,D2,GLEI,
  Dji,Dki,Dli,
  anzj011,anzk011,anzl011,
  anzj000,anzk000,anzl000,
  anzj111,anzk111,anzl111,
  anzj100,anzk100,anzl100;
  SD:=Size(D);DD:=[];DDD:=[];D0:=[];D1:=[];D2:=[];
  GLEI:=NullMat(SD,16);
  for i in [1..SD] do 
    DD[i]:=List(BITLIST2[D[i]+1]);
    DDD[i]:=List(BITLIST0[D[i]+1]);
    od;
##  RET:=NullMat(SD,20);
  for jkli in [1..(SD-1)*(SD-2)/6] do
    jkl:=JKLLISTE[jkli];
    j:=jkl[1];k:=jkl[2];l:=jkl[3];
    dj:=D[j];dk:=D[k];dl:=D[l];
#Print("\n",jkl," ",dj," ",dk," ",dl);
##    RET2:=DJDKDL[dj+1][dk+1][dl+1];
##    RET[j][RET2]:=RET[j][RET2]+1;
##    RET[k][RET2]:=RET[k][RET2]+1;
##    RET[l][RET2]:=RET[l][RET2]+1;
    anzj011:=0; anzk011:=0; anzl011:=0;
    anzj000:=0; anzk000:=0; anzl000:=0;
    anzj111:=0; anzk111:=0; anzl111:=0;
    anzj100:=0; anzk100:=0; anzl100:=0;
    for i in [1..3] do
      Dji:=DDD[j][i];
      Dki:=DDD[k][i];
      Dli:=DDD[l][i];
      if Dji=1 and Dki=Dli and Dki=1 then DD[j][i]:=1; anzj111:=anzj111+1; fi;
      if Dji=1 and Dki=Dli and Dki=0 then DD[j][i]:=1; anzj100:=anzj100+1; fi;
      if Dji=0 and Dki=Dli and Dki=1 then anzj011:=anzj011+1; fi;
      if Dji=0 and Dki=Dli and Dki=0 then anzj000:=anzj000+1; fi;
      if Dji=0 and Dki<>Dli then DD[j][i]:=0; fi;
      if Dki=1 and Dji=Dli and Dji=1 then DD[k][i]:=1; anzk111:=anzk111+1; fi;
      if Dki=1 and Dji=Dli and Dji=0 then DD[k][i]:=1; anzk100:=anzk100+1; fi;
      if Dki=0 and Dji=Dli and Dji=1 then anzk011:=anzk011+1; fi;
      if Dki=0 and Dji=Dli and Dji=0 then anzk000:=anzk000+1; fi;
      if Dki=0 and Dji<>Dli then DD[k][i]:=0; fi;
      if Dli=1 and Dki=Dji and Dki=1 then DD[l][i]:=1; anzl111:=anzl111+1; fi;
      if Dli=1 and Dki=Dji and Dki=0 then DD[l][i]:=1; anzl100:=anzl100+1; fi;
      if Dli=0 and Dki=Dji and Dki=1 then anzl011:=anzl011+1; fi;
      if Dli=0 and Dki=Dji and Dki=0 then anzl000:=anzl000+1; fi;
      if Dli=0 and Dki<>Dji then DD[l][i]:=0; fi;
#      if Dji=0 and Dki=Dli then DD[j][i]:=DD[j][i]+2; fi;
#      if Dji=1 and Dki<>Dli then DD[j][i]:=DD[j][i]+2; fi;
#      if Dki=0 and Dji=Dli then DD[k][i]:=DD[k][i]+2; fi;
#      if Dki=1 and Dji<>Dli then DD[k][i]:=DD[k][i]+2; fi;
#      if Dli=0 and Dki=Dji then DD[l][i]:=DD[l][i]+2; fi;
#      if Dli=1 and Dki<>Dji then DD[l][i]:=DD[l][i]+2; fi;
      od;
    GLEI[j][anzj011+1]:=GLEI[j][anzj011+1]+1;
    GLEI[k][anzk011+1]:=GLEI[k][anzk011+1]+1;
    GLEI[l][anzl011+1]:=GLEI[l][anzl011+1]+1;
    GLEI[j][anzj000+5]:=GLEI[j][anzj000+5]+1;
    GLEI[k][anzk000+5]:=GLEI[k][anzk000+5]+1;
    GLEI[l][anzl000+5]:=GLEI[l][anzl000+5]+1;
    GLEI[j][anzj111+9]:=GLEI[j][anzj111+9]+1;
    GLEI[k][anzk111+9]:=GLEI[k][anzk111+9]+1;
    GLEI[l][anzl111+9]:=GLEI[l][anzl111+9]+1;
    GLEI[j][anzj100+13]:=GLEI[j][anzj100+13]+1;
    GLEI[k][anzk100+13]:=GLEI[k][anzk100+13]+1;
    GLEI[l][anzl100+13]:=GLEI[l][anzl100+13]+1;
    od;
  GLEI:=SortedList(Collected(GLEI));
#Print("\n--",DD);
  for i in [1..SD] do 
    D0[i]:=DD[i][1];
    D1[i]:=DD[i][2];
    D2[i]:=DD[i][3];
    od;
  if flag=1 then
    Print("\n  ",D0);
    Print("\n  ",D1);
    Print("\n  ",D2);
    fi;
  D0:=Reversed(SortedList(List(Collected(List(D0)),i->i[2])));
  D1:=Reversed(SortedList(List(Collected(List(D1)),i->i[2])));
  D2:=Reversed(SortedList(List(Collected(List(D2)),i->i[2])));
  DD:=Reversed(SortedList(List(Collected(List(DD)),i->i[2])));
#Print("\n  ",D0);
#Print("\n  ",D1);
#Print("\n  ",D2);
#Print("\n  ",DD);
# RET:=Collected(RET);#Remove(RET,1);
  RET:=[SortedList([D0,D1,D2]),DD,GLEI];#DD muss bei 1122 dabei sein, D0,D1,D2 nicht
#Print(RET);
  return StructuralCopy(RET);
  end;

P12:=(2,3)(5,8)(7,9)(11,17)(12,14)(13,18)(16,19);
P23:=(3,4)(6,7)(8,10)(12,13)(14,16)(17,20)(18,19);
T23P:=function(PERM,V)
  local RET,j,k,l;
  RET:=StructuralCopy(V);
  for j in RET do
    j[1]:=Permuted(j[1],PERM);
    od;
  RET:=SortedList(RET);
  return RET;
  end;

Add1:=function(L,M) Add(L,M); end;
GESAMTDILIST:=[];
FUN9:=function(arg)#neu
  local MIN,V;
  RT:=[];
  j:=Size(arg)/2;
  for i in [1..j] do
    Add1(RT,arg[i]+arg[i+j]);
    od;
  if RI=[] then R:=R4(RT); else R:=R5([RI,RT]); fi;
#  Print(".");
#  Print("\n",RI,RT,R,IdSmallGroup(PcgsOfR(R)));
#  Print("\n",RT);
  S:=Size(R);
  RSIZE:=Size(R);
  V:=COMPDIAG4_15(DIAG(R));MIN:=V;
#  VVV:=COMPDIAG7(DIAG(R),0)[2][1];
#if VVV=[[6,6,2,2],[8,4,4],[9,6,1]] then  Print("\n>",RI,RT,R,COMPDIAG7(DIAG(R),0)[2]); fi;
#  V:=COMPDIAG5(DIAG(R),0);MIN:=V;
  GESAMTDI:=MIN;
  if not (GESAMTDI in GESAMTDILIST) then
    Add(GESAMTDILIST,GESAMTDI);
    GV:=T23P(P23,V); if not (GV in GESAMTDILIST) then Add(GESAMTDILIST,GV); fi;
    GV:=T23P(P12,V); if not (GV in GESAMTDILIST) then Add(GESAMTDILIST,GV); fi;
    GV:=T23P(P12*P23,V); if not (GV in GESAMTDILIST) then Add(GESAMTDILIST,GV); fi;
    GV:=T23P(P23*P12,V); if not (GV in GESAMTDILIST) then Add(GESAMTDILIST,GV); fi;
    GV:=T23P(P12*P23*P12,V); if not (GV in GESAMTDILIST) then Add(GESAMTDILIST,GV); fi;
    if RI=[] then Add(ERG,RT); else Add(ERG,[RI,RT]); fi;
    Print("*",Size(ERG),"\c");
    fi;
  return [];
  end;

SCHNACK:=function(dd,CMPD)
  Exec("date");
  ERGS2[dd]:=[];GESAMTDILIST[dd]:=[];
  for R1 in ERGS1[dd] do
    Print("\n***R1=",R1);
    TEILDILIST:=[];
    for jj in [1..Size(ERGS2[dd-1])] do R1R2:=ERGS2[dd-1][jj]; if R1{[1..dd-1]}=R1R2[1] then
      Print("\n...R1,R1R2=\n",R1,"\n",R1R2,"\n");
      ORBI:=SCHNICK(R1,R1R2[2]);
      #1#Print("\nORBI=",ORBI,Size(ORBI),"\n",R1R2,"...\n");
      Print("\nSize(ORBI)=",Size(ORBI));
      Print("\n",jj," von ",Size(ERGS2[dd-1]),": Size(GESAMTDILIST[dd])=",Size(GESAMTDILIST[dd]),"\n");
      for ORB in ORBI do
        R:=R1+2*ORB;
        D:=DIAG(R);
        #a#Remove(D,1);
        #a#RV:=RVOND(dd,D);
        #a#ID:=IdSmallGroup(PcgsOfR(RV));
        ID:=CMPD(dd,D,false);
        #a#Print(" ",ID,"\c");
        if not ID in TEILDILIST then
          Add(TEILDILIST,ID);
          Add(ERGS2[dd],[R1,ORB]);
          fi;
        if not ID in GESAMTDILIST[dd] then
          Add(GESAMTDILIST[dd],ID);
          Print("*\c");
          else Print(".\c"); fi;
        od;
      fi; od;
    od;
  Print("\n",List(GESAMTDILIST,i->Size(i)));
  Print("\n",[ 1, 6, 19, 60, 158, 442, 1122, 2945],"\n");
  Exec("date");
  end;

KANTENZUEGE(10);
ERGS1[4];
ERGS2:=[[[[[1]],[[1]]]]];
ERGS2[1][1];[[[1]],[[1]]];
GESAMTDILIST:=[[1]];
dd:=2;
SCHNACK(2,COMPDIAG5);#16
SCHNACK(3,COMPDIAG5);#32
SCHNACK(4,COMPDIAG5);#64
SCHNACK(5,COMPDIAG5);#128
SCHNACK(6,COMPDIAG5);#256
SCHNACK(7,COMPDIAG5);#512
SCHNACK(8,COMPDIAG5);#1024


##################neues COMPDIAG5
COMPDIAG5A:=function(dd,D,flag)#neu
  local RET,i,j,k,l,jkl,jkli,dj,dk,dl,SD,DD,DDD,D0,D1,D2,GLEI,
  Dji,Dki,Dli,
  anzj011,anzk011,anzl011,
  anzj000,anzk000,anzl000,
  anzj111,anzk111,anzl111,
  anzj100,anzk100,anzl100,
  DA,DB;
  SD:=Size(D);DD:=[];DDD:=[];D0:=[];D1:=[];D2:=[];
  GLEI:=NullMat(SD,16);
  for i in [1..SD] do 
    DD[i]:=List(BITLIST2[D[i]+1]);
    DDD[i]:=List(BITLIST0[D[i]+1]);
    od;
##  RET:=NullMat(SD,20);
  for jkli in [1..(SD-1)*(SD-2)/6] do
    jkl:=JKLLISTE[jkli];
    j:=jkl[1];k:=jkl[2];l:=jkl[3];
    dj:=D[j];dk:=D[k];dl:=D[l];
#Print("\n",jkl," ",dj," ",dk," ",dl);
##    RET2:=DJDKDL[dj+1][dk+1][dl+1];
##    RET[j][RET2]:=RET[j][RET2]+1;
##    RET[k][RET2]:=RET[k][RET2]+1;
##    RET[l][RET2]:=RET[l][RET2]+1;
    anzj011:=0; anzk011:=0; anzl011:=0;
    anzj000:=0; anzk000:=0; anzl000:=0;
    anzj111:=0; anzk111:=0; anzl111:=0;
    anzj100:=0; anzk100:=0; anzl100:=0;
    for i in [1..3] do
      Dji:=DDD[j][i];
      Dki:=DDD[k][i];
      Dli:=DDD[l][i];
      if Dji=1 and Dki=Dli and Dki=1 then DD[j][i]:=1; anzj111:=anzj111+1; fi;
      if Dji=1 and Dki=Dli and Dki=0 then DD[j][i]:=1; anzj100:=anzj100+1; fi;
      if Dji=0 and Dki=Dli and Dki=1 then anzj011:=anzj011+1; fi;
      if Dji=0 and Dki=Dli and Dki=0 then anzj000:=anzj000+1; fi;
      if Dji=0 and Dki<>Dli then DD[j][i]:=0; fi;
      if Dki=1 and Dji=Dli and Dji=1 then DD[k][i]:=1; anzk111:=anzk111+1; fi;
      if Dki=1 and Dji=Dli and Dji=0 then DD[k][i]:=1; anzk100:=anzk100+1; fi;
      if Dki=0 and Dji=Dli and Dji=1 then anzk011:=anzk011+1; fi;
      if Dki=0 and Dji=Dli and Dji=0 then anzk000:=anzk000+1; fi;
      if Dki=0 and Dji<>Dli then DD[k][i]:=0; fi;
      if Dli=1 and Dki=Dji and Dki=1 then DD[l][i]:=1; anzl111:=anzl111+1; fi;
      if Dli=1 and Dki=Dji and Dki=0 then DD[l][i]:=1; anzl100:=anzl100+1; fi;
      if Dli=0 and Dki=Dji and Dki=1 then anzl011:=anzl011+1; fi;
      if Dli=0 and Dki=Dji and Dki=0 then anzl000:=anzl000+1; fi;
      if Dli=0 and Dki<>Dji then DD[l][i]:=0; fi;
#      if Dji=0 and Dki=Dli then DD[j][i]:=DD[j][i]+2; fi;
#      if Dji=1 and Dki<>Dli then DD[j][i]:=DD[j][i]+2; fi;
#      if Dki=0 and Dji=Dli then DD[k][i]:=DD[k][i]+2; fi;
#      if Dki=1 and Dji<>Dli then DD[k][i]:=DD[k][i]+2; fi;
#      if Dli=0 and Dki=Dji then DD[l][i]:=DD[l][i]+2; fi;
#      if Dli=1 and Dki<>Dji then DD[l][i]:=DD[l][i]+2; fi;
      od;
    GLEI[j][anzj011+1]:=GLEI[j][anzj011+1]+1;
    GLEI[k][anzk011+1]:=GLEI[k][anzk011+1]+1;
    GLEI[l][anzl011+1]:=GLEI[l][anzl011+1]+1;
    GLEI[j][anzj000+5]:=GLEI[j][anzj000+5]+1;
    GLEI[k][anzk000+5]:=GLEI[k][anzk000+5]+1;
    GLEI[l][anzl000+5]:=GLEI[l][anzl000+5]+1;
    GLEI[j][anzj111+9]:=GLEI[j][anzj111+9]+1;
    GLEI[k][anzk111+9]:=GLEI[k][anzk111+9]+1;
    GLEI[l][anzl111+9]:=GLEI[l][anzl111+9]+1;
    GLEI[j][anzj100+13]:=GLEI[j][anzj100+13]+1;
    GLEI[k][anzk100+13]:=GLEI[k][anzk100+13]+1;
    GLEI[l][anzl100+13]:=GLEI[l][anzl100+13]+1;
    od;
#Print("\n--",DD);
  for i in [1..SD] do 
    D0[i]:=DD[i][1];
    D1[i]:=DD[i][2];
    D2[i]:=DD[i][3];
    od;
  if flag=1 then
    Print("\n  ",D0);
    Print("\n  ",D1);
    Print("\n  ",D2);
    fi;

###neu Einschub für Orbits(Aut(G),[1..2^dd-1]);
DA:=List(D0);Remove(DA,1);
DB:=List(D1);Remove(DB,1);
SDA:=STABMACH(dd,DA);
SDB:=STABMACH(dd,DB);
SDAB:=Intersection(Group(SDA),Group(SDB));
ORBAB:=Orbits(SDAB,[1..Size(DA)]);
OSIZE:=Size(ORBAB);
Print(OSIZE);
ORBAB1:=List(ORBAB,i->i[1]);
  
  D0:=Reversed(SortedList(List(Collected(List(D0)),i->i[2])));
  D1:=Reversed(SortedList(List(Collected(List(D1)),i->i[2])));
  D2:=Reversed(SortedList(List(Collected(List(D2)),i->i[2])));
  DD:=Reversed(SortedList(List(Collected(List(DD)),i->i[2])));
#Print("\n  ",D0);
#Print("\n  ",D1);
#Print("\n  ",D2);
#Print("\n  ",DD);

###neu Einschub für Orbits(Aut(G),[1..2^dd-1]); das +1 in ORBAB1[i]+1 ist wegen 0,1 Start
for i in [1..OSIZE-1] do for j in [i+1..OSIZE] do
  if D[ORBAB1[i]+1]=D[ORBAB1[j]+1] and GLEI[ORBAB1[i]+1]=GLEI[ORBAB1[j]+1] and Size(ORBAB[i])=Size(ORBAB[j]) and D0<>D1 and D0<>D2 and D1<>D2 then Error(i," ",j," haben gleiche Markierung"); fi;
  od; od;

  GLEI:=SortedList(Collected(GLEI));
# RET:=Collected(RET);#Remove(RET,1);
  RET:=[SortedList([D0,D1,D2]),DD,GLEI];#DD muss bei 1122 dabei sein, D0,D1,D2 nicht
#Print(RET);
  return StructuralCopy(RET);
  end;

KANTENZUEGE(10);
ERGS1[4];
ERGS2:=[[[[[1]],[[1]]]]];
ERGS2[1][1];[[[1]],[[1]]];
GESAMTDILIST:=[[1]];
dd:=2;
SCHNACK(2,COMPDIAG5A);#16#6
SCHNACK(3,COMPDIAG5A);#32#19
SCHNACK(4,COMPDIAG5A);#64#60
SCHNACK(5,COMPDIAG5A);#128#158
SCHNACK(6,COMPDIAG5A);#256#442
SCHNACK(7,COMPDIAG5A);#512#1122
SCHNACK(8,COMPDIAG5A);#1024#2945

brk> GLEI;
[ [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], 
  [ 3, 0, 0, 0, 2, 1, 0, 0, 3, 0, 0, 0, 0, 2, 1, 0 ], 
  [ 3, 0, 0, 0, 2, 1, 0, 0, 3, 0, 0, 0, 0, 2, 1, 0 ], 
  [ 2, 1, 0, 0, 1, 1, 0, 1, 3, 0, 0, 0, 3, 0, 0, 0 ], 
  [ 3, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 3, 0, 0, 0 ], 
  [ 2, 1, 0, 0, 1, 1, 0, 1, 3, 0, 0, 0, 3, 0, 0, 0 ], 
  [ 2, 1, 0, 0, 1, 1, 0, 1, 3, 0, 0, 0, 3, 0, 0, 0 ], 
  [ 3, 0, 0, 0, 2, 1, 0, 0, 3, 0, 0, 0, 0, 2, 1, 0 ] ]
brk> D;
[ 0, 3, 1, 0, 0, 0, 0, 2 ]
brk> ORBAB;
[ [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ], [ 7 ] ]

brk> D;
[ 0, 3, 1, 0, 1, 0, 2, 1, 1, 2, 2, 3, 2, 3, 3, 0, 0, 0, 0, 2, 0, 2, 2, 2, 2, 
  2, 0, 2, 0, 2, 0, 0 ]
brk> ORBAB;
[ [ 1, 11, 13 ], [ 2, 4, 8 ], [ 3, 5, 15 ], [ 6, 12, 10 ], [ 7 ], [ 9 ], 
  [ 14 ], [ 16, 30, 20, 26, 28, 18 ], [ 17, 31 ], [ 19, 27, 29, 23, 21, 25 ],
  [ 22, 24 ] ]
brk> GLEI;
[ [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ], 
  [ 11, 4, 0, 0, 12, 3, 0, 0, 11, 4, 0, 0, 5, 8, 2, 0 ], 
  [ 11, 4, 0, 0, 12, 3, 0, 0, 11, 4, 0, 0, 5, 8, 2, 0 ], 
  [ 8, 2, 5, 0, 2, 11, 0, 2, 15, 0, 0, 0, 15, 0, 0, 0 ], 
  [ 11, 4, 0, 0, 12, 3, 0, 0, 11, 4, 0, 0, 5, 8, 2, 0 ], 
  [ 8, 2, 5, 0, 2, 11, 0, 2, 15, 0, 0, 0, 15, 0, 0, 0 ], 
  [ 11, 4, 0, 0, 4, 11, 0, 0, 10, 2, 3, 0, 10, 2, 3, 0 ], 
  [ 11, 4, 0, 0, 12, 3, 0, 0, 15, 0, 0, 0, 7, 8, 0, 0 ], 
  [ 11, 4, 0, 0, 12, 3, 0, 0, 11, 4, 0, 0, 5, 8, 2, 0 ], 
  [ 11, 4, 0, 0, 4, 11, 0, 0, 15, 0, 0, 0, 15, 0, 0, 0 ], 
  [ 11, 4, 0, 0, 4, 11, 0, 0, 10, 2, 3, 0, 10, 2, 3, 0 ], 
  [ 11, 4, 0, 0, 12, 3, 0, 0, 11, 4, 0, 0, 5, 8, 2, 0 ], 
  [ 11, 4, 0, 0, 4, 11, 0, 0, 10, 2, 3, 0, 10, 2, 3, 0 ], 
  [ 11, 4, 0, 0, 12, 3, 0, 0, 11, 4, 0, 0, 5, 8, 2, 0 ], 
  [ 7, 8, 0, 0, 8, 7, 0, 0, 11, 4, 0, 0, 7, 4, 4, 0 ], 
  [ 8, 2, 5, 0, 2, 11, 0, 2, 15, 0, 0, 0, 15, 0, 0, 0 ], 
  [ 9, 4, 2, 0, 4, 10, 0, 1, 15, 0, 0, 0, 15, 0, 0, 0 ], 
  [ 7, 4, 4, 0, 4, 8, 0, 3, 15, 0, 0, 0, 15, 0, 0, 0 ], 
  [ 9, 4, 2, 0, 4, 10, 0, 1, 15, 0, 0, 0, 15, 0, 0, 0 ], 
  [ 15, 0, 0, 0, 8, 7, 0, 0, 9, 4, 2, 0, 9, 4, 2, 0 ], 
  [ 9, 4, 2, 0, 4, 10, 0, 1, 15, 0, 0, 0, 15, 0, 0, 0 ], 
  [ 15, 0, 0, 0, 8, 7, 0, 0, 9, 4, 2, 0, 9, 4, 2, 0 ], 
  [ 15, 0, 0, 0, 8, 7, 0, 0, 11, 4, 0, 0, 11, 4, 0, 0 ], 
  [ 15, 0, 0, 0, 8, 7, 0, 0, 9, 4, 2, 0, 9, 4, 2, 0 ], 
  [ 15, 0, 0, 0, 8, 7, 0, 0, 11, 4, 0, 0, 11, 4, 0, 0 ], 
  [ 15, 0, 0, 0, 8, 7, 0, 0, 9, 4, 2, 0, 9, 4, 2, 0 ], 
  [ 9, 4, 2, 0, 4, 10, 0, 1, 15, 0, 0, 0, 15, 0, 0, 0 ], 
  [ 15, 0, 0, 0, 8, 7, 0, 0, 9, 4, 2, 0, 9, 4, 2, 0 ], 
  [ 9, 4, 2, 0, 4, 10, 0, 1, 15, 0, 0, 0, 15, 0, 0, 0 ], 
  [ 15, 0, 0, 0, 8, 7, 0, 0, 9, 4, 2, 0, 9, 4, 2, 0 ], 
  [ 9, 4, 2, 0, 4, 10, 0, 1, 15, 0, 0, 0, 15, 0, 0, 0 ], 
  [ 7, 4, 4, 0, 4, 8, 0, 3, 15, 0, 0, 0, 15, 0, 0, 0 ] ]

brk> D;
     a  b     c           d                       f
[ 0, 3, 1, 1, 1, 1, 1, 2, 1, 0, 0, 2, 2, 0, 2, 3, 1, 2, 0, 0, 2, 2, 2, 1, 3, 
  2, 2, 0, 2, 0, 2, 3 ]
brk> ORBAB;
[ [ 1 ], [ 2, 5 ], [ 3, 4 ], [ 6 ], [ 7 ], [ 8 ], [ 9 ], [ 10, 13 ], 
  [ 11, 12 ], [ 14 ], [ 15 ], [ 16, 23 ], [ 17, 22 ], [ 18 ], [ 19 ], 
  [ 20 ], [ 21 ], [ 24, 31 ], [ 25, 30 ], [ 26 ], [ 27 ], [ 28 ], [ 29 ] ]
brk> GLEI[2];
[ 9, 6, 0, 0, 14, 1, 0, 0, 9, 6, 0, 0, 6, 8, 1, 0 ]
brk> GLEI[16];
[ 9, 6, 0, 0, 14, 1, 0, 0, 9, 6, 0, 0, 6, 8, 1, 0 ]
brk> GLEI[25];
[ 9, 6, 0, 0, 14, 1, 0, 0, 9, 6, 0, 0, 6, 8, 1, 0 ]
brk> GLEI[32];
[ 9, 6, 0, 0, 14, 1, 0, 0, 9, 6, 0, 0, 6, 8, 1, 0 ]
brk> D0;
[ 18, 12, 2 ]
brk> D1;
[ 15, 15, 1, 1 ]
brk> D2;
[ 20, 10, 2 ]
brk> SDAB;
Group([ (2,5)(3,4)(10,13)(11,12)(16,23)(17,22)(24,31)(25,30) ])
brk> Size(SDAB);
2
A:=AutomorphismGroup(G);
<group of size 2048 with 11 generators>
brk> A.1;
Pcgs([ f1, f2, f3, f4, f5, f6, f7 ]) -> [ f1*f5, f2, f3, f4, f5, f6, f7 ]
brk> A.2;
Pcgs([ f1, f2, f3, f4, f5, f6, f7 ]) -> [ f1*f6, f2, f3, f4, f5, f6, f7 ]
brk> A.3;
Pcgs([ f1, f2, f3, f4, f5, f6, f7 ]) -> [ f1, f2*f6, f3, f4, f5, f6, f7 ]
brk> A.4;
Pcgs([ f1, f2, f3, f4, f5, f6, f7 ]) -> [ f1, f2, f3*f6, f4, f5, f6, f7 ]
brk> A.5;
Pcgs([ f1, f2, f3, f4, f5, f6, f7 ]) -> [ f1, f2, f3, f4*f6, f5, f6, f7 ]
brk> A.6;
Pcgs([ f1, f2, f3, f4, f5, f6, f7 ]) -> [ f1, f2, f3, f4, f5*f6, f6, f7 ]
brk> A.7;
Pcgs([ f1, f2, f3, f4, f5, f6, f7 ]) -> [ f1*f7, f2, f3, f4, f5, f6, f7 ]
brk> A.8;
Pcgs([ f1, f2, f3, f4, f5, f6, f7 ]) -> [ f1, f2*f7, f3, f4, f5, f6, f7 ]
brk> A.9;
Pcgs([ f1, f2, f3, f4, f5, f6, f7 ]) -> [ f1, f2, f3*f7, f4, f5, f6, f7 ]
brk> A.10;
Pcgs([ f1, f2, f3, f4, f5, f6, f7 ]) -> [ f1, f2, f3, f4*f7, f5, f6, f7 ]
brk> A.11;
Pcgs([ f1, f2, f3, f4, f5, f6, f7 ]) -> [ f1, f2, f3, f4, f5*f7, f6, f7 ]
brk> G.1^2;      
<identity> of ...
brk> G.2^2;
<identity> of ...
brk> G.3^2;
<identity> of ...
brk> G.4^2;
f6
brk> G.5^2;
f6
brk> G.6^2;
<identity> of ...

#############neues COMPDIAG5B mit ausführlichster Markierung
PERMMARK:=function(MARK,a,b,c)
  return SortedList(List(MARK,
    i->SortedList(List(i,j->[[
      [j[1][1][a],j[1][1][b],j[1][1][c]],
      [j[1][2][a],j[1][2][b],j[1][2][c]]],j[2]]))));
  end;
MARK:=[[[[[1,0,1],[0,1,1]],5],[[[1,0,1],[0,0,2]],6]],
       [[[[1,1,0],[0,1,1]],7],[[[1,1,0],[3,1,0]],8]]];
MARK123:=PERMMARK(MARK,1,2,3);#6,5,7,8
MARK132:=PERMMARK(MARK,1,3,2);#7,8,5,6
MARK213:=PERMMARK(MARK,2,1,3);#6,5,7,8
MARK231:=PERMMARK(MARK,2,3,1);#6,5,8,7
MARK312:=PERMMARK(MARK,3,1,2);#8,7,5,6
MARK321:=PERMMARK(MARK,3,2,1);#8,7,5,6

COMPDIAG5B:=function(dd,D,flag)#neu
  local RET,i,j,k,l,jkl,jkli,dj,dk,dl,SD,DD,DDD,D0,D1,D2,GLEI,
    Dji,Dki,Dli,
    anzj011,anzk011,anzl011,
    anzj000,anzk000,anzl000,
    anzj111,anzk111,anzl111,
    anzj100,anzk100,anzl100,
    DA,DB,MARK,MARKI,MARKJ,D0Z,D1Z,D2Z,DDZ,MINMARK,GLEIZ;
  SD:=Size(D);DD:=[];DDD:=[];D0:=[];D1:=[];D2:=[];
  GLEI:=NullMat(SD,16);
  for i in [1..SD] do 
    DD[i]:=List(BITLIST2[D[i]+1]);
    DDD[i]:=List(BITLIST0[D[i]+1]);
    od;
##  RET:=NullMat(SD,20);
  for jkli in [1..(SD-1)*(SD-2)/6] do
    jkl:=JKLLISTE[jkli];
    j:=jkl[1];k:=jkl[2];l:=jkl[3];
    dj:=D[j];dk:=D[k];dl:=D[l];
#Print("\n",jkl," ",dj," ",dk," ",dl);
##    RET2:=DJDKDL[dj+1][dk+1][dl+1];
##    RET[j][RET2]:=RET[j][RET2]+1;
##    RET[k][RET2]:=RET[k][RET2]+1;
##    RET[l][RET2]:=RET[l][RET2]+1;
    anzj011:=0; anzk011:=0; anzl011:=0;
    anzj000:=0; anzk000:=0; anzl000:=0;
    anzj111:=0; anzk111:=0; anzl111:=0;
    anzj100:=0; anzk100:=0; anzl100:=0;
    for i in [1..3] do
      Dji:=DDD[j][i];
      Dki:=DDD[k][i];
      Dli:=DDD[l][i];
      if Dji=1 and Dki=Dli and Dki=1 then DD[j][i]:=1; anzj111:=anzj111+1; fi;
      if Dji=1 and Dki=Dli and Dki=0 then DD[j][i]:=1; anzj100:=anzj100+1; fi;
      if Dji=0 and Dki=Dli and Dki=1 then anzj011:=anzj011+1; fi;
      if Dji=0 and Dki=Dli and Dki=0 then anzj000:=anzj000+1; fi;
      if Dji=0 and Dki<>Dli then DD[j][i]:=0; fi;
      if Dki=1 and Dji=Dli and Dji=1 then DD[k][i]:=1; anzk111:=anzk111+1; fi;
      if Dki=1 and Dji=Dli and Dji=0 then DD[k][i]:=1; anzk100:=anzk100+1; fi;
      if Dki=0 and Dji=Dli and Dji=1 then anzk011:=anzk011+1; fi;
      if Dki=0 and Dji=Dli and Dji=0 then anzk000:=anzk000+1; fi;
      if Dki=0 and Dji<>Dli then DD[k][i]:=0; fi;
      if Dli=1 and Dki=Dji and Dki=1 then DD[l][i]:=1; anzl111:=anzl111+1; fi;
      if Dli=1 and Dki=Dji and Dki=0 then DD[l][i]:=1; anzl100:=anzl100+1; fi;
      if Dli=0 and Dki=Dji and Dki=1 then anzl011:=anzl011+1; fi;
      if Dli=0 and Dki=Dji and Dki=0 then anzl000:=anzl000+1; fi;
      if Dli=0 and Dki<>Dji then DD[l][i]:=0; fi;
#      if Dji=0 and Dki=Dli then DD[j][i]:=DD[j][i]+2; fi;
#      if Dji=1 and Dki<>Dli then DD[j][i]:=DD[j][i]+2; fi;
#      if Dki=0 and Dji=Dli then DD[k][i]:=DD[k][i]+2; fi;
#      if Dki=1 and Dji<>Dli then DD[k][i]:=DD[k][i]+2; fi;
#      if Dli=0 and Dki=Dji then DD[l][i]:=DD[l][i]+2; fi;
#      if Dli=1 and Dki<>Dji then DD[l][i]:=DD[l][i]+2; fi;
      od;
    GLEI[j][anzj011+1]:=GLEI[j][anzj011+1]+1;
    GLEI[k][anzk011+1]:=GLEI[k][anzk011+1]+1;
    GLEI[l][anzl011+1]:=GLEI[l][anzl011+1]+1;
    GLEI[j][anzj000+5]:=GLEI[j][anzj000+5]+1;
    GLEI[k][anzk000+5]:=GLEI[k][anzk000+5]+1;
    GLEI[l][anzl000+5]:=GLEI[l][anzl000+5]+1;
    GLEI[j][anzj111+9]:=GLEI[j][anzj111+9]+1;
    GLEI[k][anzk111+9]:=GLEI[k][anzk111+9]+1;
    GLEI[l][anzl111+9]:=GLEI[l][anzl111+9]+1;
    GLEI[j][anzj100+13]:=GLEI[j][anzj100+13]+1;
    GLEI[k][anzk100+13]:=GLEI[k][anzk100+13]+1;
    GLEI[l][anzl100+13]:=GLEI[l][anzl100+13]+1;
    od;
  GLEIZ:=SortedList(Collected(GLEI));
#Print("\n--",DD);
  for i in [1..SD] do 
    D0[i]:=DD[i][1];
    D1[i]:=DD[i][2];
    D2[i]:=DD[i][3];
    od;
  if flag=1 then
    Print("\n  ",D0);
    Print("\n  ",D1);
    Print("\n  ",D2);
    fi;
  D0Z:=Reversed(SortedList(List(Collected(List(D0)),i->i[2])));
  D1Z:=Reversed(SortedList(List(Collected(List(D1)),i->i[2])));
  D2Z:=Reversed(SortedList(List(Collected(List(D2)),i->i[2])));
  DDZ:=Reversed(SortedList(List(Collected(List(DD)),i->i[2])));
#Print("\n  ",D0);
#Print("\n  ",D1);
#Print("\n  ",D2);
#Print("\n  ",DD);

###neu Einschub für Orbits(Aut(G),[1..2^dd-1]);
DA:=List(D0);Remove(DA,1);
DB:=List(D1);Remove(DB,1);
SDA:=STABMACH(dd,DA);
SDB:=STABMACH(dd,DB);
SDAB:=Intersection(Group(SDA),Group(SDB));
ORBAB:=Orbits(SDAB,[1..Size(DA)]);
OSIZE:=Size(ORBAB);
Print(OSIZE);
ORBAB1:=List(ORBAB,i->i[1]);
MARK:=[];
for i in [1..OSIZE] do
  MARK[i]:=[];
  for j in [1..SD] do
    MARKI:=DD[XORMAT[j][ORBAB1[i]+1]];#das +1 wg. Beginn bei Index 1
    MARKJ:=DD[j];
    MARK[i][j]:=[MARKI,MARKJ];
    od;
  MARK[i]:=Collected(MARK[i]);
  od;

#for i in [1..OSIZE-1] do for j in [i+1..OSIZE] do
#  if D[ORBAB1[i]+1]=D[ORBAB1[j]+1] and GLEI[ORBAB1[i]+1]=GLEI[ORBAB1[j]+1] and Size(ORBAB[i])=Size(ORBAB[j]) and D0<>D1 and D0<>D2 and D1<>D2 then Error(i," ",j," haben gleiche Markierung"); fi;
#  od; od;

MARK123:=PERMMARK(MARK,1,2,3);
MARK132:=PERMMARK(MARK,1,3,2);
MARK213:=PERMMARK(MARK,2,1,3);
MARK231:=PERMMARK(MARK,2,3,1);
MARK312:=PERMMARK(MARK,3,1,2);
MARK321:=PERMMARK(MARK,3,2,1);
MINMARK:=Minimum(MARK123,MARK132,MARK213,MARK231,MARK312,MARK321);

# RET:=Collected(RET);#Remove(RET,1);
  RET:=[SortedList([D0Z,D1Z,D2Z]),DDZ,GLEIZ,MINMARK];#DDZ muss bei 1122 dabei sein, D0Z,D1Z,D2Z nicht
#Print(RET);
  return StructuralCopy(RET);
  end;
  
COMPDIAG5B([ 0, 3, 1, 1, 1, 1, 1, 2, 1, 0, 0, 2, 2, 0, 2, 3, 1, 2, 0, 0, 2, 2, 2, 1, 3, 2, 2, 0, 2, 0, 2, 3 ],false);
#bei break dann: MARK[1];MARK[11];#weil ORBAB1[11]=15 ist.


KANTENZUEGE(10);
ERGS1[4];
ERGS2:=[[[[[1]],[[1]]]]];
ERGS2[1][1];[[[1]],[[1]]];
GESAMTDILIST:=[[1]];
dd:=2;
SCHNACK(2,COMPDIAG5B);#n=16#6
SCHNACK(3,COMPDIAG5B);#n=32#19
SCHNACK(4,COMPDIAG5B);#n=64#60
SCHNACK(5,COMPDIAG5B);#n=128#158
SCHNACK(6,COMPDIAG5B);#n=256#442
SCHNACK(7,COMPDIAG5B);#n=512#1122
SCHNACK(8,COMPDIAG5B);#n=1024#2945
for i in [1..8] do Print("\n",List(Collected(List(ERGS2[i],j->j[1])),k->k[2])); od;

#############neue Kantenzüge
DOPPER:=function(R)
  local RNEU;
  RNEU:=StructuralCopy(R);
  RNEU[Size(R)+1]:=Concatenation([0],List(R,i->i[1]));
  return RNEU;
  end;
R:=[[1],[0,0],[1,1,1]];
RD:=DOPPER(R);[[1],[0,0],[1,1,1],[0,1,0,1]];
RDD:=DOPPER(RD);[[1],[0,0],[1,1,1],[0,1,0,1],[0,1,0,1,0]];

NEUE_KANTENZUEGE:=function(ddmax)
  local ADMAX;
  ERGS1:=[[[[1]]]];
  for dd in [2..ddmax] do
    ERGS1[dd]:=[];
    ADMAX:=a[dd];
    if IsEvenInt(dd) then
      for i in [1..ADMAX-2] do ERGS1[dd][i]:=DOPPER(ERGS1[dd-1][i]); od;
      ERGS1[dd][ADMAX-1]:=Concatenation(
        ERGS1[dd-1][ADMAX-2],[List([1..dd],j->1)]);
      ERGS1[dd][ADMAX-0]:=Concatenation(
        ERGS1[dd-1][ADMAX-2],[List([1..dd],j->0)]);
      else
        for i in [1..ADMAX-1] do 
          ERGS1[dd][i]:=DOPPER(ERGS1[dd-1][i]); od;
        ERGS1[dd][ADMAX-0]:=Concatenation(
          ERGS1[dd-1][ADMAX-1],[List([1..dd],j->1)]);
        fi;
    od;
  end;
NEUE_KANTENZUEGE(10);

#und los
ERGS1{[1..6]};
ERGS2:=[[[[[1]],[[1]]]]];
ERGS2[1][1];[[[1]],[[1]]];
GESAMTDILIST:=[[1]];
dd:=2;
SCHNACK(2,COMPDIAG5B);#n=16#6
SCHNACK(3,COMPDIAG5B);#n=32#19
SCHNACK(4,COMPDIAG5B);#n=64#60
SCHNACK(5,COMPDIAG5B);#n=128#158
SCHNACK(6,COMPDIAG5B);#n=256#442
SCHNACK(7,COMPDIAG5B);#n=512#1122#45 min
SCHNACK(8,COMPDIAG5B);#n=1024#2945
for i in [1..8] do Print("\n",List(Collected(List(ERGS2[i],j->j[1])),k->k[2])); od;
#hier dann ohne TEILDILIST probieren...geht nicht

#######ERGS2 auswerten
for i in [1..8] do Print("\n",List(Collected(List(ERGS2[i],j->j[1])),k->k[2])); od;
[ 1 ]
[ 3, 4, 2 ]
[ 11, 10, 7, 6 ]
[ 23, 25, 32, 18, 11, 13 ]
[ 36, 77, 69, 70, 58, 14, 19 ]
[ 49, 174, 124, 252, 114, 114, 127, 18, 27 ]
[ 62, 278, 460, 426, 565, 412, 160, 204, 21, 33 ]
[ 75, 401, 1057, 715, 1613, 669, 985, 947, 205, 292, 25, 41 ]
ERGS2MERK:=StructuralCopy(ERGS2);;
GESAMTDILISTMERK:=StructuralCopy(GESAMTDILIST);;

######jetzt SCHNUCK nur über ERGS2 laufen lassen
SCHNUCK:=function(dd,CMPD)
  Exec("date");
  GESAMTDILIST[dd]:=[];
  for R1R2 in ERGS2MERK[dd] do
    Print("\n***R1R2=",R1R2);
    R:=R1R2[1]+2*R1R2[2];
    D:=DIAG(R);
    ID:=CMPD(dd,D,false);
    if not ID in GESAMTDILIST[dd] then
      Add(GESAMTDILIST[dd],ID);
      Print("*\c");
      else Print(".\c"); fi;
    od;
  Print("\n",List(GESAMTDILIST,i->Size(i)));
  Print("\n",[ 1, 6, 19, 60, 158, 442, 1122, 2945],"\n");
  Exec("date");
  end;

SCHNUCK(2,COMPDIAG5B);#n=16#6
SCHNUCK(3,COMPDIAG5B);#n=32#19
SCHNUCK(4,COMPDIAG5B);#n=64#60
SCHNUCK(5,COMPDIAG5B);#n=128#158
SCHNUCK(6,COMPDIAG5B);#n=256#442
SCHNUCK(7,COMPDIAG5B);#n=512#1122#45 min
SCHNUCK(8,COMPDIAG5B);#n=1024#2945
