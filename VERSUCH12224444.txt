#XSAMMEL:=[];#nur anfangs einmal
ClearProfile();
IS:=[2,1];
for i1 in IS do i2:=i1;
#  for i2 in IS do
    for i3 in IS do
      for i4 in IS do
        for i5 in IS do
          for i6 in IS do
            Print("\n",i1," ",i2," ",i3," ",i4," ",i5," ",i6);
            R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[i1,i2,i3,i4,i5,i6]];
#            G1:=AsGroup(MagmaByMultiplicationTable(MatrixOf(R)));
#            if G1<>fail then 
              G:=PcgsOfR(R);
              Print(IdSmallGroup(G),"\c");RMAXSUCH(G); 
#              fi;
            od;
          od;
        od;
      od;
#    od;
  od;

IS:=[4,3,2,1];
for i1 in IS do i2:=i1; i3:=i1;
#  for i2 in IS do
#    for i3 in IS do
      for i4 in IS do
        for i5 in IS do
          for i6 in IS do
            Print("\n",i1," ",i2," ",i3," ",i4," ",i5," ",i6);
            R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[i1,i2,i3,i4,i5,i6]];
#            G1:=AsGroup(MagmaByMultiplicationTable(MatrixOf(R)));
#            if G1<>fail then 
              G:=PcgsOfR(R);
              Print(IdSmallGroup(G),"\c");RMAXSUCH(G);
#              fi;
            od;
          od;
        od;
#      od;
#    od;
  od;

IS:=[2,1];
for i1 in IS do i2:=i1;
#  for i2 in IS do
    for i3 in IS do
      for i4 in IS do
        for i5 in IS do
          for i6 in IS do
            for i7 in IS do
              Print("\n",i1," ",i2," ",i3," ",i4," ",i5," ",i6," ",i7);
              R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[i1,i2,i3,i4,i5,i6,i7]];
#              G1:=AsGroup(MagmaByMultiplicationTable(MatrixOf(R)));
#              if G1<>fail then 
                G:=PcgsOfR(R);
                Print(IdSmallGroup(G),"\c");RMAXSUCH(G);
#                fi;
              od;
            od;
          od;
        od;
      od;
#    od;
  od;
XSAMMEL128:=StructuralCopy(XSAMMEL);;

IS:=[4,3,2,1];
for i1 in IS do i2:=i1; i3:=i1;
#  for i2 in IS do
#    for i3 in IS do
      for i4 in IS do
        for i5 in IS do
          for i6 in IS do
            for i7 in IS do
              Print("\n",i1," ",i2," ",i3," ",i4," ",i5," ",i6," ",i7);
              R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[i1,i2,i3,i4,i5,i6,i7]];
#              G1:=AsGroup(MagmaByMultiplicationTable(MatrixOf(R)));
#              if G1<>fail then 
                G:=PcgsOfR(R);
                Print(IdSmallGroup(G),"\c");RMAXSUCH(G);
#                fi;
              od;
            od;
          od;
        od;
#      od;
#    od;
  od;
DisplayProfile();

IS:=[2,1];
for i1 in IS do i2:=i1;
#  for i2 in IS do
    for i3 in IS do
      for i4 in IS do
        for i5 in IS do
          for i6 in IS do
            for i7 in IS do
              for i8 in IS do
                Print("\n",i1," ",i2," ",i3," ",i4," ",i5," ",i6," ",i7," ",i8);
                R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[i1,i2,i3,i4,i5,i6,i7,i8]];
                G:=PcgsOfR(R);
                Print(IdSmallGroup(G),"\c");RMAXSUCH(G);
                od;
              od;
            od;
          od;
        od;
      od;
#    od;
  od;
DisplayProfile();
XSAMMEL256:=StructuralCopy(XSAMMEL);;

IS:=[4,3,2,1];
for i1 in IS do i2:=i1; i3:=i1;
#  for i2 in IS do
#    for i3 in IS do
      for i4 in IS do
        for i5 in IS do
          for i6 in IS do
            for i7 in IS do
              for i8 in IS do
                Print("\n",i1," ",i2," ",i3," ",i4," ",i5," ",i6," ",i7," ",i8,"\c");
                R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[i1,i2,i3,i4,i5,i6,i7,i8]];
                G:=PcgsOfR(R);
                Print(IdSmallGroup(G),"\c");RMAXSUCH(G);
                od;
              od;
            od;
          od;
        od;
#      od;
#    od;
  od;
XSAMMEL256A:=StructuralCopy(XSAMMEL);;
XSAMMEL:=StructuralCopy(XSAMMEL256A);;

IS:=[2,1];inh:=100000;
for i1 in IS do i2:=i1;
#  for i2 in IS do
    for i3 in IS do
      for i4 in IS do
        for i5 in IS do
          for i6 in IS do
            for i7 in IS do
              for i8 in IS do
                for i9 in IS do inh:=inh+1;
                  Print("\n",i1," ",i2," ",i3," ",i4," ",i5," ",i6," ",i7," ",i8," ",i9);
                  R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[i1,i2,i3,i4,i5,i6,i7,i8,i9]];
                  G:=PcgsOfR(R);
                  Print(inh,"\c");RMAXSUCH(G);
                  od;
                od;
              od;
            od;
          od;
        od;
      od;
#    od;
  od;
XSAMMEL512:=StructuralCopy(XSAMMEL);;

#nachfolgendes ging bis:
#"Gruppe [ 256, 55969 ] fehlt noch ......................
#Gruppe [ 256, 55969 ] jetzt drin .Error, exceeded the permitted memory (`-o' command line option) in
#also da muss noch eine Lösung her.
#einzeln erhalte ich aus 444444444
             7 [ 2, 2, 2, 2, 2, 2, 2 ] 16 [64] 128 [ 128, 2326 ]
               8 [ 2, 2, 2, 2, 2, 2, 1, 1 ] 64 [125] 0 [ 256, 56091 ]
               8 [ 2, 2, 2, 2, 2, 2, 2, 2 ] 64 [128] 128 [ 256, 56089 ]
                 9 [ 256, 256, 256, 256, 256, 256, 256, 256, 255 ] 128 [128] 
#einzeln erhalte ich aus 444444442 Error out of memory:
4 4 4 4 4 4 4 4 23........
Gruppe [ 256, 55782 ] fehlt noch ....
Gruppe [ 128, 2194 ] fehlt noch ...............................................................................................................................
Gruppe [ 128, 2194 ] jetzt drin
Gruppe [ 128, 2164 ] fehlt noch ...............................................................................................................................
Gruppe [ 128, 2164 ] jetzt drin ...........................................................................................................................................................................................................................................................
Gruppe [ 256, 55782 ] jetzt drin
Gruppe [ 256, 55969 ] fehlt noch ...............................................................................................................................................................................................................................................................
Gruppe [ 256, 55969 ] jetzt drin .....................................gap: cannot extend the workspace any more!
#Prognose aus n=32:
#44444
#44442
#44432
#44431
for i1 in IS do i2:=i1; i3:=i1;
#  for i2 in IS do
#    for i3 in IS do
      for i4 in IS do
        for i5 in IS do
          for i6 in IS do
            for i7 in IS do
              for i8 in IS do
                for i9 in IS do inh:=inh+1;
                  Print("\n",i1," ",i2," ",i3," ",i4," ",i5," ",i6," ",i7," ",i8," ",i9,"\c");
                  R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[i1,i2,i3,i4,i5,i6,i7,i8,i9]];
                  G:=PcgsOfR(R);
                  Print(" inh=",inh,"\c");RMAXSUCH(G);
                  Print("\007");Error("Pause");
                  od;
                od;
              od;
            od;
          od;
        od;
#      od;
#    od;
  od;
XSAMMEL512A:=StructuralCopy(XSAMMEL);;
XSAMMEL:=XSAMMEL512A;;

#>kurzversion n=32:
XSAMMEL:=[];#nur anfangs einmal
IS:=[4,3,2,1];
for i1 in IS do i2:=i1; i3:=i1;
      for i4 in IS do
        for i5 in IS do
          Print("\n",i1," ",i2," ",i3," ",i4," ",i5);
          R:=[[1],[1,1],[2,2,2],[2,2,2,2],[i1,i2,i3,i4,i5]];
          G:=PcgsOfR(R);
          Print(IdSmallGroup(G),"\c");RMAXSUCH(G);
          od;
        od;
  od;
oder nur
XSAMMEL:=[];#nur anfangs einmal
R:=[[1],[1,1],[2,2,2],[2,2,2,2],[4,4,4,4,4]];G:=PcgsOfR(R);Print(IdSmallGroup(G),"\c");RMAXSUCH(G);XMERKZAHL;WEGEZAHL;
#wird [ 16, 16, 16, 16, 15 ] 5 19
Gruppe [ 16, 4 ] jetzt drin 
Gruppe [ 16, 2 ] jetzt drin 
Gruppe [ 16, 12 ] jetzt drin ...........................5
R:=[[1],[1,1],[2,2,2],[2,2,2,2],[4,4,4,4,2]];G:=PcgsOfR(R);Print(IdSmallGroup(G),"\c");RMAXSUCH(G);XMERKZAHL;WEGEZAHL;
#wird [ 2, 2, 1, 16, 16 ] 11 54
 Gruppe [ 16, 4 ] jetzt drin 
Gruppe [ 16, 3 ] jetzt drin 
 Gruppe [ 16, 12 ] jetzt drin 
Gruppe [ 16, 10 ] jetzt drin ...........................11
R:=[[1],[1,1],[2,2,2],[2,2,2,2],[4,4,4,3,2]];G:=PcgsOfR(R);Print(IdSmallGroup(G),"\c");RMAXSUCH(G);XMERKZAHL;WEGEZAHL;
#wird [ 2, 2, 2, 16, 15 ] 5 20
wie bei 44444 3 Stück 4 2 12
R:=[[1],[1,1],[2,2,2],[2,2,2,2],[4,4,4,3,1]];G:=PcgsOfR(R);Print(IdSmallGroup(G),"\c");RMAXSUCH(G);XMERKZAHL;WEGEZAHL;
#wird [ 1, 1, 1, 16, 15 ] 7 41
 Gruppe [ 16, 3 ] jetzt drin 
 Gruppe [ 16, 2 ] jetzt drin 
 Gruppe [ 16, 12 ] jetzt drin 
Gruppe [ 16, 11 ] jetzt drin ...........................7

###dasselbe jetzt für n=512:
XSAMMEL:=[];#nur anfangs einmal

inh:=444444444;#unbedingt setzen, nicht 0 lassen!!!
R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[4,4,4,4,4,4,4,4,4]];G:=PcgsOfR(R);RMAXSUCH(G);XMERKZAHL;WEGEZAHL;
#?wird [ 16, 16, 16, 16, 15 ] 5 19
Gruppe [ 256, 55642 ] jetzt drin 16:09h1,7%
Gruppe [ 256, 55639 ] jetzt drin 
Gruppe [ 256, 55640 ] jetzt drin 
Gruppe [ 256, 55637 ] jetzt drin 
Gruppe [ 256, 56089 ] jetzt drin 17:25h
Error, no 1st choice method found for `[]' on 2 arguments called from
2 ^ STUFE <= n called from
XMISCH( i[6], 1, STUFE + 1 ); called from
brk> XSAMMELVIEWER1(XSAMMEL);       
                9 [ 256, 256, 256, 256, 256, 256, 256, 256, 255 ] Pcgs([ f1, f2*f3*f4*f5*f6*f7*f8, f7, f6, f5, f4, f3, f2, f9 ]) <=== [ 512, 0 ] (1) 
XMERKZAHL=5;WEGEZAHL=1854266

inh:=444444442;#unbedingt setzen, nicht 0 lassen!!!
R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[4,4,4,4,4,4,4,4,2]];G:=PcgsOfR(R);RMAXSUCH(G);XMERKZAHL;WEGEZAHL;
#?wird [ 2, 2, 1, 16, 16 ] 11 54
Gruppe [ 256, 55991 ] jetzt drin 
Gruppe [ 256, 56089 ] jetzt drin 
Gruppe [ 256, 55799 ] jetzt drin 
Gruppe [ 256, 55975 ] fehlt noch .......dann aber Error Memory bei
1 [ 1 ] 1 <=== [ 2, 1 ] (1) 
  2 [ 2, 2 ] 2 <=== [ 4, 1 ] (2) 
    3 [ 2, 2, 2 ] 4 <=== [ 8, 4 ] (3) 
      4 [ 2, 2, 2, 2 ] 8 <=== [ 16, 12 ] (1) 
        5 [ 2, 2, 2, 2, 2 ] 72 <=== [ 32, 50 ] (53) 
          6 [ 2, 2, 2, 2, 2, 2 ] 32 <=== [ 64, 266 ] (17) 
            7 [ 2, 2, 2, 2, 2, 2, 1 ] 32 <=== [ 128, 2325 ] (1) 
              8 [ 2, 2, 2, 2, 2, 2, 98, 98 ] 864 <=== [ 256, 55991 ] (321) 
                9 [ 2, 2, 2, 2, 2, 2, 2, 2, 1 ] Pcgs(
 R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[2,2,2,2,1,1,1,256,256]];G:=PcgsOfR(R);RMAXSUCH(G);XMERKZAHL;WEGEZAHL;
Gruppe [ 256, 56088 ] jetzt drin Das ist schon der Beweis, dass nicht in den folgenden enthalten
Gruppe [ 256, 55991 ] jetzt drin 
Gruppe [ 256, 55799 ] jetzt drin 
Gruppe [ 256, 55782 ] jetzt drin 
Gruppe [ 256, 55990 ] jetzt drin 
Gruppe [ 256, 55841 ] fehlt noch halt, das kann ja p-class>2 sein!!!
also gleich mit der richtigen anfangen:
 R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[2,2,2,2,2,2,1,256,256]];G:=PcgsOfR(R);RMAXSUCH(G);XMERKZAHL;WEGEZAHL;

inh:=444444432;#unbedingt setzen, nicht 0 lassen!!!
R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[4,4,4,4,4,4,4,3,2]];G:=PcgsOfR(R);RMAXSUCH(G);XMERKZAHL;WEGEZAHL;
#?wird [ 2, 2, 2, 16, 15 ] 5 20
Gruppe [ 256, 55991 ] jetzt drin 
Gruppe [ 256, 55800 ] jetzt drin 
Gruppe [ 256, 55969 ] jetzt drin 
Gruppe [ 256, 55783 ] jetzt drin 
Gruppe [ 256, 55840 ] jetzt drin 
Gruppe [ 256, 55639 ] jetzt drin
Gruppe [ 256, 56089 ] jetzt drin 1h14%20%.2h33%2410708 9 [ 2, 2, 2, 2, 2, 2, 2, 256, 255 ] 8h54% dann irgendwannERROR Memory
XMERKZAHL war >=24 und WEGEZAHL>500000

inh:=444444431;#unbedingt setzen, nicht 0 lassen!!!
R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[4,4,4,4,4,4,4,3,1]];G:=PcgsOfR(R);RMAXSUCH(G);XMERKZAHL;WEGEZAHL;
#?wird [ 1, 1, 1, 16, 15 ] 7 41---nicht ganz!!!
Gruppe [ 256, 55990 ] jetzt drin 
 Gruppe [ 256, 55800 ] jetzt drin 
Gruppe [ 256, 55975 ] jetzt drin 
Gruppe [ 256, 55794 ] jetzt drin 
Gruppe [ 256, 55847 ] jetzt drin 8,6%
 Gruppe [ 256, 55840 ] jetzt drin 
 Gruppe [ 256, 55639 ] jetzt drin 2h3,2%
 Gruppe [ 256, 56089 ] jetzt drin 
Gruppe [ 256, 56090 ] jetzt drin >3h24,8%
versehentlich beendet, aber erstes erhofftes Ergebnis ist da: 9 [ 2, 2, 2, 2, 2, 1, 1, 256, 255 ]
ich muss aber dabei [1,1... als [1,... lesen!!! Dann stimmt es. Das war knapp!!!! Hätt ich beihnahe übersehen. Also geht weiter.
XMERKZAHL=45 bis hierher, WEGEZAHL=1426211
[4,4,4,4,4][ 16, 16, 16, 16, 15 ][256,256,256,256,256,256,256,256,256]
[4,4,4,4,2]   [ 2, 2, 1, 16, 16 ]????[ 2, 2, 2, 2, 2, 2, 1, 256, 256 ]
[4,4,4,3,2]   [ 2, 2, 2, 16, 15 ][ 2, 2, 2, 2, 2, 2, 2, 256, 255 ]
[4,4,4,3,1]   [ 1, 1, 1, 16, 15 ][ 2, 2, 2, 2, 2, 1, 1, 256, 255 ]
2 Ergebnisse:
- bei weitem nicht alle i1...i5 bilden eine Gruppe, ach ja, die ersten drei i1=i2=i3 sind ja gleich!!!
    aber außer wo i1=i2=2, da kann und muss auch i3=1 sein!!!
- warum durchläuft eine bereits in XSAMMEL enthaltene Gruppe alle "...."?

G:=SmallGroup(128,2229);
RMAXSUCH(G);time;
#dauert 1600
R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[4,4,4,4,4,4,4]];
G:=AsGroup(MagmaByMultiplicationTable(MatrixOf(R)));
RMAXSUCH(G);time;
G:=PcgsOfR(R);
RMAXSUCH(G);time;
#dauert 17760
#und hält sich überdies bei einzelnen Punkten "." auf
#das darf doch nicht sein!!!
#das könnte daran liegen, dass ich wohl den [[1],[1,1]...]-Zweig aus XSAMMEL ausgeschlossen habe, 
#der muss dann halt wieder mit rein.
#ok hab das in Zeile 88 auskommetiert
#daraufhin erscheint auch [[1],[1,1],[4,4,4]] in XSAMMELVIEWER2(XSAMMELVIEWER2
vv aber jetzt dauert inh=202 ewig, 
vv ich vermute weil viele XMERK in XSAMMEL rein müssen)???
vv auch dauert RMAXSUCH immer noch ewig 
vv zweite Fehlermöglichkeit: G ist keine pc-Group
vv also muss ich das entsprechende MatrixOf suchen oder machen...
ok ja das ist PcgsOfR(R) aus D4_2_37.txt!!! Also alles da
ok jetzt geht Versuch1 ganz flott, sogar schneller bei nur [[1],[2,2]]
.. aber das dürfte eigentlich nicht sein, mit [[1],[1,1]...] muss schneller sein
.. und das brauch ich auch jetzt, weil viel isomorph ist.
.. dazu mache ich mal in beiden Varianten ... 

T(64);
G:=SmallGroup(64,226);
RMAXSUCH(G);time;

.. der Unterschied ist 200 zu 1780. Das darf doch nicht sein!!!
.. gut, das muss ich rausbekommen, erstemal überlegen, das ist die nächste Aufgabe.
.. wenn G schon drin ist, müsste das ja sofort rauskommen!!!

QY10A:=function(HRES,S,GROUP)#ob HRES ein pcgs ist
  local RET,j;
  RET:=(HRES[1])^2 in GROUP;
  for j in [2..S] do
    if not Commu(HRES[1],HRES[j]) in GROUP then RET:=false; fi; od;#C
#if S=2 and (HRES[1])^2=(HRES[1])^0 then RET:=false; fi;#wenn if, dann nur [[1],[2,2]...] in XSAMMEL rein, dafür längere Suche wenn G schon in XSAMMEL drin
#if S=3 and (HRES[1]*HRES[3])^2=(HRES[1])^0 then RET:=false; fi;
#if S=4 and (HRES[1]*HRES[2])^2=(HRES[1])^0 and (HRES[2]*HRES[3])^2<>(HRES[1])^0 then RET:=false; fi;
  return RET;
  end;

.. noch zu unübersichtlich, also vielleicht reicht schon

T(8);
G:=SmallGroup(8,3);
RMAXSUCH(G);time;

.. ja, das reicht schon: 10 - 20. G entspricht
Prob:=function(RX);
  R:=RX;
  G:=PcgsOfR(R);
  n:=Size(G);
  RMAXSUCH(G);
  Print(IdSmallGroup(G));
  end;
  

Prob([[1],[1,1],[3,1,3]]);
Prob([[1],[1,1],[4,1,1]]);
Prob([[1],[1,1],[1,3,1]]);
Prob([[1],[1,1],[1,4,4]]);
Prob([[1],[1,1],[1,1,2]]);
Prob([[1],[1,1],[2,2,1]]);
Prob([[1],[2,2],[1,1,1]]);
R:=[[1],[1,1],[3,3,1]];
G:=PcgsOfR(R);IdSmallGroup(G);
n:=Size(G);RMAXSUCH(G);time;
R:=[[1],[1,1],[3,3,3]];
G:=PcgsOfR(R);IdSmallGroup(G);
n:=Size(G);RMAXSUCH(G);time;

ok hab jetzt extra neu XSAMMELVIEWER1(XSAMMEL)
vv und bei Prob(...) da ist eindeutig was nicht funktionierend!!!
vv deranbleiben!!! aber erstmal Pause.
vv huiii da stimmt ja überhaupt nix
   vv erstens einmal das erste R ist meistens false, muss aber immer true sein
   ok zweitens dann wenn einmal true-1-1, dann dürfen nur noch Punkte "..." sein
      das konnte aber an erstens liegen weil ERSTBIT dann -1 ist
      und dann soll ja BRIT unwirksam sein
      also liegt alles an erstens.
ok na gut, hab eine mögliche Stelle gefunden: 
   in QY13 muss bei ZR[3]=0 auch RDRIN=-1 gesetzt werden
   das ist möglicherweise bei irgendeiner Umstellung verlorengegangen
vv jetzt aber ist bei n=64, inh=197 ein HRES=67 statt HRES=[...] da.???
   das nachher weiter, erstmal kurze Pause
   Versuch: ich setze bei ZR[3]=0 auch RDRIN=-1 nur beim allerallerersten Durchlauf
   ALLERANFANGSBIT:=-1;
ok da muss noch ALLERANFANGSBIT:=-1 aucH beim ersten ZR[3]<>0 rein
   dann erhalte ich das gewünschte Resultat:
   mit/ohne [[1],[1,1]...] 
   T(64) 1950/390 ms
   RMAXSUCH(SmallGroup(64,226) 140/0 ms !!!
   Versuch1 geht trotz zusätzlichem [[1],[1,1]...] bei i1-i6 minimal schneller.
   Ergebnis von i1-i7 steht noch aus, aber "ohne" ist schon beim Aufholen
   also Versuch1 mit [[1],[1,1]...]
üü dann muss ich aber nochmal schauen, 
   ob es auch doch noch öfters geht, damit nix verschenkt.
ok auch mal die überflüssigen i1<>i2<>i3 herausnehmen und damit MatrixOf
   ok perfekt: Am Anfang großer Rückstand, am Ende riesen Vorsprung.
vv wo ist 

R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2]];
G:=AsGroup(MagmaByMultiplicationTable(MatrixOf(R)));
RMAXSUCH(G);time;
G:=PcgsOfR(R);
RMAXSUCH(G);time;

ok ach so, ist gar nicht dabei bei R:=[[1],[1,1],[2,2,2]..., 
   dehalb umändern bei IS=[2,1];
.. dann muss ich aber nochmal schauen, 
   ob es auch doch noch öfters geht, damit nix verschenkt.
   denn inh=202 dauert doch auffällig lange
   dabei auch Size am längsten und PositionFirstComponentRepariert
nö dazu ALLERANFANGSBIT:=0 mal von RMAXSUCH in QY13 verschieben
   nur probehalber mal, geht aber leider nicht.

ClearProfile();
G:=SmallGroup(64,202);
RMAXSUCH(G);time;
DisplayProfile();

ClearProfile();
G:=SmallGroup(64,201);
RMAXSUCH(G);time;
DisplayProfile();

also nix geht heute mehr -> Aus.

ok warum geht "ist schon drin" oftmals erst nach 4 oder 5 Punkten?
   nee das ist schon ok, das ist weil nicht jedes HRES ein pcgs ist
   und hat auch kaum Zeitverbrauch
ok neue GAP-Version mal installieren ob da PositionFirstComponent korrekt geht
   ist installiert, aber PositionFirstComponent geht dort noch nicht
ok jetzt ist bei inh=56089 nochmal ein Fehler: R=[[..2,1]] dauert ewig???
   huuu ja, da ist bei XSAMMELVIEWER1(XSAMMEL)
   tatsächlich nicht 8[2,2,2,2,2,2,2,1] enthalten
   und auch nicht 8[2,2,2,2,2,2,1,2]
   und 8[2,2,2,2,2,2,1,1]
   das müsste aber alles schon bei 8[2,2,2,2,2,2,2,2]
   mit rauskommen
   Vorgehen: ich ergänze mal noch die fehlenden
   und vergleiche dann die beiden XSAMMEL 
   das läuft darauf hinaus, QY13 nochmal durchzuchecken.
   aaaaha, das liegt daran weil ich für n=nmax=256 
   eine Speichersparmodus drin hab, den muss ich natürlich ausmachen
   und auch in XSAMMEL die 255 256 in was anderes umwandeln z.B. 10001 und 10002
   ok das scheint der Fehler gewesen zu sein, 
   jetzt sollte auch i1-i8 durchgehen

ClearProfile();
XSAMMEL:=[];#nur anfangs einmal
G:=SmallGroup(256,56089);
RMAXSUCH(G);time;Print("\007");
DisplayProfile();
XSAMMELMERK56089:=StructuralCopy(XSAMMEL);;
XSAMMEL:=StructuralCopy(XSAMMELMERK56089);;
R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2]];
G:=PcgsOfR(R);Size(G);IdSmallGroup(G);
RMAXSUCH(G);time;
R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,1]];
G:=PcgsOfR(R);Size(G);IdSmallGroup(G);
RMAXSUCH(G);time;
XSAMMELMERK56089A:=StructuralCopy(XSAMMEL);;
R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,1,2]];
G:=PcgsOfR(R);Size(G);IdSmallGroup(G);
RMAXSUCH(G);time;
XSAMMELMERK56089B:=StructuralCopy(XSAMMEL);;
R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,1,1]];
G:=PcgsOfR(R);Size(G);IdSmallGroup(G);
RMAXSUCH(G);time;
XSAMMELMERK56089C:=StructuralCopy(XSAMMEL);;

nö was auch interessant wäre, statt R=[1][1,1]...[4...]] durchweg mit
   R=[1][2,2]...[4...]] zu beginnen
ok dafür bräuchte ich aber ein IsConfluent für das Pcgs
.. auch ListX müsste ich mal aktivieren.
ok aber neee, R=[1][2,2]...[4...]] geht nicht als Ausgangspunkt
   weil dann statt 4... auch 1-256 stehen kann...
   also bleibt doch nur R=[1][1,1]...[4...]].
.. dann nochmal den ganzen RBIT-Ablauf von QY13 checken.
   .. ich mach mal WEGEBAUM raus
      da geht n=32, inh=51 verhältnismäßig langsam, das dürfte eigentlich nicht sein
      also ALLERANFANGSBIT auch inaktiv machen.
      da ist bei n=32, inh=21 ein Error in WEBEBAUM
      den wollte ich sowieso rausmach-->
      dann fehlt bei n=64, inh=226 auf einmal [32,27] und [32,28]
      wieso das?, Die waren doch schon bei T(32) dabei!!!
      und wieso ist da HRES2=1083 und nicht [...irgendwas...]???
      aha, da wurde halt 32,27] und [32,28] nicht vollständig gespeichert
      das auch bei [32,48] --> extra probieren
      und sogar bei [16,13]
      na und da stimmt was nicht
      das erste [ 1, 1, 8 ] ist [8,3]
      aber das dritte [ 1, 1, 3 ] ist [8,2]
      und kann deshalb unmöglich ZR3MERK=0 zurückliefern
      denn das sollte noch nicht in XSAMMEL drin sein!!!???!!!
      nee doch, [ 1, 1, 3 ] war schon mal weiter oben drin ganz kurz
      nächster Versuch, ich generiere [8,2] und [8,3] extra vorher
OK so, jetzt hab ich mal in QY21MINI die völlig unverständliche Zeile
   #  if ISO=0 then INDEX1:=0; else INDEX1:=ZEIGER[ISO][14]; fi;
   herausgemacht, mal sehen, was da läuft.
   ja, scheint alles zu gehen, nee doch nicht
   die Zeile war schon nötig um über REKURSIV die Wegenummern beizubehaten
   statt dessen hab ich mal mit ZSIZE in QY21MINI die Nummer etwas vereinfacht
   mal sehen wie weit das geht
.. damit nochmal zurück zu "ohne WEGEBAUM"
.. den muss ich mir mal ausgeben und ausgiebig anschauen 
   zusammen mit XSAMMELVIEWER1(XSAMMEL)
.. na gut, morgen mach ich mal WEGEBAUM wieder mit []-Spitzen.
.. wo sind die fehlenden 2 Wege für alle Wege?
   dazu RDRIN mal vorübergehend unwirksam machen
   zuvor aber WEGEBAUM ganz neu fertigmachen auch die Spitzen
   
   
   

Gruppe [ 8, 2 ] jetzt drin 
[ 1, 1, 8 ][ 10001, 10001, 10002, 10001 ] -1 0 
[ 1, 1, 4 ][ 10002, 10002, 10001, 10002 ] 0 -1 .
[ 1, 1, 3 ][ 10002, 10002, 10001, 10002 ] 0 -1 ..

XSAMMEL:=[];#nur anfangs einmal
G:=SmallGroup(64,267);
RMAXSUCH(G);time;Print("\007");


XSAMMEL:=[];#nur anfangs einmal
G:=SmallGroup(32,48);
RMAXSUCH(G);time;Print("\007");
XSAMMELVIEWER1(XSAMMEL);

XSAMMEL:=[];#nur anfangs einmal
G:=SmallGroup(16,13);
RMAXSUCH(G);time;Print("\007");
XSAMMELVIEWER1(XSAMMEL);

XSAMMEL:=[];#nur anfangs einmal
G:=SmallGroup(8,2);
RMAXSUCH(G);time;
G:=SmallGroup(8,3);
RMAXSUCH(G);time;
G:=SmallGroup(8,4);
RMAXSUCH(G);time;
XSAMMELVIEWER1(XSAMMEL);
G:=SmallGroup(16,13);
RMAXSUCH(G);time;Print("\007");
XSAMMELVIEWER1(XSAMMEL);
WEGEZAHL;

1111
1131
1211
1241
1231
1181
1141
1212

1 [ 1 ] 1  #5 2 [ 2, 1 ]<=k1 ##12 1 
  2 [ 1, 1 ] 1  #5 9 [ 4, 2 ]<=k1 ##12 1 
    3 [ 3, 3, 3 ] 1 ==>[ 4, 4, 4 ]3[ 8, 2 ] 
    3 [ 3, 1, 3 ] 2 ==>[ 1, 4, 4 ]6[ 8, 3 ] 
Y    3 [ 4, 4, 4 ] 3  #5 0 [ 8, 2 ]<=k2===>[ 2, 2, 1 ]3[ 8, 2 ] 1 
    3 [ 4, 1, 1 ] 4 ==>[ 1, 4, 4 ]6[ 8, 3 ] 
    3 [ 1, 3, 1 ] 5 ==>[ 1, 4, 4 ]6[ 8, 3 ] 
Y    3 [ 1, 4, 4 ] 6  #5 0 [ 8, 3 ]<=k4===>[ 1, 1, 1 ]1[ 8, 3 ] 4 
    3 [ 1, 1, 2 ] 7 ==>[ 2, 2, 1 ]8[ 8, 3 ] 
Y    3 [ 2, 2, 1 ] 8  #5 0 [ 8, 3 ]<=k2===>[ 1, 1, 1 ]1[ 8, 3 ] 8 
Y    3 [ 2, 2, 2 ] 9  #5 0 [ 8, 2 ]<=k1===>[ 2, 2, 1 ]3[ 8, 2 ] 3 
  2 [ 2, 2 ] 2  #5 4 [ 4, 1 ]<=k1 ##12 2 
X    3 [ 1, 1, 1 ] 1  #5 4 [ 8, 3 ]<=k1 ##12 3 
      4 [ 1, 1, 2, 2 ] 1 ==>[ 2, 2, 2, 2 ]4[ 16, 13 ] 
      4 [ 2, 2, 1, 2 ] 2 ==>[ 2, 2, 2, 2 ]4[ 16, 13 ] 
      4 [ 2, 2, 2, 1 ] 3 ==>[ 2, 2, 2, 2 ]4[ 16, 13 ] 
      4 [ 2, 2, 2, 2 ] 4  #5 0 [ 16, 13 ]<=k4===>[ 2, 2, 1, 1 ]4[ 16, 13 ] 1 
    3 [ 1, 1, 2 ] 2 ==>[ 2, 2, 1 ]3[ 8, 2 ] 
X    3 [ 2, 2, 1 ] 3  #5 4 [ 8, 2 ]<=k2 ##12 1 
      4 [ 1, 1, 1, 2 ] 1 ==>[ 2, 2, 2, 1 ]4[ 16, 13 ] 
      4 [ 1, 1, 2, 1 ] 2 ==>[ 2, 2, 1, 2 ]3[ 16, 13 ] 
Y      4 [ 2, 2, 1, 2 ] 3  #5 0 [ 16, 13 ]<=k2===>[ 2, 2, 1, 1 ]4[ 16, 13 ] 1 
Y      4 [ 2, 2, 2, 1 ] 4  #5 0 [ 16, 13 ]<=k2===>[ 2, 2, 1, 1 ]4[ 16, 13 ] 3 
X    3 [ 2, 2, 2 ] 4  #5 4 [ 8, 4 ]<=k1 ##12 4 
      4 [ 1, 1, 1, 1 ] 1 ==>[ 2, 2, 1, 1 ]4[ 16, 13 ] 
      4 [ 1, 1, 1, 2 ] 2 ==>[ 2, 2, 1, 1 ]4[ 16, 13 ] 
      4 [ 1, 1, 2, 1 ] 3 ==>[ 2, 2, 1, 1 ]4[ 16, 13 ] 
X      4 [ 2, 2, 1, 1 ] 4  #5 0 [ 16, 13 ]<=k4 ##12 1 
1111
1191
1231
1241

.. bei [32,22] sind unterschiedliche WEGEZAHLEN
   dem muss ich nachgehen, da sind wohl doch zwei Durchläufe
   mit gleichem Anfang am Ende unterschiedlich.
.. aber erstmal die neue Wegespitze, so die ist drin
.. trotzdem noch unterschiedliche WEGEZAHLEN
   die muss ich genauestens herausfinden.
   Mit folgender Rechnung:
   
T(16);
G:=SmallGroup(32,33);#gefunden 25..28
RMAXSUCH(G);time;
XSAMMELVIEWER1(XSAMMEL);
WEGEZAHL;
.
[ 1, 2, 10, 1, 1 ][ 1 ] -1 false [ f1, f4, f5, f2, f3 ]|[ f3, f1, f1*f2*f5, f1*f2*f4, f5 ]0 
[ 1, 2, 10, 9, 5 ][ 5 ] -1 false [ f1, f4, f5, f3, f2 ]|[ f2, f1, f3*f4*f5, f3, f4 ]0 
[ 1, 2, 10, 9, 1 ][ 1 ] 0 false [ f1, f4, f5, f2*f3, f3 ]|[ f3, f1, f1*f2*f3*f4, f1*f2*f3*f4*f5, f4 ]0 
[ 1, 2, 10, 9, 1 ][ 1 ] 0 true [ f1, f5, f4, f2, f3 ]|[ f2*f3*f5, f1, f1*f2*f5, f1*f2*f4, f5 ]0 
[ 1, 2, 10, 1, 5 ][ 1 ] 0 false [ f1, f5, f4, f3, f2 ]|[ f1*f2*f3*f5, f1, f3*f4*f5, f3, f4 ]0 

das erste true überspringt das darauffolgende false,
dadurch ein WEGMERKER weniger.
na gut, muss ich erstmal so lassen.
Alle Prints und so zurück und mal weng laufenlassen...

.. neuer Fehler [64,206] da ist HRES2=1126??? Wieso das???
   ok dieser Fehler tritt nicht auf, wenn immer DDDD:=false;
      also muss ich da mal das XMISCH gucken...
   ok dieser Fehler tritt nicht auf, wenn ich nur RMAXSUCH ohne T(32) mach.
   ok dieser Fehler tritt nicht auf, wenn ich RMAXSUCH nach T(16) mach.
   ok dieser Fehler tritt auf, wenn ich RMAXSUCH nach T(32) mach.
      überhaupt, wieso fehlt dann [32,27]???
   also muss ich mal gucken wie XMISCH funktioniert hat.
   .. davor erstmal nur [32,27] vergleichen mit/ohne DDDD
      bei ohne DDDD fehlt ein Teil in XSAMMEL:
      XMERKZAHL=14 ohne DDDD (DDDDBIT=1)
      XMERKZAHL=6 mit DDDD (DDDDBIT=0)
      das ist ne ganze Menge
      nach den unteren Versuchen denke ich,
      dass wohl doch die neuen Wegspitzen nicht funktionieren
      Die alten mache ich aber nicht wieder her, 
      sondern versuche stattdessen ein anderes DDDD
   .. auf mit NEUWEGLAENGE.
      ok geht schon mal
      aber das HRES2=1150 ist immer noch drin
      als letzten Versuch mach ich
      if ZEIGER[j]<>NW then 
      statt if ZEIGER[j]<NW then
      aber da dauert inh=51 wieder ewig
      also hier muss noch eine Lösung her.
      als Behelf habe ich jetzt
          if ZEIGER[j]<NW then 
            DRINBIT:=false;
            fi;
          if ZEIGER[j]>NW+1 then 
            DRINBIT:=false;
            fi;
      reicht aber auch nicht
      XMERKZAHL=10 statt 14
      kann aber nicht so bleiben...
      gut, das reicht für heute

T(32);
T(16);
XSAMMEL:=[];#nur anfangs einmal
G:=SmallGroup(64,206);
RMAXSUCH(G);time;
XSAMMELVIEWER1(XSAMMEL);
WEGEZAHL;

XSAMMEL:=[];#nur anfangs einmal
DDDDBIT:=0;#kurze Variante
G:=SmallGroup(16,14);
RMAXSUCH(G);time;
G:=SmallGroup(16,11);
RMAXSUCH(G);time;
G:=SmallGroup(16,3);
RMAXSUCH(G);time;
G:=SmallGroup(32,27);
RMAXSUCH(G);time;
XMERKZAHL;#14 muss rauskommen und nicht 8
XSAMMEL1:=StructuralCopy(XSAMMEL);;

XSAMMEL:=[];#nur anfangs einmal
DDDDBIT:=1;DBIT:=1;#ausfuehrliche Variante
G:=SmallGroup(16,14);
RMAXSUCH(G);time;
G:=SmallGroup(16,11);
RMAXSUCH(G);time;
G:=SmallGroup(16,3);
RMAXSUCH(G);time;
G:=SmallGroup(32,27);
RMAXSUCH(G);time;
XMERKZAHL;#14 wie auch bisher schon

XSAMMEL=XSAMMEL1;
XSAMMELVIEWER2(XSAMMEL);
XSAMMELVIEWER3(XSAMMEL1);

nö neuer Ansatz: ich trage die Restweglänge erst nach kompletten 
   Durchlaufen der Teilstruktur in den Wegebaum ein. Ist eine kleine Hoffnung
   nee geht wohl auch nicht, damit bekomme ich nicht die folgende 2[....18,1] hin
   aber mit dieser Liste erhalte ich eine neue Idee:
nö also gut, mit dem jetzigen WEGMERKER sind zwei 
   definitiv verschiedene Teilstrukturen
   nicht mehr Wegedisjunkt. Das war vorher mal anders. 
   Deshalb WEGMERKER wieder zurück auf die Elementnummern
   und in die Wegspitze das PNEU rein.
   Konkret sind im obigen [32,27] folgende gleich, 
   welche eigentlich verschieden sein müssten
nö nö dazu kann ich erstmal die Wegspitze generell nullsetzen nö
ok als erstes in Q15 wieder aufwärts Zählen
nö dann die Restweglänge deaktivieren nö bleibt für Print
   Schwupp und da hab ich wieder meine XMERKZAHL=14 bei DDDDBIT=0
ok !!das erste RMAX[S]:=Size(ZR[2])+1 muss aber noch korrigiert werden
   !!! ja das muss ich machen, ich versuche QY12 vor QY10NEU zu bringen
ok mit altem WEGMERK (Size+i) von 8 auf 0,5h !!! -->Speichern!!!
ok ist gut geworden heute das alles. Fin.

2[ 1, 1, 1, 18, 1 ][ 1 ] 0 false [ f1, f4, f5, f2, f3 ]|HRES 0 
2[ 1, 1, 1, 18, 1 ][ 1 ] 0 true  [ f2, f4, f5, f1, f3 ]|HRES 0 

2[ 1, 1, 2, 1, 1 ][ 1 ] 0 false [ f1*f5, f4*f5, f2*f3*f5, f5, f3 ]|HRES 0 .
3[ 1, 1, 2, 1, 1 ][ 1 ] 0 false [ f2*f3, f4*f5, f1, f5, f3 ]|HRES 0 

2[ 1, 1, 1, 22, 3 ][ 1 ] 0 false [ f1, f4, f5, f2, f3 ]|HRES 0 
2[ 1, 1, 1, 22, 7 ][ 1 ] 0 false [ f2, f4, f5, f1, f3 ]|HRES 0 
2[ 1, 1, 4, 2, 1 ][ 1 ] 0 true   [ f1*f5, f4*f5, f2*f3*f5, f5, f3 ]|HRES 0 .
3[ 1, 1, 4, 2, 5 ][ 1 ] 0 true   [ f2*f3, f4*f5, f1, f5, f3 ]|HRES 0 

ok die Umstellung QY12 vor QY21MINI.
.. offensichtlich sind in einem true-Block noch einzelne false drin
   jedoch keine neuen *****, also könnte ich WEGMERKER
   noch ein wenig allgemeiner machen. hier:

4[ 1, 1, 1, 1, 285 ][ 1 ] 0 true  [ f3, f2, f4, f5, f1 ]|HRES 0 
2[ 1, 1, 1, 1, 157 ][ 1 ] 0 false [ f3, f2, f4*f5, f5, f1 ]|HRES 0 
3[ 1, 1, 1, 1, 509 ][ 1 ] 0 false [ f3, f4*f5, f2, f5, f1 ]|HRES 0 
2[ 1, 1, 1, 8, 5 ]  [ 1 ] 0 false [ f3, f4*f5, f5, f1, f2 ]|HRES 0 
1[ 1, 1, 1, 1, 633 ][ 1 ] 0 false [ f3, f4*f5, f5, f2, f1 ]|HRES 0 
1[ 1, 1, 1, 60, 3 ] [ 1 ] 0 false [ f3, f4*f5, f5, f1*f2*f4, f2 ]|HRES 0 

nö auch mal 3 und 4 nach 256 einsortieren? nö, bringt trotzdem die 15 16
.. zu diesem Zweck Bilden einer Gruppe entlang eines vorgegebenen Weges
   ok als Anfang WEGEDISP(WEG)
   .. weiter: neueste Idee, ich mache in jedem Schritt S ein Pcgs
      und dann die beiden phi Phi Transformationen
      und dann das nächste R[S] hinzu und damit aich Pcgs und phi Phi
      und so weiter. Ja, das sieht gut aus.
   .. außerdem kann ich als Behelf folgendes versuchen:
      ich gehe davon aus, dass zwar unterschiedliche Teilstrukturen 
      in jedem Fall disjunkt sind, aber gleiche Teilstrukturen
      auch unterschiedliche Wege enthalten. Wenn der erste Weg
      noch nicht enthalten ist, aber der zweite oder dritte,
      dann kann ich die Durchsuchung der Teilstruktur abbrechen.
      Damit entfällt ERSTBIT und bin wieder bei einer urzeitlichen Version.
      Allerdings wenn erst der dritte Weg enthalten ist, so kann dieser
      der erste Weg der aktuellen Teilstruktur gewesen sein,
      und das muss ich jetzt irgendwie ausschließen, möglcherweise mit NM.
   .. für eine endgültige Lösung:
      das WEGLI entspricht nur auf direktem Weg einem kompletten XMERK
      Teilstrukturen sind daher komplett unterschiedlich oder komplett gleich
      wenn alle XMERK unverändert in XSAMMEL gespeichert werden. 
      Wenn aber Umwege reinkommen, so könnten zwei origional unterschiedliche XMERK
      in ein einziges XMERK vom komprimierten XSAMMEL münden. Das hatte ich schon mal
      und jetzt besteht die Aussicht, das endgültig zu packen.
.. also denn mal los, rein mit der 4533R
   .. zuerst WEGEZAHL in die Wegspitze rein 


[ 1 ]1-->[ 1 ]==>[ 1 ]
[ 1, 1 ]1-->[ 1, 1 ]==>[ 1, 1 ]
[ 1, 3, 1 ]4-->[ 1, 4, 4 ]==>[ 1, 1, 1 ]
[ 1, 1, 2, 1 ]2-->[ 2, 2, 1, 1 ]==>[ 1, 1, 1, 1 ]
[ 1, 1, 8, 8, 1 ]1-->[ 1, 1, 8, 8, 1 ]==>[ 1, 1, 8, 8, 1 ]

Beispiel:
T(16);
R:=[[1],[1,1],[2,2,2],[4,4,4,3]];
G:=PcgsOfR(R);
RMAXSUCH(G);IdSmallGroup(G);
XSAMMELVIEWER2(XSAMMEL);
IdSmallGroup(G);
WEGLI;
WEGEDISP(WEGLI,XSAMMEL,1);#ergibt: R:=[[1],[2,2],[2,2,1],[8,8,7,7]];

.. gesucht ist jetzt die umgekehrte Richtung, 
