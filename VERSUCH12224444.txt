#XSAMMEL:=[];#nur anfangs einmal
ClearProfile();
IS:=[2,1];
for i1 in IS do i2:=i1;
#  for i2 in IS do
    for i3 in IS do
      for i4 in IS do
        for i5 in IS do
          for i6 in IS do
            Print("\n",i1," ",i2," ",i3," ",i4," ",i5," ",i6);
            R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[i1,i2,i3,i4,i5,i6]];
#            G1:=AsGroup(MagmaByMultiplicationTable(MatrixOf(R)));
#            if G1<>fail then 
              G:=PcgsOfR(R);
              Print(IdSmallGroup(G),"\c");RMAXSUCH(G); 
#              fi;
            od;
          od;
        od;
      od;
#    od;
  od;

IS:=[4,3,2,1];
for i1 in IS do i2:=i1; i3:=i1;
#  for i2 in IS do
#    for i3 in IS do
      for i4 in IS do
        for i5 in IS do
          for i6 in IS do
            Print("\n",i1," ",i2," ",i3," ",i4," ",i5," ",i6);
            R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[i1,i2,i3,i4,i5,i6]];
#            G1:=AsGroup(MagmaByMultiplicationTable(MatrixOf(R)));
#            if G1<>fail then 
              G:=PcgsOfR(R);
              Print(IdSmallGroup(G),"\c");RMAXSUCH(G);
#              fi;
            od;
          od;
        od;
#      od;
#    od;
  od;

IS:=[2,1];
for i1 in IS do i2:=i1;
#  for i2 in IS do
    for i3 in IS do
      for i4 in IS do
        for i5 in IS do
          for i6 in IS do
            for i7 in IS do
              Print("\n",i1," ",i2," ",i3," ",i4," ",i5," ",i6," ",i7);
              R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[i1,i2,i3,i4,i5,i6,i7]];
#              G1:=AsGroup(MagmaByMultiplicationTable(MatrixOf(R)));
#              if G1<>fail then 
                G:=PcgsOfR(R);
                Print(IdSmallGroup(G),"\c");RMAXSUCH(G);
#                fi;
              od;
            od;
          od;
        od;
      od;
#    od;
  od;
XSAMMEL128:=StructuralCopy(XSAMMEL);;

IS:=[4,3,2,1];
for i1 in IS do i2:=i1; i3:=i1;
#  for i2 in IS do
#    for i3 in IS do
      for i4 in IS do
        for i5 in IS do
          for i6 in IS do
            for i7 in IS do
              Print("\n",i1," ",i2," ",i3," ",i4," ",i5," ",i6," ",i7);
              R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[i1,i2,i3,i4,i5,i6,i7]];
#              G1:=AsGroup(MagmaByMultiplicationTable(MatrixOf(R)));
#              if G1<>fail then 
                G:=PcgsOfR(R);
                Print(IdSmallGroup(G),"\c");RMAXSUCH(G);
#                fi;
              od;
            od;
          od;
        od;
#      od;
#    od;
  od;
DisplayProfile();

IS:=[2,1];
for i1 in IS do i2:=i1;
#  for i2 in IS do
    for i3 in IS do
      for i4 in IS do
        for i5 in IS do
          for i6 in IS do
            for i7 in IS do
              for i8 in IS do
                Print("\n",i1," ",i2," ",i3," ",i4," ",i5," ",i6," ",i7," ",i8);
                R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[i1,i2,i3,i4,i5,i6,i7,i8]];
                G:=PcgsOfR(R);
                Print(IdSmallGroup(G),"\c");RMAXSUCH(G);
                od;
              od;
            od;
          od;
        od;
      od;
#    od;
  od;
DisplayProfile();
XSAMMEL256:=StructuralCopy(XSAMMEL);;

IS:=[4,3,2,1];
for i1 in IS do i2:=i1; i3:=i1;
#  for i2 in IS do
#    for i3 in IS do
      for i4 in IS do
        for i5 in IS do
          for i6 in IS do
            for i7 in IS do
              for i8 in IS do
                Print("\n",i1," ",i2," ",i3," ",i4," ",i5," ",i6," ",i7," ",i8,"\c");
                R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[i1,i2,i3,i4,i5,i6,i7,i8]];
                G:=PcgsOfR(R);
                Print(IdSmallGroup(G),"\c");RMAXSUCH(G);
                od;
              od;
            od;
          od;
        od;
#      od;
#    od;
  od;
XSAMMEL256A:=StructuralCopy(XSAMMEL);;
XSAMMEL:=StructuralCopy(XSAMMEL256A);;

IS:=[2,1];inh:=100000;
for i1 in IS do i2:=i1;
#  for i2 in IS do
    for i3 in IS do
      for i4 in IS do
        for i5 in IS do
          for i6 in IS do
            for i7 in IS do
              for i8 in IS do
                for i9 in IS do inh:=inh+1;
                  Print("\n",i1," ",i2," ",i3," ",i4," ",i5," ",i6," ",i7," ",i8," ",i9);
                  R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[i1,i2,i3,i4,i5,i6,i7,i8,i9]];
                  G:=PcgsOfR(R);
                  Print(inh,"\c");RMAXSUCH(G);
                  od;
                od;
              od;
            od;
          od;
        od;
      od;
#    od;
  od;
XSAMMEL512:=StructuralCopy(XSAMMEL);;

#nachfolgendes ging bis:
#"Gruppe [ 256, 55969 ] fehlt noch ......................
#Gruppe [ 256, 55969 ] jetzt drin .Error, exceeded the permitted memory (`-o' command line option) in
#also da muss noch eine Lösung her.
#einzeln erhalte ich aus 444444444
             7 [ 2, 2, 2, 2, 2, 2, 2 ] 16 [64] 128 [ 128, 2326 ]
               8 [ 2, 2, 2, 2, 2, 2, 1, 1 ] 64 [125] 0 [ 256, 56091 ]
               8 [ 2, 2, 2, 2, 2, 2, 2, 2 ] 64 [128] 128 [ 256, 56089 ]
                 9 [ 256, 256, 256, 256, 256, 256, 256, 256, 255 ] 128 [128] 
#einzeln erhalte ich aus 444444442 Error out of memory:
#tritt auch genauso auf beim neuen QY07L, da lässt sich aber noch was machen bei LETZTEWEGELISTE:
4 4 4 4 4 4 4 4 23........
Gruppe [ 256, 55782 ] fehlt noch ....
Gruppe [ 128, 2194 ] fehlt noch ...............................................................................................................................
Gruppe [ 128, 2194 ] jetzt drin
Gruppe [ 128, 2164 ] fehlt noch ...............................................................................................................................
Gruppe [ 128, 2164 ] jetzt drin ...........................................................................................................................................................................................................................................................
Gruppe [ 256, 55782 ] jetzt drin
Gruppe [ 256, 55969 ] fehlt noch ...............................................................................................................................................................................................................................................................
Gruppe [ 256, 55969 ] jetzt drin .....................................gap: cannot extend the workspace any more!
brk> WEGEZAHL;   
1262239
brk> MemoryUsage(LETZTEWEGELISTE);
1793353495
brk> MemoryUsage(XSAMMEL);        
88101617
brk> MemoryUsage(LETZTEWEGELISTE[100000]);
1693



#Prognose aus n=32:
#44444
#44442
#44432
#44431
IS:=[4,3,2,1];inh:=5000;
for i1 in IS do i2:=i1; i3:=i1;
#  for i2 in IS do
#    for i3 in IS do
      for i4 in IS do
        for i5 in IS do
          for i6 in IS do
            for i7 in IS do
              for i8 in IS do
                for i9 in IS do inh:=inh+1;
                  Print("\n",i1," ",i2," ",i3," ",i4," ",i5," ",i6," ",i7," ",i8," ",i9," \c");
#                  if [i1,i2,i3,i4,i5,i6,i7,i8,i9]<[4,4,4,4,1,...] then
                    R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[i1,i2,i3,i4,i5,i6,i7,i8,i9]];
                    G:=PcgsOfR(R);
                    Exec("date");RMAXSUCH(G);
#                    fi;
                  od;
                od;
              od;
            od;
          od;
        od;
#      od;
#    od;
  od;
XSAMMEL512A:=StructuralCopy(XSAMMEL);;
XSAMMEL:=XSAMMEL512A;;
#erste dauert 49 min:
4 4 4 4 4 4 4 4 4 Sa 9. Aug 08:38:44 CEST 2014
........
Gruppe [ 256, 55640 ] fehlt noch .....
Gruppe [ 128, 2157 ] fehlt noch ............................................................................................................................... <4116> 11
Gruppe [ 128, 2157 ] jetzt drin .......................................................................................................................................................................................................................................................... <23144> 5
Gruppe [ 256, 55640 ] jetzt drin
Gruppe [ 256, 55637 ] fehlt noch ....
Gruppe [ 128, 2154 ] fehlt noch ............................................................................................................................... <2033> 34
Gruppe [ 128, 2154 ] jetzt drin ........................................................................................................................................................................................................................................................... <30145> 11
Gruppe [ 256, 55637 ] jetzt drin ....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................... <373186> 5
4 4 4 4 4 4 4 4 3 Sa 9. Aug 09:25:33 CEST 2014

#>kurzversion n=32:
XSAMMEL:=[];#nur anfangs einmal
IS:=[4,3,2,1];
for i1 in IS do i2:=i1; i3:=i1;
      for i4 in IS do
        for i5 in IS do
          Print("\n",i1," ",i2," ",i3," ",i4," ",i5);
          R:=[[1],[1,1],[2,2,2],[2,2,2,2],[i1,i2,i3,i4,i5]];
          G:=PcgsOfR(R);
          Print(IdSmallGroup(G),"\c");RMAXSUCH(G);
          od;
        od;
  od;
oder nur
XSAMMEL:=[];#nur anfangs einmal
R:=[[1],[1,1],[2,2,2],[2,2,2,2],[4,4,4,4,4]];G:=PcgsOfR(R);Print(IdSmallGroup(G),"\c");RMAXSUCH(G);XMERKZAHL;WEGEZAHL;
#wird [ 16, 16, 16, 16, 15 ] 5 19
Gruppe [ 16, 4 ] jetzt drin 
Gruppe [ 16, 2 ] jetzt drin 
Gruppe [ 16, 12 ] jetzt drin ...........................5
R:=[[1],[1,1],[2,2,2],[2,2,2,2],[4,4,4,4,2]];G:=PcgsOfR(R);Print(IdSmallGroup(G),"\c");RMAXSUCH(G);XMERKZAHL;WEGEZAHL;
#wird [ 2, 2, 1, 16, 16 ] 11 54
 Gruppe [ 16, 4 ] jetzt drin 
Gruppe [ 16, 3 ] jetzt drin 
 Gruppe [ 16, 12 ] jetzt drin 
Gruppe [ 16, 10 ] jetzt drin ...........................11
R:=[[1],[1,1],[2,2,2],[2,2,2,2],[4,4,4,3,2]];G:=PcgsOfR(R);Print(IdSmallGroup(G),"\c");RMAXSUCH(G);XMERKZAHL;WEGEZAHL;
#wird [ 2, 2, 2, 16, 15 ] 5 20
wie bei 44444 3 Stück 4 2 12
R:=[[1],[1,1],[2,2,2],[2,2,2,2],[4,4,4,3,1]];G:=PcgsOfR(R);Print(IdSmallGroup(G),"\c");RMAXSUCH(G);XMERKZAHL;WEGEZAHL;
#wird [ 1, 1, 1, 16, 15 ] 7 41
 Gruppe [ 16, 3 ] jetzt drin 
 Gruppe [ 16, 2 ] jetzt drin 
 Gruppe [ 16, 12 ] jetzt drin 
Gruppe [ 16, 11 ] jetzt drin ...........................7

###dasselbe jetzt für n=512:
XSAMMEL:=[];#nur anfangs einmal

#Vortest:
R:=[[1],[1,1],[2,2,2]];G:=PcgsOfR(R);IdSmallGroup(G);RMAXSUCH(G);XSAMMELVIEWER1(XSAMMEL);XMERKZAHL;WEGEZAHL;
R:=[[1],[1,1],[2,2,2],[2,2,2,2]];G:=PcgsOfR(R);IdSmallGroup(G);RMAXSUCH(G);XSAMMELVIEWER1(XSAMMEL);XMERKZAHL;WEGEZAHL;
R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2]];G:=PcgsOfR(R);IdSmallGroup(G);RMAXSUCH(G);XSAMMELVIEWER1(XSAMMEL);XMERKZAHL;WEGEZAHL;
R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2]];G:=PcgsOfR(R);IdSmallGroup(G);RMAXSUCH(G);time;XSAMMELVIEWER1(XSAMMEL);XMERKZAHL;WEGEZAHL;
R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2]];G:=PcgsOfR(R);IdSmallGroup(G);RMAXSUCH(G);time;XSAMMELVIEWER1(XSAMMEL);XMERKZAHL;WEGEZAHL;
R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2]];G:=PcgsOfR(R);IdSmallGroup(G);RMAXSUCH(G);time;XSAMMELVIEWER1(XSAMMEL);XMERKZAHL;WEGEZAHL;

inh:=444444444;#unbedingt setzen, nicht 0 lassen!!!
R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[4,4,4,4,4,4,4,4,4]];G:=PcgsOfR(R);RMAXSUCH(G);XMERKZAHL;WEGEZAHL;
 R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[ 256, 256, 256, 256, 256, 256, 256, 256, 255 ]];G:=PcgsOfR(R);RMAXSUCH(G);XMERKZAHL;WEGEZAHL;
#?wird [ 16, 16, 16, 16, 15 ] 5 19
Gruppe [ 256, 55639 ] jetzt drin 
Gruppe [ 256, 55642 ] jetzt drin 
Gruppe [ 256, 55637 ] jetzt drin 
Gruppe [ 256, 55640 ] jetzt drin 
Gruppe [ 256, 56089 ] jetzt drin 17:25h
Error, no 1st choice method found for `[]' on 2 arguments called from
2 ^ STUFE <= n called from
XMISCH( i[6], 1, STUFE + 1 ); called from
brk> XSAMMELVIEWER1(XSAMMEL);       
                9 [ 256, 256, 256, 256, 256, 256, 256, 256, 255 ] Pcgs([ f1, f2*f3*f4*f5*f6*f7*f8, f7, f6, f5, f4, f3, f2, f9 ]) <=== [ 512, 0 ] (1) 
XMERKZAHL=5;WEGEZAHL=1854266

inh:=444444442;#unbedingt setzen, nicht 0 lassen!!!
R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[4,4,4,4,4,4,4,4,2]];G:=PcgsOfR(R);RMAXSUCH(G);XMERKZAHL;WEGEZAHL;
 R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[2,2,2,2,2,2,1,256,256]];G:=PcgsOfR(R);RMAXSUCH(G);XMERKZAHL;WEGEZAHL;
#?wird [ 2, 2, 1, 16, 16 ] 11 54
Gruppe [ 256, 56088 ]B1 jetzt drin 
Gruppe [ 256, 55991 ]12 jetzt drin 
Gruppe [ 256, 55799 ]23 jetzt drin 
Gruppe [ 256, 55782 ]44 jetzt drin 3,8% 100 min
Gruppe [ 256, 55990 ]65 jetzt drin 2,9% 112 min
Gruppe [ 256, 55841 ]96 jetzt drin 5,6% 132 min
Gruppe [ 256, 55840 ]77 jetzt drin 3,2% 152 min
Gruppe [ 256, 55969 ]88 jetzt drin 8,8% 196 min
Gruppe [ 256, 55975 ]39 jetzt drin 7,2% 228 min
Gruppe [ 256, 56089 ]AA jetzt drin 13,2% 235 min
Gruppe [ 256, 55642 ]5B jetzt drin 9,5% 245 min 
77 742124 9,5% 246 min
77 952161 11,0% 256 min
77 1428639 13,9% 282 min
77 2119635 17,9% 319 min... !!!
77 3666813 27,4% 367 min..............................................................
77 4359602 37,4% 420 min
77 5199522 45,5% 460 min......
77 5682128 52,9% 477 min
77 6063423 52,9% 510 min
77 6063703 52,9% 562 min
77 6063726 52,9% 721 min hier dann ^C, vielleicht ist da jetzt doch eine Bremsschleife drin

inh:=444444432;#unbedingt setzen, nicht 0 lassen!!!
R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[4,4,4,4,4,4,4,3,2]];G:=PcgsOfR(R);RMAXSUCH(G);XMERKZAHL;WEGEZAHL;
 R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,256,255]];G:=PcgsOfR(R);RMAXSUCH(G);XMERKZAHL;WEGEZAHL;
#?wird [ 2, 2, 2, 16, 15 ] 5 20
Gruppe [ 256, 56089 ] jetzt drin 
Gruppe [ 256, 55991 ] jetzt drin 15 min
Gruppe [ 256, 55800 ] jetzt drin 30 min
Gruppe [ 256, 55840 ] jetzt drin 60 min
Gruppe [ 256, 55969 ] jetzt drin 6,1% 70 min
Gruppe [ 256, 55783 ] jetzt drin 
Gruppe [ 256, 55639 ] jetzt drin
24 366632   4,2%  92 min
24 1688178 12,4% 137 min
24 2315194 ??? ??? ^C
^^^^ aktuell R=444444432 ^^^^

 Gruppe [ 256, 55991 ] jetzt drin 
 Gruppe [ 256, 55800 ] jetzt drin 
 Gruppe [ 256, 55969 ] jetzt drin 
 Gruppe [ 256, 55783 ] jetzt drin 
 Gruppe [ 256, 55840 ] jetzt drin 
Gruppe [ 256, 55639 ] jetzt drin
 Gruppe [ 256, 56089 ] jetzt drin 1h14%20%.2h33%2410708 9 [ 2, 2, 2, 2, 2, 2, 2, 256, 255 ] 8h54% dann irgendwannERROR Memory
XMERKZAHL war >=24 und WEGEZAHL>500000

inh:=444444431;#unbedingt setzen, nicht 0 lassen!!!
R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[4,4,4,4,4,4,4,3,1]];G:=PcgsOfR(R);RMAXSUCH(G);XMERKZAHL;WEGEZAHL;
 R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[2,2,2,2,2,1,1,256,255]];G:=PcgsOfR(R);RMAXSUCH(G);XMERKZAHL;WEGEZAHL;
#?wird [ 1, 1, 1, 16, 15 ] 7 41---nicht ganz!!!
Gruppe [ 256, 55990 ] jetzt drin 
 Gruppe [ 256, 55800 ] jetzt drin 
Gruppe [ 256, 55975 ] jetzt drin 
Gruppe [ 256, 55794 ] jetzt drin 
Gruppe [ 256, 55847 ] jetzt drin 8,6%
 Gruppe [ 256, 55840 ] jetzt drin 
 Gruppe [ 256, 55639 ] jetzt drin 2h3,2%
 Gruppe [ 256, 56089 ] jetzt drin 
Gruppe [ 256, 56090 ] jetzt drin >3h24,8%
versehentlich beendet, aber erstes erhofftes Ergebnis ist da: 9 [ 2, 2, 2, 2, 2, 1, 1, 256, 255 ]
ich muss aber dabei [1,1... als [1,... lesen!!! Dann stimmt es. Das war knapp!!!! Hätt ich beihnahe übersehen. Also geht weiter.
XMERKZAHL=45 bis hierher, WEGEZAHL=1426211

.. lib anlegen
   .. dazu muss ich nur bis zu einem bestimten XMERKZAHLZIEL rechnen
   .. Zeiten siehe oben
[4,4,4,4,4][16,16,16, 16, 15 ]5[256,256,256,256,256,256,256,256,256]
[4,4,4,4,2][ 2, 2, 1, 16, 16 ]77[ 2, 2, 2, 2, 2, 2, 1, 256, 256 ]
[4,4,4,3,2][ 2, 2, 2, 16, 15 ]24[ 2, 2, 2, 2, 2, 2, 2, 256, 255 ]
[4,4,4,3,1][ 1, 1, 1, 16, 15 ]45[ 2, 2, 2, 2, 2, 1, 1, 256, 255 ]
.. also mal los:
GANZLOS:=function()
  Exec("date");
  XSAMMEL:=[];#nur anfangs einmal
  ILIST:=[56082..56092];QQQY(256);Print("\007");
  inh:=4444;XMERKZAHLZIEL:=5;R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[ 256, 256, 256, 256, 256, 256, 256, 256, 255 ]];G:=PcgsOfR(R);RMAXSUCH(G);Print(XMERKZAHL," ",WEGEZAHL);
  inh:=4442;XMERKZAHLZIEL:=77;R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[2,2,2,2,2,2,1,256,256]];G:=PcgsOfR(R);RMAXSUCH(G);Print(XMERKZAHL," ",WEGEZAHL);
  inh:=4432;XMERKZAHLZIEL:=24;R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[2,2,2,2,2,2,2,256,255]];G:=PcgsOfR(R);RMAXSUCH(G);Print(XMERKZAHL," ",WEGEZAHL);
  inh:=4431;XMERKZAHLZIEL:=45;R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[2,2,2,2,2,1,1,256,255]];G:=PcgsOfR(R);RMAXSUCH(G);Print(XMERKZAHL," ",WEGEZAHL);
  inh:=4222;XMERKZAHLZIEL:=45;R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[2,2,2,2,1,256,256,256,256]];G:=PcgsOfR(R);RMAXSUCH(G);Print(XMERKZAHL," ",WEGEZAHL);
  Exec("date");
  end;
#SaveWorkSpace("GAP_WORKSPACE_4222")
#Ausgangspunkt dafuer war:
#AUZAHL:=4;GANZLOS();
#inh:=4444;R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[4,4,4,4,4,4,4,4,4]];G:=PcgsOfR(R);RMAXSUCH(G);Exec("date");
#inh:=4442;R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[4,4,4,4,4,4,4,4,2]];G:=PcgsOfR(R);RMAXSUCH(G);Exec("date");
#inh:=4432;R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[4,4,4,4,4,4,4,3,2]];G:=PcgsOfR(R);RMAXSUCH(G);Exec("date");
#inh:=4431;R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[4,4,4,4,4,4,4,3,1]];G:=PcgsOfR(R);RMAXSUCH(G);Exec("date");
#inh:=4222;R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[4,4,4,4,4,4,2,2,2]];G:=PcgsOfR(R);RMAXSUCH(G);Exec("date");
#inh:=4211;R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[4,4,4,4,4,4,2,1,1]];G:=PcgsOfR(R);RMAXSUCH(G);Exec("date");
#inh:=3222;R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[4,4,4,4,4,3,2,2,2]];G:=PcgsOfR(R);RMAXSUCH(G);Exec("date");

#DisplayProfile();


^^^^lib 512 anfangen



2 Ergebnisse:
- bei weitem nicht alle i1...i5 bilden eine Gruppe, ach ja, die ersten drei i1=i2=i3 sind ja gleich!!!
    aber außer wo i1=i2=2, da kann und muss auch i3=1 sein!!!
- warum durchläuft eine bereits in XSAMMEL enthaltene Gruppe alle "...."?

G:=SmallGroup(128,2229);
RMAXSUCH(G);time;
#dauert 1600
R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[4,4,4,4,4,4,4]];
G:=AsGroup(MagmaByMultiplicationTable(MatrixOf(R)));
RMAXSUCH(G);time;
G:=PcgsOfR(R);
RMAXSUCH(G);time;
#dauert 17760
#und hält sich überdies bei einzelnen Punkten "." auf
#das darf doch nicht sein!!!
#das könnte daran liegen, dass ich wohl den [[1],[1,1]...]-Zweig aus XSAMMEL ausgeschlossen habe, 
#der muss dann halt wieder mit rein.
#ok hab das in Zeile 88 auskommetiert
#daraufhin erscheint auch [[1],[1,1],[4,4,4]] in XSAMMELVIEWER2(XSAMMELVIEWER2
vv aber jetzt dauert inh=202 ewig, 
vv ich vermute weil viele XMERK in XSAMMEL rein müssen)???
vv auch dauert RMAXSUCH immer noch ewig 
vv zweite Fehlermöglichkeit: G ist keine pc-Group
vv also muss ich das entsprechende MatrixOf suchen oder machen...
ok ja das ist PcgsOfR(R) aus D4_2_37.txt!!! Also alles da
ok jetzt geht Versuch1 ganz flott, sogar schneller bei nur [[1],[2,2]]
.. aber das dürfte eigentlich nicht sein, mit [[1],[1,1]...] muss schneller sein
.. und das brauch ich auch jetzt, weil viel isomorph ist.
.. dazu mache ich mal in beiden Varianten ... 

T(64);
G:=SmallGroup(64,226);
RMAXSUCH(G);time;

.. der Unterschied ist 200 zu 1780. Das darf doch nicht sein!!!
.. gut, das muss ich rausbekommen, erstemal überlegen, das ist die nächste Aufgabe.
.. wenn G schon drin ist, müsste das ja sofort rauskommen!!!

QY10A:=function(HRES,S,GROUP)#ob HRES ein pcgs ist
  local RET,j;
  RET:=(HRES[1])^2 in GROUP;
  for j in [2..S] do
    if not Commu(HRES[1],HRES[j]) in GROUP then RET:=false; fi; od;#C
#if S=2 and (HRES[1])^2=(HRES[1])^0 then RET:=false; fi;#wenn if, dann nur [[1],[2,2]...] in XSAMMEL rein, dafür längere Suche wenn G schon in XSAMMEL drin
#if S=3 and (HRES[1]*HRES[3])^2=(HRES[1])^0 then RET:=false; fi;
#if S=4 and (HRES[1]*HRES[2])^2=(HRES[1])^0 and (HRES[2]*HRES[3])^2<>(HRES[1])^0 then RET:=false; fi;
  return RET;
  end;

.. noch zu unübersichtlich, also vielleicht reicht schon

T(8);
G:=SmallGroup(8,3);
RMAXSUCH(G);time;

.. ja, das reicht schon: 10 - 20. G entspricht
Prob:=function(RX);
  R:=RX;
  G:=PcgsOfR(R);
  n:=Size(G);
  RMAXSUCH(G);
  Print(IdSmallGroup(G));
  end;
  

Prob([[1],[1,1],[3,1,3]]);
Prob([[1],[1,1],[4,1,1]]);
Prob([[1],[1,1],[1,3,1]]);
Prob([[1],[1,1],[1,4,4]]);
Prob([[1],[1,1],[1,1,2]]);
Prob([[1],[1,1],[2,2,1]]);
Prob([[1],[2,2],[1,1,1]]);
R:=[[1],[1,1],[3,3,1]];
G:=PcgsOfR(R);IdSmallGroup(G);
n:=Size(G);RMAXSUCH(G);time;
R:=[[1],[1,1],[3,3,3]];
G:=PcgsOfR(R);IdSmallGroup(G);
n:=Size(G);RMAXSUCH(G);time;

ok hab jetzt extra neu XSAMMELVIEWER1(XSAMMEL)
vv und bei Prob(...) da ist eindeutig was nicht funktionierend!!!
vv deranbleiben!!! aber erstmal Pause.
vv huiii da stimmt ja überhaupt nix
   vv erstens einmal das erste R ist meistens false, muss aber immer true sein
   ok zweitens dann wenn einmal true-1-1, dann dürfen nur noch Punkte "..." sein
      das konnte aber an erstens liegen weil ERSTBIT dann -1 ist
      und dann soll ja BRIT unwirksam sein
      also liegt alles an erstens.
ok na gut, hab eine mögliche Stelle gefunden: 
   in QY13 muss bei ZR[3]=0 auch RDRIN=-1 gesetzt werden
   das ist möglicherweise bei irgendeiner Umstellung verlorengegangen
vv jetzt aber ist bei n=64, inh=197 ein HRES=67 statt HRES=[...] da.???
   das nachher weiter, erstmal kurze Pause
   Versuch: ich setze bei ZR[3]=0 auch RDRIN=-1 nur beim allerallerersten Durchlauf
   ALLERANFANGSBIT:=-1;
ok da muss noch ALLERANFANGSBIT:=-1 aucH beim ersten ZR[3]<>0 rein
   dann erhalte ich das gewünschte Resultat:
   mit/ohne [[1],[1,1]...] 
   T(64) 1950/390 ms
   RMAXSUCH(SmallGroup(64,226) 140/0 ms !!!
   Versuch1 geht trotz zusätzlichem [[1],[1,1]...] bei i1-i6 minimal schneller.
   Ergebnis von i1-i7 steht noch aus, aber "ohne" ist schon beim Aufholen
   also Versuch1 mit [[1],[1,1]...]
üü dann muss ich aber nochmal schauen, 
   ob es auch doch noch öfters geht, damit nix verschenkt.
ok auch mal die überflüssigen i1<>i2<>i3 herausnehmen und damit MatrixOf
   ok perfekt: Am Anfang großer Rückstand, am Ende riesen Vorsprung.
vv wo ist 

R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2]];
G:=AsGroup(MagmaByMultiplicationTable(MatrixOf(R)));
RMAXSUCH(G);time;
G:=PcgsOfR(R);
RMAXSUCH(G);time;

ok ach so, ist gar nicht dabei bei R:=[[1],[1,1],[2,2,2]..., 
   dehalb umändern bei IS=[2,1];
.. dann muss ich aber nochmal schauen, 
   ob es auch doch noch öfters geht, damit nix verschenkt.
   denn inh=202 dauert doch auffällig lange
   dabei auch Size am längsten und PositionFirstComponentRepariert
nö dazu ALLERANFANGSBIT:=0 mal von RMAXSUCH in QY13 verschieben
   nur probehalber mal, geht aber leider nicht.

ClearProfile();
G:=SmallGroup(64,202);
RMAXSUCH(G);time;
DisplayProfile();

ClearProfile();
G:=SmallGroup(64,201);
RMAXSUCH(G);time;
DisplayProfile();

also nix geht heute mehr -> Aus.

ok warum geht "ist schon drin" oftmals erst nach 4 oder 5 Punkten?
   nee das ist schon ok, das ist weil nicht jedes HRES ein pcgs ist
   und hat auch kaum Zeitverbrauch
ok neue GAP-Version mal installieren ob da PositionFirstComponent korrekt geht
   ist installiert, aber PositionFirstComponent geht dort noch nicht
ok jetzt ist bei inh=56089 nochmal ein Fehler: R=[[..2,1]] dauert ewig???
   huuu ja, da ist bei XSAMMELVIEWER1(XSAMMEL)
   tatsächlich nicht 8[2,2,2,2,2,2,2,1] enthalten
   und auch nicht 8[2,2,2,2,2,2,1,2]
   und 8[2,2,2,2,2,2,1,1]
   das müsste aber alles schon bei 8[2,2,2,2,2,2,2,2]
   mit rauskommen
   Vorgehen: ich ergänze mal noch die fehlenden
   und vergleiche dann die beiden XSAMMEL 
   das läuft darauf hinaus, QY13 nochmal durchzuchecken.
   aaaaha, das liegt daran weil ich für n=nmax=256 
   eine Speichersparmodus drin hab, den muss ich natürlich ausmachen
   und auch in XSAMMEL die 255 256 in was anderes umwandeln z.B. 10001 und 10002
   ok das scheint der Fehler gewesen zu sein, 
   jetzt sollte auch i1-i8 durchgehen

ClearProfile();
XSAMMEL:=[];#nur anfangs einmal
G:=SmallGroup(256,56089);
RMAXSUCH(G);time;Print("\007");
DisplayProfile();
XSAMMELMERK56089:=StructuralCopy(XSAMMEL);;
XSAMMEL:=StructuralCopy(XSAMMELMERK56089);;
R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2]];
G:=PcgsOfR(R);Size(G);IdSmallGroup(G);
RMAXSUCH(G);time;
R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,1]];
G:=PcgsOfR(R);Size(G);IdSmallGroup(G);
RMAXSUCH(G);time;
XSAMMELMERK56089A:=StructuralCopy(XSAMMEL);;
R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,1,2]];
G:=PcgsOfR(R);Size(G);IdSmallGroup(G);
RMAXSUCH(G);time;
XSAMMELMERK56089B:=StructuralCopy(XSAMMEL);;
R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,1,1]];
G:=PcgsOfR(R);Size(G);IdSmallGroup(G);
RMAXSUCH(G);time;
XSAMMELMERK56089C:=StructuralCopy(XSAMMEL);;

nö was auch interessant wäre, statt R=[1][1,1]...[4...]] durchweg mit
   R=[1][2,2]...[4...]] zu beginnen
ok dafür bräuchte ich aber ein IsConfluent für das Pcgs
.. auch ListX müsste ich mal aktivieren.
ok aber neee, R=[1][2,2]...[4...]] geht nicht als Ausgangspunkt
   weil dann statt 4... auch 1-256 stehen kann...
   also bleibt doch nur R=[1][1,1]...[4...]].
.. dann nochmal den ganzen RBIT-Ablauf von QY13 checken.
   .. ich mach mal WEGEBAUM raus
      da geht n=32, inh=51 verhältnismäßig langsam, das dürfte eigentlich nicht sein
      also ALLERANFANGSBIT auch inaktiv machen.
      da ist bei n=32, inh=21 ein Error in WEBEBAUM
      den wollte ich sowieso rausmach-->
      dann fehlt bei n=64, inh=226 auf einmal [32,27] und [32,28]
      wieso das?, Die waren doch schon bei T(32) dabei!!!
      und wieso ist da HRES2=1083 und nicht [...irgendwas...]???
      aha, da wurde halt 32,27] und [32,28] nicht vollständig gespeichert
      das auch bei [32,48] --> extra probieren
      und sogar bei [16,13]
      na und da stimmt was nicht
      das erste [ 1, 1, 8 ] ist [8,3]
      aber das dritte [ 1, 1, 3 ] ist [8,2]
      und kann deshalb unmöglich ZR3MERK=0 zurückliefern
      denn das sollte noch nicht in XSAMMEL drin sein!!!???!!!
      nee doch, [ 1, 1, 3 ] war schon mal weiter oben drin ganz kurz
      nächster Versuch, ich generiere [8,2] und [8,3] extra vorher
OK so, jetzt hab ich mal in QY21MINI die völlig unverständliche Zeile
   #  if ISO=0 then INDEX1:=0; else INDEX1:=ZEIGER[ISO][14]; fi;
   herausgemacht, mal sehen, was da läuft.
   ja, scheint alles zu gehen, nee doch nicht
   die Zeile war schon nötig um über REKURSIV die Wegenummern beizubehaten
   statt dessen hab ich mal mit ZSIZE in QY21MINI die Nummer etwas vereinfacht
   mal sehen wie weit das geht
.. damit nochmal zurück zu "ohne WEGEBAUM"
.. den muss ich mir mal ausgeben und ausgiebig anschauen 
   zusammen mit XSAMMELVIEWER1(XSAMMEL)
.. na gut, morgen mach ich mal WEGEBAUM wieder mit []-Spitzen.
.. wo sind die fehlenden 2 Wege für alle Wege?
   dazu RDRIN mal vorübergehend unwirksam machen
   zuvor aber WEGEBAUM ganz neu fertigmachen auch die Spitzen
   
   
   

Gruppe [ 8, 2 ] jetzt drin 
[ 1, 1, 8 ][ 10001, 10001, 10002, 10001 ] -1 0 
[ 1, 1, 4 ][ 10002, 10002, 10001, 10002 ] 0 -1 .
[ 1, 1, 3 ][ 10002, 10002, 10001, 10002 ] 0 -1 ..

XSAMMEL:=[];#nur anfangs einmal
G:=SmallGroup(64,267);
RMAXSUCH(G);time;Print("\007");


XSAMMEL:=[];#nur anfangs einmal
G:=SmallGroup(32,48);
RMAXSUCH(G);time;Print("\007");
XSAMMELVIEWER1(XSAMMEL);

XSAMMEL:=[];#nur anfangs einmal
G:=SmallGroup(16,13);
RMAXSUCH(G);time;Print("\007");
XSAMMELVIEWER1(XSAMMEL);

XSAMMEL:=[];#nur anfangs einmal
G:=SmallGroup(8,2);
RMAXSUCH(G);time;
G:=SmallGroup(8,3);
RMAXSUCH(G);time;
G:=SmallGroup(8,4);
RMAXSUCH(G);time;
XSAMMELVIEWER1(XSAMMEL);
G:=SmallGroup(16,13);
RMAXSUCH(G);time;Print("\007");
XSAMMELVIEWER1(XSAMMEL);
WEGEZAHL;

1111
1131
1211
1241
1231
1181
1141
1212

1 [ 1 ] 1  #5 2 [ 2, 1 ]<=k1 ##12 1 
  2 [ 1, 1 ] 1  #5 9 [ 4, 2 ]<=k1 ##12 1 
    3 [ 3, 3, 3 ] 1 ==>[ 4, 4, 4 ]3[ 8, 2 ] 
    3 [ 3, 1, 3 ] 2 ==>[ 1, 4, 4 ]6[ 8, 3 ] 
Y    3 [ 4, 4, 4 ] 3  #5 0 [ 8, 2 ]<=k2===>[ 2, 2, 1 ]3[ 8, 2 ] 1 
    3 [ 4, 1, 1 ] 4 ==>[ 1, 4, 4 ]6[ 8, 3 ] 
    3 [ 1, 3, 1 ] 5 ==>[ 1, 4, 4 ]6[ 8, 3 ] 
Y    3 [ 1, 4, 4 ] 6  #5 0 [ 8, 3 ]<=k4===>[ 1, 1, 1 ]1[ 8, 3 ] 4 
    3 [ 1, 1, 2 ] 7 ==>[ 2, 2, 1 ]8[ 8, 3 ] 
Y    3 [ 2, 2, 1 ] 8  #5 0 [ 8, 3 ]<=k2===>[ 1, 1, 1 ]1[ 8, 3 ] 8 
Y    3 [ 2, 2, 2 ] 9  #5 0 [ 8, 2 ]<=k1===>[ 2, 2, 1 ]3[ 8, 2 ] 3 
  2 [ 2, 2 ] 2  #5 4 [ 4, 1 ]<=k1 ##12 2 
X    3 [ 1, 1, 1 ] 1  #5 4 [ 8, 3 ]<=k1 ##12 3 
      4 [ 1, 1, 2, 2 ] 1 ==>[ 2, 2, 2, 2 ]4[ 16, 13 ] 
      4 [ 2, 2, 1, 2 ] 2 ==>[ 2, 2, 2, 2 ]4[ 16, 13 ] 
      4 [ 2, 2, 2, 1 ] 3 ==>[ 2, 2, 2, 2 ]4[ 16, 13 ] 
      4 [ 2, 2, 2, 2 ] 4  #5 0 [ 16, 13 ]<=k4===>[ 2, 2, 1, 1 ]4[ 16, 13 ] 1 
    3 [ 1, 1, 2 ] 2 ==>[ 2, 2, 1 ]3[ 8, 2 ] 
X    3 [ 2, 2, 1 ] 3  #5 4 [ 8, 2 ]<=k2 ##12 1 
      4 [ 1, 1, 1, 2 ] 1 ==>[ 2, 2, 2, 1 ]4[ 16, 13 ] 
      4 [ 1, 1, 2, 1 ] 2 ==>[ 2, 2, 1, 2 ]3[ 16, 13 ] 
Y      4 [ 2, 2, 1, 2 ] 3  #5 0 [ 16, 13 ]<=k2===>[ 2, 2, 1, 1 ]4[ 16, 13 ] 1 
Y      4 [ 2, 2, 2, 1 ] 4  #5 0 [ 16, 13 ]<=k2===>[ 2, 2, 1, 1 ]4[ 16, 13 ] 3 
X    3 [ 2, 2, 2 ] 4  #5 4 [ 8, 4 ]<=k1 ##12 4 
      4 [ 1, 1, 1, 1 ] 1 ==>[ 2, 2, 1, 1 ]4[ 16, 13 ] 
      4 [ 1, 1, 1, 2 ] 2 ==>[ 2, 2, 1, 1 ]4[ 16, 13 ] 
      4 [ 1, 1, 2, 1 ] 3 ==>[ 2, 2, 1, 1 ]4[ 16, 13 ] 
X      4 [ 2, 2, 1, 1 ] 4  #5 0 [ 16, 13 ]<=k4 ##12 1 
1111
1191
1231
1241

.. bei [32,22] sind unterschiedliche WEGEZAHLEN
   dem muss ich nachgehen, da sind wohl doch zwei Durchläufe
   mit gleichem Anfang am Ende unterschiedlich.
.. aber erstmal die neue Wegespitze, so die ist drin
.. trotzdem noch unterschiedliche WEGEZAHLEN
   die muss ich genauestens herausfinden.
   Mit folgender Rechnung:
   
T(16);
G:=SmallGroup(32,33);#gefunden 25..28
RMAXSUCH(G);time;
XSAMMELVIEWER1(XSAMMEL);
WEGEZAHL;
.
[ 1, 2, 10, 1, 1 ][ 1 ] -1 false [ f1, f4, f5, f2, f3 ]|[ f3, f1, f1*f2*f5, f1*f2*f4, f5 ]0 
[ 1, 2, 10, 9, 5 ][ 5 ] -1 false [ f1, f4, f5, f3, f2 ]|[ f2, f1, f3*f4*f5, f3, f4 ]0 
[ 1, 2, 10, 9, 1 ][ 1 ] 0 false [ f1, f4, f5, f2*f3, f3 ]|[ f3, f1, f1*f2*f3*f4, f1*f2*f3*f4*f5, f4 ]0 
[ 1, 2, 10, 9, 1 ][ 1 ] 0 true [ f1, f5, f4, f2, f3 ]|[ f2*f3*f5, f1, f1*f2*f5, f1*f2*f4, f5 ]0 
[ 1, 2, 10, 1, 5 ][ 1 ] 0 false [ f1, f5, f4, f3, f2 ]|[ f1*f2*f3*f5, f1, f3*f4*f5, f3, f4 ]0 

das erste true überspringt das darauffolgende false,
dadurch ein WEGMERKER weniger.
na gut, muss ich erstmal so lassen.
Alle Prints und so zurück und mal weng laufenlassen...

.. neuer Fehler [64,206] da ist HRES2=1126??? Wieso das???
   ok dieser Fehler tritt nicht auf, wenn immer DDDD:=false;
      also muss ich da mal das XMISCH gucken...
   ok dieser Fehler tritt nicht auf, wenn ich nur RMAXSUCH ohne T(32) mach.
   ok dieser Fehler tritt nicht auf, wenn ich RMAXSUCH nach T(16) mach.
   ok dieser Fehler tritt auf, wenn ich RMAXSUCH nach T(32) mach.
      überhaupt, wieso fehlt dann [32,27]???
   also muss ich mal gucken wie XMISCH funktioniert hat.
   .. davor erstmal nur [32,27] vergleichen mit/ohne DDDD
      bei ohne DDDD fehlt ein Teil in XSAMMEL:
      XMERKZAHL=14 ohne DDDD (DDDDBIT=1)
      XMERKZAHL=6 mit DDDD (DDDDBIT=0)
      das ist ne ganze Menge
      nach den unteren Versuchen denke ich,
      dass wohl doch die neuen Wegspitzen nicht funktionieren
      Die alten mache ich aber nicht wieder her, 
      sondern versuche stattdessen ein anderes DDDD
   .. auf mit NEUWEGLAENGE.
      ok geht schon mal
      aber das HRES2=1150 ist immer noch drin
      als letzten Versuch mach ich
      if ZEIGER[j]<>NW then 
      statt if ZEIGER[j]<NW then
      aber da dauert inh=51 wieder ewig
      also hier muss noch eine Lösung her.
      als Behelf habe ich jetzt
          if ZEIGER[j]<NW then 
            DRINBIT:=false;
            fi;
          if ZEIGER[j]>NW+1 then 
            DRINBIT:=false;
            fi;
      reicht aber auch nicht
      XMERKZAHL=10 statt 14
      kann aber nicht so bleiben...
      gut, das reicht für heute

T(32);
T(16);
XSAMMEL:=[];#nur anfangs einmal
G:=SmallGroup(64,206);
RMAXSUCH(G);time;
XSAMMELVIEWER1(XSAMMEL);
WEGEZAHL;

XSAMMEL:=[];#nur anfangs einmal
AUZAHL:=0;DDDDBIT:=0;DBIT:=1;#kurze Variante
G:=SmallGroup(16,14);
RMAXSUCH(G);time;
G:=SmallGroup(16,11);
RMAXSUCH(G);time;
G:=SmallGroup(16,3);
RMAXSUCH(G);time;
G:=SmallGroup(32,27);
RMAXSUCH(G);time;
XMERKZAHL;WEGEZAHL;#14 muss rauskommen und nicht 8
XSAMMEL1:=StructuralCopy(XSAMMEL);;

XSAMMEL:=[];#nur anfangs einmal
AUZAHL:=0;DDDDBIT:=1;DBIT:=1;#ausfuehrliche Variante
G:=SmallGroup(16,14);
RMAXSUCH(G);time;
G:=SmallGroup(16,11);
RMAXSUCH(G);time;
G:=SmallGroup(16,3);
RMAXSUCH(G);time;
G:=SmallGroup(32,27);
RMAXSUCH(G);time;
XMERKZAHL;WEGEZAHL;#14 wie auch bisher schon

XSAMMEL=XSAMMEL1;
XSAMMELVIEWER2(XSAMMEL);
XSAMMELVIEWER3(XSAMMEL1);

#hier suche ich warum # 
XSAMMEL:=[];#nur anfangs einmal
AUZAHL:=0;DDDDBIT:=1;DBIT:=1;#ausfuehrliche Variante
G:=SmallGroup(8,2);
RMAXSUCH(G);time;
G:=SmallGroup(16,4);
RMAXSUCH(G);time;
XMERKZAHL;WEGEZAHL;#14 wie auch bisher schon
XSAMMELVIEWER0(XSAMMEL);

ALLEPCGS:=function(G)
  local i,j,k,l,m,ANZAHL,map,G1,fam,pcgs,ALLEW,ALLEP;
  ANZAHL:=0;fam:=FamilyObj(G.1);
  ALLEW:=[];ALLEP:=[];
  for i in List(G) do if Size(Group(i))=2 then
    for j in List(G) do if Size(Group(i,j))=4 then
      for k in List(G) do if Size(Group(i,j,k))=8 then
        for l in List(G) do if Size(Group(i,j,k,l))=16 then
          for m in List(G) do if Size(Group(i,j,k,l,m))=32 then
          ANZAHL:=ANZAHL+1;
#          map:=GroupGeneralMappingByImages(G,[G.4,G.3,G.2,G.1],[i,j,k,l]);
#          G1:=Image(map);
#          pcgs:=PcgsByPcSequence(fam,[l,k,j,i]);
#          G1:=GroupOfPcgs(pcgs);
#          RMAXSUCH(G1);
          HRESW:=[i,j,k,l,m];
          WEGGUCK(G);
          ALLEW[ANZAHL]:=List(WEGLI);
          ALLEP[ANZAHL]:=[i,j,k,l,m];
          Print ("\n",ANZAHL," ",WEGLI," ",[i,j,k,l,m]);
          fi; od; fi; od; fi; od; fi; od; fi; od;
  return [ALLEW,ALLEP];
  end;
#DDDDBIT:=0;DBIT:=0;ALLEN16G4:=ALLEPCGS(G);Collected(ALLEN16G4[1]);
Collected(ALLEN16G4[1]{[1..448]});
Collected(ALLEN16G4[1]{[449..768]});
Collected(ALLEN16G4[1]{[769..960]});

T(16);G:=SmallGroup(32,27);#da aber HRESW mit i,j,k,l,m
DDDDBIT:=0;DBIT:=0;ALLEN32G27:=ALLEPCGS(G);;Collected(ALLEN32G27[1]);
ALLEZ32G27:=StructuralCopy(ALLEN32G27[1]);;
for i in [1..Size(ALLEN32G27[1])] do Add(ALLEZ32G27[i],ALLEN32G27[2][i][1],1); od;
LogTo("GAP_LOGFILE.txt");
Collected(ALLEZ32G27);
LogTo();
LogTo("GAP_LOGFILE2.txt");
XSAMMELVIEWER0(XSAMMEL);
LogTo();
LogTo("GAP_LOGFILE2.txt");
RMAXSUCH(G);time;
LogTo();

PP:=Positions(ALLEN32G27[1],[]);
ALLEN32G27[2]{PP};



#Ergebnis: 
gap> XSAMMELVIEWER0(XSAMMEL);
(1) 1 [ 1 ] 1 = [ 2, 1 ] 
  (2) 2 [ 1, 1 ] 1 = [ 4, 2 ] 
    (3) 3 [ 3, 3, 3 ] 1 2 [ 8, 2 ] ::::[ 1, 6, 4 ]
    (2) 3 [ 4, 4, 4 ] 2 ===> [ 8, 2 ] ~~~~[ 5, 1, 6 ]
    (1) 3 [ 2, 2, 2 ] 3 ===> [ 8, 2 ] ~~~~[ 3, 1, 4 ]
  (1) 2 [ 2, 2 ] 2 = [ 4, 1 ] 
    (2) 3 [ 1, 1, 2 ] 1 2 [ 8, 2 ] ::::[ 7, 2, 4 ]
    (1) 3 [ 2, 2, 1 ] 2 = [ 8, 2 ] 
      (6) 4 [ 7, 7, 7, 7 ] 1 3 [ 16, 4 ] ::::[ 1, 10, 4, 8 ]
      (4) 4 [ 7, 7, 2, 2 ] 2 6 [ 16, 4 ] ::::[ 13, 10, 4, 8 ]
      (5) 4 [ 8, 8, 8, 8 ] 3 ===> [ 16, 4 ] ~~~~[ 13, 9, 1, 14 ]
      (2) 4 [ 8, 8, 2, 2 ] 4 6 [ 16, 4 ] ::::[ 13, 2, 4, 8 ]
      (3) 4 [ 2, 2, 7, 7 ] 5 6 [ 16, 4 ] ::::[ 1, 10, 4, 8 ]
      (1) 4 [ 2, 2, 8, 8 ] 6 = [ 16, 4 ] 
gap> Collected(ALLEN16G4[1]);
[ [ [ 1, 1, 1, 1 ], 32 ], [ [ 1, 1, 1, 2 ], 32 ], [ [ 1, 1, 1, 3 ], 32 ], 
  [ [ 1, 1, 1, 4 ], 32 ], [ [ 1, 1, 1, 5 ], 32 ], [ [ 1, 1, 1, 6 ], 32 ], 
  [ [ 1, 1, 2, 1 ], 32 ], [ [ 1, 1, 2, 2 ], 32 ], [ [ 1, 1, 2, 3 ], 32 ], 
  [ [ 1, 1, 2, 4 ], 32 ], [ [ 1, 1, 2, 5 ], 32 ], [ [ 1, 1, 2, 6 ], 32 ], 
  [ [ 1, 2, 1, 1 ], 32 ], [ [ 1, 2, 1, 2 ], 32 ], [ [ 1, 2, 1, 3 ], 32 ], 
  [ [ 1, 2, 1, 4 ], 32 ], [ [ 1, 2, 1, 5 ], 32 ], [ [ 1, 2, 1, 6 ], 32 ], 
  [ [ 1, 2, 2, 1 ], 32 ], [ [ 1, 2, 2, 2 ], 32 ], [ [ 1, 2, 2, 3 ], 32 ], 
  [ [ 1, 2, 2, 4 ], 32 ], [ [ 1, 2, 2, 5 ], 32 ], [ [ 1, 2, 2, 6 ], 32 ], 
  [ [ 1, 2, 3, 1 ], 32 ], [ [ 1, 2, 3, 2 ], 32 ], [ [ 1, 2, 3, 3 ], 32 ], 
  [ [ 1, 2, 3, 4 ], 32 ], [ [ 1, 2, 3, 5 ], 32 ], [ [ 1, 2, 3, 6 ], 32 ] ]
gap> Collected(ALLEN16G4[1]{[1..448]});
[ [ [ 1, 1, 1, 1 ], 32 ], [ [ 1, 1, 1, 2 ], 32 ], [ [ 1, 1, 1, 3 ], 32 ], 
  [ [ 1, 1, 1, 4 ], 32 ], [ [ 1, 1, 2, 1 ], 32 ], [ [ 1, 1, 2, 2 ], 32 ], 
  [ [ 1, 1, 2, 3 ], 32 ], [ [ 1, 1, 2, 4 ], 32 ], [ [ 1, 2, 1, 1 ], 32 ], 
  [ [ 1, 2, 1, 2 ], 32 ], [ [ 1, 2, 1, 3 ], 32 ], [ [ 1, 2, 1, 4 ], 32 ], 
  [ [ 1, 2, 2, 5 ], 32 ], [ [ 1, 2, 3, 5 ], 32 ] ]
gap> Collected(ALLEN16G4[1]{[449..768]});
[ [ [ 1, 1, 1, 5 ], 32 ], [ [ 1, 1, 1, 6 ], 32 ], [ [ 1, 1, 2, 5 ], 32 ], 
  [ [ 1, 1, 2, 6 ], 32 ], [ [ 1, 2, 1, 5 ], 32 ], [ [ 1, 2, 1, 6 ], 32 ], 
  [ [ 1, 2, 2, 1 ], 32 ], [ [ 1, 2, 2, 2 ], 32 ], [ [ 1, 2, 3, 1 ], 32 ], 
  [ [ 1, 2, 3, 2 ], 32 ] ]
gap> Collected(ALLEN16G4[1]{[769..960]});
[ [ [ 1, 2, 2, 3 ], 32 ], [ [ 1, 2, 2, 4 ], 32 ], [ [ 1, 2, 2, 6 ], 32 ], 
  [ [ 1, 2, 3, 3 ], 32 ], [ [ 1, 2, 3, 4 ], 32 ], [ [ 1, 2, 3, 6 ], 32 ] ]
ok PGCSZ=WZ*AUZ;
.. ich muss die WEGELISTE auch mit den  


#####################
nö neuer Ansatz: ich trage die Restweglänge erst nach kompletten 
   Durchlaufen der Teilstruktur in den Wegebaum ein. Ist eine kleine Hoffnung
   nee geht wohl auch nicht, damit bekomme ich nicht die folgende 2[....18,1] hin
   aber mit dieser Liste erhalte ich eine neue Idee:
nö also gut, mit dem jetzigen WEGMERKER sind zwei 
   definitiv verschiedene Teilstrukturen
   nicht mehr Wegedisjunkt. Das war vorher mal anders. 
   Deshalb WEGMERKER wieder zurück auf die Elementnummern
   und in die Wegspitze das PNEU rein.
   Konkret sind im obigen [32,27] folgende gleich, 
   welche eigentlich verschieden sein müssten
nö nö dazu kann ich erstmal die Wegspitze generell nullsetzen nö
ok als erstes in Q15 wieder aufwärts Zählen
nö dann die Restweglänge deaktivieren nö bleibt für Print
   Schwupp und da hab ich wieder meine XMERKZAHL=14 bei DDDDBIT=0
ok !!das erste RMAX[S]:=Size(ZR[2])+1 muss aber noch korrigiert werden
   !!! ja das muss ich machen, ich versuche QY12 vor QY10NEU zu bringen
ok mit altem WEGMERK (Size+i) von 8 auf 0,5h !!! -->Speichern!!!
ok ist gut geworden heute das alles. Fin.

2[ 1, 1, 1, 18, 1 ][ 1 ] 0 false [ f1, f4, f5, f2, f3 ]|HRES 0 
2[ 1, 1, 1, 18, 1 ][ 1 ] 0 true  [ f2, f4, f5, f1, f3 ]|HRES 0 

2[ 1, 1, 2, 1, 1 ][ 1 ] 0 false [ f1*f5, f4*f5, f2*f3*f5, f5, f3 ]|HRES 0 .
3[ 1, 1, 2, 1, 1 ][ 1 ] 0 false [ f2*f3, f4*f5, f1, f5, f3 ]|HRES 0 

2[ 1, 1, 1, 22, 3 ][ 1 ] 0 false [ f1, f4, f5, f2, f3 ]|HRES 0 
2[ 1, 1, 1, 22, 7 ][ 1 ] 0 false [ f2, f4, f5, f1, f3 ]|HRES 0 
2[ 1, 1, 4, 2, 1 ][ 1 ] 0 true   [ f1*f5, f4*f5, f2*f3*f5, f5, f3 ]|HRES 0 .
3[ 1, 1, 4, 2, 5 ][ 1 ] 0 true   [ f2*f3, f4*f5, f1, f5, f3 ]|HRES 0 

ok die Umstellung QY12 vor QY21MINI.
.. offensichtlich sind in einem true-Block noch einzelne false drin
   jedoch keine neuen *****, also könnte ich WEGMERKER
   noch ein wenig allgemeiner machen. hier:

4[ 1, 1, 1, 1, 285 ][ 1 ] 0 true  [ f3, f2, f4, f5, f1 ]|HRES 0 
2[ 1, 1, 1, 1, 157 ][ 1 ] 0 false [ f3, f2, f4*f5, f5, f1 ]|HRES 0 
3[ 1, 1, 1, 1, 509 ][ 1 ] 0 false [ f3, f4*f5, f2, f5, f1 ]|HRES 0 
2[ 1, 1, 1, 8, 5 ]  [ 1 ] 0 false [ f3, f4*f5, f5, f1, f2 ]|HRES 0 
1[ 1, 1, 1, 1, 633 ][ 1 ] 0 false [ f3, f4*f5, f5, f2, f1 ]|HRES 0 
1[ 1, 1, 1, 60, 3 ] [ 1 ] 0 false [ f3, f4*f5, f5, f1*f2*f4, f2 ]|HRES 0 

nö auch mal 3 und 4 nach 256 einsortieren? nö, bringt trotzdem die 15 16
.. zu diesem Zweck Bilden einer Gruppe entlang eines vorgegebenen Weges
   ok als Anfang WEGEDISP(WEG)
   .. weiter: neueste Idee, ich mache in jedem Schritt S ein Pcgs
      und dann die beiden phi Phi Transformationen
      und dann das nächste R[S] hinzu und damit aich Pcgs und phi Phi
      und so weiter. Ja, das sieht gut aus.
   vv außerdem kann ich als Behelf folgendes versuchen:
      ich gehe davon aus, dass zwar unterschiedliche Teilstrukturen 
      in jedem Fall disjunkt sind, aber gleiche Teilstrukturen
      auch unterschiedliche Wege enthalten. Wenn der erste Weg
      noch nicht enthalten ist, aber der zweite oder dritte,
      dann kann ich die Durchsuchung der Teilstruktur abbrechen.
      Damit entfällt ERSTBIT und bin wieder bei einer urzeitlichen Version.
      Allerdings wenn erst der dritte Weg enthalten ist, so kann dieser
      der erste Weg der aktuellen Teilstruktur gewesen sein,
      und das muss ich jetzt irgendwie ausschließen, möglcherweise mit NM.
   .. für eine endgültige Lösung:
      das WEGLI entspricht nur auf direktem Weg einem kompletten XMERK
      Teilstrukturen sind daher komplett unterschiedlich oder komplett gleich
      wenn alle XMERK unverändert in XSAMMEL gespeichert werden. 
      Wenn aber Umwege reinkommen, so könnten zwei origional unterschiedliche XMERK
      in ein einziges XMERK vom komprimierten XSAMMEL münden. Das hatte ich schon mal
      und jetzt besteht die Aussicht, das endgültig zu packen.
.. die große PositionFirstComponentRepariert-Zeit tritt markant bei [n=64,202] auf
ok also denn mal los, rein mit der 4533R
   ok zuerst WEGEZAHL in die Wegspitze rein 
      ok es muss RBIT[2]<=S heißen, nicht =
      ....hier muss noch Ergänzung rein....
      ansonsten funktioniert es bis jetzt bestens!!!
      ok Erstbit raus? ja, auch NEUWEGLAENGE und ALLERANFANGSBIT
      erstaunlich, dass ohne ALLERANFANGSBIT alles automatisch funktioniert 
      nee, doch nicht, das ALLERANFANGSBIT muss wieder rein.
      und zwar jetzt einfach als if WEGEZAHL=0
      außerdem in QY07NEU jetzt DRINBIT raus. 
      Jetzt wird wieder Platz!!!
      zeitlich ist anscheinend kein großer Unterschied,
      ZR3MERK geht fast raus, nur noch wegen Print("*****");
      DDDD ist raus, QY07NEU nur noch einmal
      QY07NEU in QY07, das ist jetzt die Zeit für. Q21MINI in QY21 auch
      QY10A in QY10, QY11A in QY11
      huuu in QY07 muss WEGEARRAY[WEGEZAHL]:=S+1; rein statt nur S;
      das war nochmal wichtig, alles auf screen ummach 
      und nochmal das richtige R=444444442 starten
      dann Feierabend! 
      
ok PARTFIND(XSAMMEL,PART) ist da.
   ok nur stimmt nicht???? Doch, ist ok. hat aber wieder gedauert.
   
T(64);
R:=[[1],[1,1],[2,2,2],[4,4,4,2],[3,3,3,2,1],[2,2,2,4,4,1]];
G:=PcgsOfR(R);IdSmallGroup(G);RMAXSUCH(G);XMERKZAHL;WEGEZAHL;
PART:=WEGEDISP(WEGLI,XSAMMEL,1);;
RMAX:=[];PARTFIND(XSAMMEL,PART);RMAX;#IdSmallGroup(G);

^^^^^^^^ RMAX tatsächlich finden ^^^^^^^^
XMERKZAHLZIEL:=11;
XMERKZAHLZIEL:=99999;
XSAMMEL:=[];
RMAXSUCH(SmallGroup(128,2300));XMERKZAHL;WEGEZAHL;
#11 32949
#11 75

^^^^^^^^ XMERKZAHLZIEL ^^^^^^^^

.. jetzt muss ich noch die Isomorphieprüfung ohne reinspeichern machen


ok kann WEGEBAUM etwa auch wieder raus? 
   Das müsste doch mit in XSAMMEL untergebracht werden können.
   Wenn das so wäre, das wäre die Wucht! Nee doch nicht. 
   Wenn sich zwei Wege trennen und dann wieder zusammenführen,
   und dann sich wieder trennen, wenn schon drei dieser vier Wege gegangen sind,
   kann man dann noch erkennen, dass er noch nicht gegangen war? 
   Vom ersten Eindruck her nicht, aber wenn dabei diese Aufspaltung
   in erscheinung tritt und dafür sorgt, dass der vierte 
   tatsächlich noch nicht gegangen wurde? 
   Na zumindestens kann ich das mal nachträglich mitlaufen lassen,
   ok ob sich soetwas ergibt. z,B: wenigstens WEGEZAHL<ZEILENZAHL(XSAMMELVIEW1)
      ja, WEGEZAHL=23112>>>PARTZAHL=1908 
      
[ 1 ]1-->[ 1 ]==>[ 1 ]
[ 1, 1 ]1-->[ 1, 1 ]==>[ 1, 1 ]
[ 1, 3, 1 ]4-->[ 1, 4, 4 ]==>[ 1, 1, 1 ]
[ 1, 1, 2, 1 ]2-->[ 2, 2, 1, 1 ]==>[ 1, 1, 1, 1 ]
[ 1, 1, 8, 8, 1 ]1-->[ 1, 1, 8, 8, 1 ]==>[ 1, 1, 8, 8, 1 ]

Beispiel:
T(16);
R:=[[1],[1,1],[2,2,2],[4,4,4,3]];
G:=PcgsOfR(R);
RMAXSUCH(G);IdSmallGroup(G);
XSAMMELVIEWER2(XSAMMEL);
IdSmallGroup(G);
WEGLI;
WEGEDISP(WEGLI,XSAMMEL,1);#ergibt: R:=[[1],[2,2],[2,2,1],[8,8,7,7]];
^^^^ RMAX auslesen ^^^^


.. gesucht ist jetzt die umgekehrte Richtung von WEGLI zu R.
nö und eine Isomorphie-Abfrage, ohne das Speichern auszulösen. nö


vvvv neu Conjugacy(HRES); vvvv
vv mal probieren! na sowas: 
   Print(ISNOTCON,RBIT," "); liefert
false6 true0 false6 true0 false6 true0 true0 false4 true0 true0 true0 false
3 true0 true0 true0 false6 true0 true0 false6 true0 false6 true0 false6 true
0 true0 false4 true0 true0 true0 false3 true0 true0 true0 false3 true0 true
0 true0 false3 true0 true0 true0 false3 true0 true0 true0 .false3 true0 true0 tru
nö ConjugacyClasses gehen nicht, weil bei inh=14 alle Elemente
   nicht konjugiert sind, aber nur 1 durchlaufen werden muss
vv das ist was anderes, bloß was, irgendwie nicht isomorphierbar?
vv also mal so ein Beispiel raussuchen lassen.
   das sieht aber ganz so danach aus wie wenn phi wieder rein muss
vv probieren mal, jo, überall kleines phi geht nicht bei G=[64,203]
   da ist nix zu machen, G.1 und G.3 sind nicht G.1^a=G.3. 
   Damit entfällt entgültig der Versuch, G.3 wegzulassen
[ 1, 2, 10, 50, 57, 1 ] -1 7 [ f1, f4, f5, f2, f6, f3 ]false***************
[ 1, 2, 10, 92, 1146, 1 ] 0 7 [ f1, f4, f5, f6, f2, f3 ]false
[ 1, 2, 10, 92, 1082, 17 ] -1 7 [ f1, f4, f5, f6, f3, f2 ]false***************
.
[ 1, 2, 10, 43, 169, 1 ] -1 7 [ f3, f4, f5, f2, f6, f1 ]false***************
[ 1, 2, 10, 92, 1082, 17 ] 0 2 [ f3, f4, f5, f6, f1, f2 ]true.
was eigentlich war:
[ 1, 2, 10, 57, 58, 10 ] -1 7 [ f1, f4, f5, f2, f6, f3 ]false***************
[ 1, 2, 10, 92, 1563, 14 ] 0 7 [ f1, f4, f5, f6, f2, f3 ]false
[ 1, 2, 10, 92, 1500, 42 ] -1 7 [ f1, f4, f5, f6, f3, f2 ]false***************
.
[ 1, 2, 10, 46, 170, 13 ] -1 7 [ f3, f4, f5, f2, f6, f1 ]false***************
[ 1, 2, 10, 92, 1500, 46 ] 0 7 [ f3, f4, f5, f6, f1, f2 ]false
vv aber jetzt mach ich mal in die Wegspitze neu INDEX2
   noooo, [64,203] geht jetzt!!!!->speichern
ok doch auch die geht nicht, weil dann G.3 einen glöeichen Weg enthält wie G.1

ok ALSO INDEX2 geht definitiv nicht in keiner Variante. ok Schluss damit

DDDDBIT:=0;DBIT:=0;#ausfuehrliche Variante
T(32);
DDDDBIT:=0;DBIT:=1;#ausfuehrliche Variante
G:=SmallGroup(64,203);
RMAXSUCH(G);time;
XMERKZAHL;#20

DDDDBIT:=0;DBIT:=0;#ausfuehrliche Variante
T(32);
DDDDBIT:=1;DBIT:=1;#ausfuehrliche Variante
G:=SmallGroup(64,203);
RMAXSUCH(G);time;
XMERKZAHL;
^^^^ neu Conjugacy(HRES); ^^^^^
vv demnächst versuch ich aber mal rauszubekommen, ob da wo kein *****
   auftritt, isodings vorliegt. bzw. probiere es aus. Fini
   nachfolgendes Orbits(A,RC,OnPoints) logischerweise ging nicht,
   versuche es nochmal auf nur S=1: ja das scheint es zu sein <A/>
ok und für S>1 habe ich inzwischen auch eine Idee; Statt A nur St(A,Gr)
   versuche das in <B/> Jo, dass ist es, jedoch schneckenlangsam.
   Also rein mit AUZAHL=0 -->speich
ok in der gemischten Version könnte ich auf dem Anfangs S
   einen neuen WEGEBAUM beginnen. Das könnte ich aber auch bei AUZAHL=0!
   Das ist im Prinzip schon das WEGEARRAY zurückschreiben.
   ja, das wäre zu überlegen. Bräuchte wohl nur WEGEMAUM umdrehen.
   Aber erstmal aus.
vv So. Nun hat R=4444444XX wieder nicht ausreichend Speicher, 
   daher versuche ich doch mal AUZAHL>2 oder sowas. 
   Es müsste reichen, dass bei S=AUZAHL+1 WEGEBAUM gelöscht wird am Anfang QY13
   ok das geht prima, verringert aber die Zeit von 200 auf unter 100 und WEGEZAHL auf 1/100.
   Ich schau mal, wo der Speicher nicht reicht, muss in XMISCH sein oder so.
   Außerdem auch mal die phi=[1,1,0,0,1] in einem Separatvektor speichern.
ok hab jetzt IZUN und NUZI <C/> mit drin, mal schauen, ob der Speicher jetzt reicht.
ok alles klar, inh=444444444 erzeugt einen so langen Vektor!!!! das geht so natüröich nicht!
ok bin jetzt nach 30 min schon bei inh=4442 und 2,2% also so kann es laufen
ok läuft los, hab dann noch paar Prints zurückgestellt und - aus.

<A>
G:=SmallGroup(64,203);
A:=AutomorphismGroup(G);
HRES:=[G.1];
GR:=Group(HRES);
RC:=RightTransversal(G,GR);Size(RC);List(RC);
OR:=Orbits(A,List(RC),OnPoints);Size(ORB);
ORB:=List(OR,i->Representative(i)); 
</A>

<B>
G:=SmallGroup(64,203);
A:=AutomorphismGroup(G);
HRES:=[G.1];
GR:=Group(HRES);
ri:=G.2;
S:=Stabilizer(A,Set(GR),OnSets);
RC:=RightTransversal(G,GR);Size(RC);List(RC);
OR:=Orbits(A,List(RC),OnPoints);Size(ORB);
ORB:=List(OR,i->Representative(i)); 
</B>

<C>
IZUN:=function(L) return Iterated(L,function(a,b) return a+a+b; end); end;
NZUI:=function(n,S) return CoefficientsQadic(1024+n,2){[1..S]}; end;
CoefficientsQadic(23,2);
Iterated([1,1,1,1,1],function(a,b) return a+a+b; end);
</C>

#Read("GAP/PCLASS2/XSAMMEL.txt");#Rek.4432 den IV-Graph
#T(8);
#AUZAHL:=4;GANZLOS();#6 min für alle n=256 /
#AUZAHL:=5;GANZLOS();#11 min/
#AUZAHL:=6;GANZLOS();#29 min/
#AUZAHL:=99;GANZLOS();# min

^^^^ neu Orbits(AU,RC); ^^^^
vv rumms, wieder Error bei XMISCH, wei HRES2 keine Liste
   MERKE: tritt vermutlich auf, wenn schon eine Gruppe mit Nr. inh drin ist
nö muss ich wenigstens überbrücken... nö habs unten
ok wie in aller Welt kommt 56092 in das [512,56092] hinein???
   ok so ich glaub ich hab was gefunden: ok auch mit aber nicht alles
      XFUELL darf nicht über das aktuelle n hinaus rekursiv aufgerufen werden.
      vermutlich war das schon mal drin und ich habs wieder raus
      weil es anscheindend aussieht wie immer <=n.
   ok die erste Hürde Print() am Anfang von inh=4444 ist geschafft
   vv gut, läuft jetzt, erstmal aus.
.. doch neues XFUELL reicht noch nicht, immer noch verkehrt!!! Na sowas!
ok ok ok ok ich habs!!! inh war local in GANZLOS, alles klar.
^^^^ XMISCH-Fehler ^^^
ok statt 2^..<n in XFUELL sollte auch else gehen
o. RMERKER muss kein Vektor mehr sein.
o. auch AUZAHL=5 probieren.
nö RC doch nochmal komplette Nebenklassen versuchen, ob dann gleich Ende bei XMERKZALZIEL
.. auch die WEGEZAHL bei AUZAHL=99 gucken. Da sollte doch XMERKZAHL rauskommen?
.. dann nochmal ohne XMERKZAHLZIEL versuchen, es ist wieder Leerlauf drin, wie das?
.. wie war gleich die Folge 1,5,28,212???
.. Zusammenhang vollständige WEGEZAHL und Size(A).


vvvv ALLEWAEGEZAEHLER vvvv
ALLEWEGEZAEHLER:=function(ZEIGER,ZIEL)
  local PART,ZEIG;
  for PART in ZEIGER do
#    Print("\n",UMKEHRLIST(PART[1]),PART[14]);
    ZEIG:=PART;
    if IsBound(ZEIG[5]) then ZEIG:=ZEIG[5]; fi;
#    Print("-->",UMKEHRLIST(ZEIG[1]));
    if IsBound(ZEIG[12]) then ZEIG:=ZEIG[12]; fi;
#    Print("==>",UMKEHRLIST(ZEIG[1]));
    if IsBound(ZEIG[6]) then ALLEWEGEZAEHLER(ZEIG[6],ZIEL); fi;
    if ZEIG[7]=ZIEL then ALLEWEGEZAHL:=ALLEWEGEZAHL+1; fi;
    od;
  end;
#ALLEWEGEZAHL:=0;ALLEWEGEZAEHLER(XSAMMEL,[32,27]);ALLEWEGEZAHL;
#ALLEWEGEZAHL:=0;ALLEWEGEZAEHLER(XSAMMEL,[8,4]);ALLEWEGEZAHL;
#ALLEWEGEZAHL:=0;ALLEWEGEZAEHLER(XSAMMEL,[16,4]);ALLEWEGEZAHL;
^^^^ ALLEWAEGEZAEHLER ^^^^

#XSAMMEL:=[];#nur anfangs einmal
ClearProfile();
IS2:=[1,2];
IS4:=[1,2,3,4];
for i1 in IS2 do i2:=i1;
  for i2 in IS2 do
    for i3 in IS4 do
    for i4 in IS4 do
    for i5 in IS4 do
            Print("\n",i1," ",i2," ",i3," ",i4," ",i5);
            R:=[[1],[i1,i2],[i3,i4,i5]];
#            G1:=AsGroup(MagmaByMultiplicationTable(MatrixOf(R)));
              G:=PcgsOfR(R);
            if G<>fail then 
              Print(IdSmallGroup(G),"\c");RMAXSUCH(G);Print(WEGLI);
              fi;
      od;
      od;
      od;
    od;
  od;
     
.. neues von 4444: 4222 fehlt auch noch und 
.. Gruppe [ 128, 2163 ] die dauert ewig
.. Gruppe [ 64, 202 ] die dauert ewig


########
so, hier habe ich verdingst wegen dem i[2] in XMISCH. Alles weg von heut
.. da war das CosetDecomposition,
o. das Auprodukt ausrechnen, hat schon tüchtig gestimmt
.. diverse Testausgaben mit **** ####
.. das Aufg

vvvv inh=4222 vvvv
XSAMMEL:=[];AUZAHL:=4;HRESEXT:=[];
RMAXSUCH(SmallGroup(256,55975));XMERKZAHL;WEGEZAHL
ist durch!!! in 1,7% und 18 min. Gleich weiter mit
#inh:=4222;R:=[[1],[1,1],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2],[4,4,4,4,4,4,2,2,2]];G:=PcgsOfR(R);RMAXSUCH(G);
jetzt dauert [ 128, 2163 ] in [ 256, 55751 ] bei QY15 Size(Zeiger)=300000...
und 99% massiv PositionFirstComponentRepariert
jetzt darüber hinweg, schade, läuft auf [2,2,2,2,1,256,256,256,256]
jetzt kann ich nur noch hoffen, dass das auch als [256,256,256,256,1,256,256,255 geht
ja, ist was passendes dabei:[ 256, 256, 256, 256, 256, 2, 2, 2, 1 ]

.. so, jetzt aber richtig: bei [16,4] ist XMERKZAHL1=XMERKZAHL
   da mach ich erneut die CosetDecomposition rein.
   und da tritt wieder XMERKZAHL1=XMERKZAHL auf.
.. das muss ich rausbekommen, was das ist. Das ist bei der [16,4] zuerst,
.. kann auch bei größerem S leer durchlaufen, also ein XMERKBIT:=-1; rein bei SMAX 
   aber trotzdem anhalt. Also muss ich [16,4] gucken.
.. versuch mal Orbits HRES+ri, nee ertmal könnte es so sein
   dass dieser Weg erst bei n=32 wirksam wird und dort zu neuen Wegen führt.

XSAMMEL:=[];AUZAHL:=4;HRESEXT:=[];
RMAXSUCH(SmallGroup(16,4));XMERKZAHL;WEGEZAHL;
XSAMMELVIEWER0(XSAMMEL);

.. bei dem XMISCH muss ich RMAXSUCHREKURSIV mit berücksichtigen
.. auch nochmal Aprodukt gucken bei mit/ohne CosetDecomposition
ok dazu FAKT mit rein, ok ist drin ok
huuuu, das war eine extra Aktion heut! Mach ich morgen normal weiter, gute Nacht

XSAMMEL:=[];AUZAHL:=9999;HRESEXT:=[];DBIT:=1;DDDDBIT:=1;
G:=SmallGroup(8,4);
RMAXSUCH(SmallGroup(4,1));
RMAXSUCH(SmallGroup(4,2));
RMAXSUCH(G);
XSAMMELVIEWER0(XSAMMEL);
A:=AutomorphismGroup(G);
Size(A);168/Size(A);


vvvv die untersten n=256 Abzweige vvvv
#jetzt auch für 512
#ILIST:=[55626..56058];
#ILIST:=[10493062..10494173];
for inha in ILIST do
  Print(".\c");
#  G:=SmallGroup(256,inha);
  G:=SmallGroup(512,inha);
#C:=ConjugacyClassesSubgroups(G);
#C:=ConjugacyClassesMaximalSubgroups(G);
  C:=MaximalSubgroupClassReps(G);
  L:=List(C,i->IdSmallGroup(i));
#  if [128,2325] in L then Print(inha); fi;
  if [256,56089] in L then Print(inha); fi;
  od;
#JLIST:=[10493080,10493262,10493263,10493272,10493292,10493293,10493302];#ab [256,56089]


R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,1]];
M:=PcgsOfR(R);
IdSmallGroup(M);
R:=[[1],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[2,2,2,2,2,2,2,2]];
M:=PcgsOfR(R);
IdSmallGroup(M);

Ergebnis:
XSAMMEL:=[];
ILIST:=[55639,55642,55799,55800,55840,55841,55847,55975,55976,55990,55991];
Size(ILIST);
for inha in ILIST do
  Print("\n",inha);
  G:=SmallGroup(256,inha);
  RMAXSUCH(G);
  od;
XSAMMELVIEWER4(XSAMMEL);

vvvv das große XSAMMEL weiter vvvv
.. das else XFUELL in XFUELL passt auch noch nicht so richtig.
   Es sollte verhindern, dass bei Ergänzung kleinerer Gruppen 
   weiter XSAMMEL aufgerufen wird. Funktionieren tut es aber...
ok das Workspace laden natürlich mit gap -L und nicht LoadWorkspace()!!!
ok das reparieren des wegen inh=0 abgebrochenen XSAMMEL scheint zu gehen:
ok XSAMMELVIEWER4 jetzt mit LETZTERABZWEIG

   gap.sh -L GAP_WORKSPACE_4222
   inh:=4222;
   XFUELL(XSAMMEL);
   RMERKER:=[];XMISCH(XSAMMEL,[],1);
   XLEER(XSAMMEL);
   
ok ist durch bis 111111111 !!!!! 9 Stück sind es geworden,
   nicht ganz das Erwartete, aber geschafft!!!!
                 9 [ 256, 256, 256, 256, 256, 256, 256, 256, 255 ] 128 [5462] 0 [ 512, 4444 ]
                 9 [ 2, 2, 2, 2, 1, 256, 256, 255, 255 ] 64 [16277] 0 [ 512, 5048 ]
                 9 [ 2, 2, 2, 2, 1, 256, 256, 256, 256 ] 64 [16278] 0 [ 512, 4222 ]
                 9 [ 2, 2, 2, 2, 2, 256, 256, 256, 255 ] 128 [16342] 0 [ 512, 5107 ]
                 9 [ 2, 2, 2, 2, 2, 1, 1, 256, 255 ] 64 [16362] 0 [ 512, 4431 ]
                 9 [ 2, 2, 2, 2, 2, 2, 1, 256, 256 ] 128 [16378] 0 [ 512, 4442 ]
                 9 [ 2, 2, 2, 2, 2, 2, 1, 1, 1 ] 64 [16379] 0 [ 512, 15928 ]
                 9 [ 2, 2, 2, 2, 2, 2, 2, 256, 255 ] 64 [16382] 0 [ 512, 4432 ]
                 9 [ 2, 2, 2, 2, 2, 2, 2, 2, 1 ] 64 [16384] 0 [ 512, 15923 ]

.. wenn drin, muss gar nicht XFUELL, XMISCH und XLEER durch.
^^^^ das große XSAMMEL fertig ^^^^


vvvv ein WEGFINDER aus HRES zu WEGLI vvvv
QY13MOD:=function(C,S,nn,ZEIGER,AU)
  local i,j,ri,RC,PNEU,GR,HRESMERK,RDRIN,HRES0MERK,ZR,RBIT,ZR3MERK,rj,
  orbi,ORB,STAB;
  RBIT:=0;RDRIN:=0;STAB:=0;
  if HRES<>[] then GR:=Group(HRES); else GR:=Group(Identity(C)); fi;
  if S=AUZAHL+1 then WEGEBAUM:=[]; fi;
  for ri in [HRESW[S]] do if 1=1 then 
    Add(HRES,ri,1);HRESEXT[S]:=ri;
    if QY10(HRES,S,GR) then
if S=1 then XMERKZAHL1:=XMERKZAHL; WEGEZAHL1:=WEGEZAHL; XMERKBIT:=0; fi;
#FAKT[S]:=Size(ORB[Position(RC,rj)]);
      PNEU:=QY11(HRES,S);
      R[S]:=List(PNEU);
      HRESMERK:=List(HRES);
      ZR:=QY21(HRES,S,nn,ZEIGER,PNEU);
      HRES:=List(ZR[1]);WEGLI[S]:=ZR[5];ZR3MERK:=ZR[3];
      if 2*nn<n then 
        RBIT:=QY13MOD(C,S+1,2*nn,ZR[2],STAB); 
        else 
          if ZR3MERK<>0 then #RDRIN=0
            HRES0MERK:=List(HRES0);
            HRES0:=List(HRES);
            CLIST:=[Identity(C)];
            for i in Reversed(HRES0) do
              for j in [1..Size(CLIST)] do
                Add(CLIST,i*CLIST[j]);
                od; od;
            XMERK:=[];FIXBIT:=0;HRES:=[];STEP:=1;
            QY12(C,1,1);
            QY14();
            QY15(ZR[2],XMERK[S]);
            XMERKZAHL:=XMERKZAHL+1;
            ZR:=QY21(HRES0,S,nn,ZEIGER,PNEU);
            WEGLI[S]:=ZR[5];
            HRES0:=HRES0MERK;
            Print("*\c");
            fi;
          if ZR3MERK=0 and WEGEZAHL=0 then RBIT:=0; else
            RBIT:=QY07(WEGEBAUM,WEGLI{[1..S]},S); fi;
          if DBIT=1 then
            Print("\n",WEGLI{[1..S]}," ",ZR3MERK," ",RBIT," ",HRESEXT{[1..S]},RBIT<=S," ");
            if ZR3MERK=-1 then Print("DONNERWETTER "); fi;
            fi;
          if XMERKZAHL=XMERKZAHLZIEL then RBIT:=0; fi;#besser kein RMAXSUCHREKURSIV!!!
          if DDDDBIT=1 then RBIT:=999999; fi;
          XMERKBIT:=-1;
#          Print("\n^^^^",WEGLI," ",FAKT{[1..S]}," ",Size(STAB)," \c");
          fi; #(if 2*nn<n) 
      if RBIT<=S then RDRIN:=-1; fi;
      HRES:=List(HRESMERK);
#+++++++++
      if S=1 then 
        if XMERKZAHL1=XMERKZAHL and XMERKBIT=-1 then #and WEGEZAHL1<WEGEZAHL then
          Print("#");
#          Error("hier aber da"); 
          fi;
        fi;
#---------
      fi; #(if QY10(HRES,S,GR))
    Remove(HRES,1);
    fi; od; #(for ri in RC do if ri<>RC[1] and RDRIN>-1)
  i:=WEGEZAHL;while i>0 and S<WEGEARRAY[i] do WEGEARRAY[i]:=S; i:=i-1; od;
  return RBIT;
  end;

WEGGUCK:=function(C)#aus RMAXSUCH abgeleitet
  local AU;
  n:=Size(C);AU:=AutomorphismGroup(C);
  XMERK:=[];HRES:=[];STEP:=1;R:=[];WEGLI:=[];FAKT:=[];
  #  XSAMMEL:=[];
  XMERKZAHL:=0;WEGEBAUM:=[];WEGEZAHL:=0;
  WEGEARRAY:=[];
  QY13MOD(C,1,1,XSAMMEL,AU);
  end;
#HRESW:=[G.4,G.3,G.2,G.1];WEGGUCK(G);WEGLI;
#HRESW:=[G.3,G.4,G.1,G.2];WEGGUCK(G);WEGLI;
^^^^^ WEGFINDER aus HRES das WEGLI ^^^^^
ok na ok, hat ein brauchbares Ergebnis. fini bei WEGEZAHL*32=A




##############################################
also gänzlich neu: jetzt ohne WEGEBAUM:
#W#
#aktueller Testablauf ist:
VORLETZT:=1;
XSAMMEL:=[];#nur anfangs einmal
AUZAHL:=0;DDDDBIT:=0;DBIT:=1;#kurze Variante
G:=SmallGroup(16,14);
RMAXSUCH(G);#time;
G:=SmallGroup(16,11);
RMAXSUCH(G);#time;
G:=SmallGroup(16,3);
RMAXSUCH(G);#time;
XSAMMEL1:=StructuralCopy(XSAMMEL);;
G:=SmallGroup(32,27);
RMAXSUCH(G);#time;
XSAMMELFERTIG:=StructuralCopy(XSAMMEL);;
VORLETZT:=0;

AKTUELLERTEST:=function(AU,DDDD)
  XSAMMEL:=StructuralCopy(XSAMMEL1);;
  AUZAHL:=AU;DDDDBIT:=DDDD;DBIT:=1;
  G:=SmallGroup(32,27);
  RMAXSUCH(G);#time;
  #XMERKZAHL;WEGEZAHL;#14 muss rauskommen und nicht 8
  end;
SaveWorkspace("GAPOHNEWEGEBAUM");

AKTUELLERTEST(0);#bei true erfolgt return
Pager(AKTUELLERTEST(1));#ausfuehrliche Variante mit allen true's


#### hier nun los:
ok zuerst muss ich mal phi^-1 wieder mit reinmachen, ok ist drin
ok als nächstes gebe ich zu Beginn jedes neuen Teilwegebaumes ein ???? aus
ok wenn das paarmal zuviel ist - macht nix, das fällt dann raus wenn phi^-1phi funktioniert
ok dann dieses erste WEGLI nach ????? in eine neue Wegeliste aufheb...: NEUEWEGELISTE
ok falls nicht schon phiy^-1(phi(x)) = x ist. Jetzt wird es langsam mit drinkniffelig.
.. diese NEUEWEGELISTE tu ich erstmal separat auswerten... mit einem SEPARATOR
   .. darin enthalten der angestrebte WEGEVERGLEICHER
      .. dazu gleich das betreffende pcgs hinzu, das ist ja schon in Print dabei.
      .. dann local und los mit I=1..S
      .. dann Komplikation wegen [14] wie schon in WEGEDISP
      ok die erste Hälfte von WEGEVERGLEICHER scheint geschafft, da hat QY21 geholfen
      ok jetzt rückzu mit WEG2...das ist sogar noch schwerer weil 
      der müsste dann sogar unabhängig von pcgs funktionieren...
      .. Vergleich 1-3 geht nicht, kleiner Hoffnungsschimmer: 
         könnte daran liegen, dass f4*f5 erst im zweiten Schritt als zu f5 gehörig erkannt wird.
+++++
ok so Schluss Aus, das hatte noch nicht richtig getroffen, dafür jetzt aber die LETZTEWEGELISTE:
.. WEGEVERGLEICHER ist gut, der wird zum Glück auch dafür mit gebraucht und geht noch besser ohne f
.. und jetzt gehe ich so vor:
  ok das erste pcgs kommt in die LETZTEWEGELISTE, ok auch gleich komplett alle anderen mit, rückwärts.
  .. jedes nächstfolgende pcgs vergleiche ich mit dem letzten pcgs aus LETZTEẂEGELISTE
     .. wenn übereinstimmung in den ersten k Elementen besteht, dann 
        .. vergleiche ich über WEGEVERGLEICHER das neue pcgs 
           mit allen pcgs aus NEUEWEGELISTE 
           für die die ersten k Elemente übereistimmen.
           das kann vom Ende NEUEWEGELISTE aus geschehen
           bis erstmalig nicht mehr k Anfangselemente übereinstimmen.
          .. wenn wenigstens einmal phi-Gleichheit auftritt, 
             dann passendes (??? wie passend ist noch offen) return 
          .. wenn keine phi-Gleichheit, dann ab mit neuem pcgs in die LETZTEWEGELISTE
.. soweit erstmal, das müsste es gewesen sein.
WEGEVERGLEICHER([LETZTEWEGELISTE[32][1],Reversed(LETZTEWEGELISTE[32][2])],[LETZTEWEGELISTE[34][1],Reversed(LETZTEWEGELISTE[34][2])]);
WEGEVERGLEICHER([LETZTEWEGELISTE[11][1],Reversed(LETZTEWEGELISTE[11][2])],
[LETZTEWEGELISTE[6][1],Reversed(LETZTEWEGELISTE[6][2])]);
WEGEVERGLEICHER([LETZTEWEGELISTE[6][1],Reversed(LETZTEWEGELISTE[6][2])],[LETZTEWEGELISTE[7][1],Reversed(LETZTEWEGELISTE[7][2])]);
WEGEVERGLEICHER([LETZTEWEGELISTE[6][1],Reversed(LETZTEWEGELISTE[6][2])],[LETZTEWEGELISTE[8][1],Reversed(LETZTEWEGELISTE[8][2])]);
WEGEVERGLEICHER([LETZTEWEGELISTE[6][1],Reversed(LETZTEWEGELISTE[6][2])],[LETZTEWEGELISTE[9][1],Reversed(LETZTEWEGELISTE[9][2])]);
WEGEVERGLEICHER([LETZTEWEGELISTE[6][1],Reversed(LETZTEWEGELISTE[6][2])],[LETZTEWEGELISTE[10][1],Reversed(LETZTEWEGELISTE[10][2])]);
WEGEVERGLEICHER([LETZTEWEGELISTE[6][1],Reversed(LETZTEWEGELISTE[6][2])],[LETZTEWEGELISTE[11][1],Reversed(LETZTEWEGELISTE[11][2])]);
das noch???
[ 1, 1, 1, 14, 7 ] 0 6 [ f5, f1, f4, f2, f3 ]false .30false
[ 1, 1, 1, 3, 7 ] 0 6 [ f5, f1, f4, f3, f2 ]false .302false
[ 1, 1, 1, 12, 5 ] 0 6 [ f5, f1, f4, f2*f3, f2 ]false .20203true
WEGEVERGLEICHER([LETZTEWEGELISTE[13][1],Reversed(LETZTEWEGELISTE[13][2])],[LETZTEWEGELISTE[15][1],Reversed(LETZTEWEGELISTE[15][2])]);
aha [ 1, 1, 1, 14, 7 ] und [ 1, 1, 1, 12, 5 ] sind auf der Stufe k=3 nicht phi-gleich!!!!
damit finifinifinifinifini!!!!

WEGEVERGLEICHER([W,Reversed(H)],[LETZTEWEGELISTE[72][1],Reversed(LETZTEWEGELISTE[72][2])]);
hä, auf einmal sind 
[ 1, 1, 3, 2, 5 ]    [ f5, f1, f3, f4, f2 ] und
[ 1, 1, 1, 1, 325 ], [ f3, f2, f4, f5, f1 ]
phi-gleich???
kann nicht sein, weil sich bei 325 die letzte Stelle ändert, sonst nicht...???...
[ 3, 2, 4 ][ 3, 2, 4 ]
[ 2, 5, 4 ][ 6, 1, 4 ]
[ 13, 2, 4, 8 ][ 5, 2, 4, 8 ]
[ 2, 1, 4, 8 ][ 2, 1, 4, 8 ]
[ 1, 26, 4, 8, 16 ][ 1, 10, 4, 8, 16 ]
zu
[ 1, 14, 4, 24, 16 ][ 1, 30, 4, 24, 16 ]
[ 24, 16, 11, 17, 30 ][ 26, 29, 12, 3, 2 ]
also in WEGEVERGLEICHER die Print wieder an
.. und siehe da, das ist dann die Stelle, wo XSAMMEL noch gar nicht komplett ist...Pause
.. als Behelf hole ich die PHI in WEGEVERGLEICHER aus einem vorher vorbereiteten XSAMMELFERTIG
WEGEVERGLEICHER([LETZTEWEGELISTE[150][1],Reversed(LETZTEWEGELISTE[150][2])],[LETZTEWEGELISTE[222][1],Reversed(LETZTEWEGELISTE[222][2])],1);
WEGEVERGLEICHER([LETZTEWEGELISTE[150][1],Reversed(LETZTEWEGELISTE[150][2])],[LETZTEWEGELISTE[221][1],Reversed(LETZTEWEGELISTE[221][2])],1);
WEGEVERGLEICHER([LETZTEWEGELISTE[150][1],Reversed(LETZTEWEGELISTE[150][2])],[LETZTEWEGELISTE[220][1],Reversed(LETZTEWEGELISTE[220][2])],1);
WEGEVERGLEICHER([LETZTEWEGELISTE[150][1],Reversed(LETZTEWEGELISTE[150][2])],[LETZTEWEGELISTE[219][1],Reversed(LETZTEWEGELISTE[219][2])],1);
??????.00011101111111101111111011110110101000111000130011110010110111111101101
01true
[ 1, 1, 1, 1, 325 ] -1 6 [ f3, f2, f4, f5, f1 ]false DONNERWETTER *.21false
ok erstmalig sind jetzt die neuen ret soweit ok (insgesamt 3*false, je bei f5, f3 und f1)
das hier mal überprüfen:
[ 1, 1, 1, 48, 2 ] -1 6 [ f5, f2, f4, f1*f3, f1 ]false DONNERWETTER .21101false12546
[ 1, 1, 3, 2, 1 ] 0 3 [ f5, f3, f1, f4, f2 ]true .1000101010false01596
WEGEVERGLEICHER([[1,1,3,2,1],[G.2,G.4,G.1,G.3,G.5]],[[1,1,1,48,2],[G.1,G.1*G.3,G.4,G.2,G.5]],1);
stimmt aber...
und das???
  [ [ 1, 1, 1, 1, 7 ], [ f5, f2*f3*f4, f3, f2, f1 ] ], 
  [ [ 1, 1, 1, 1, 39 ], [ f5, f2*f3, f2*f4, f2, f1 ] ], 
WEGEVERGLEICHER([[1,1,1,1,7],[G.1,G.2,G.3,G.2*G.3*G.4,G.5]],[[1,1,1,1,39],[G.1,G.2,G.2*G.4,G.2*G.3,G.5]],1);
ist phi-gleich zur Stufe 2, erscheint aber in AKTUELLERTEST nur mit Stufe 1 
.. da passt wohl auch XSAMMELFERTIG nicht mehr dazu...

ok weiter beim ersten ret=true aufhör... ok das ging eigentlich bisher ganz gut
ok und gleich mal das neue ret statt dem alten versuchen...ok ging bisher auch gut
   also wie war das mit dem laten RBIT
   RBIT=6 wenn gar nicht drin
   RBIT=2 wenn überhaupt drin
   RBIT=3 wenn innerhalb des ersten Elements
   RBIT=4 wenn innerhalb der ersten beiden Elemente
   .. ich muss also H mit dem gefundenen pcgs vergleichen und entsprechend ret einstellen...
      sieht machbar aus... Pause
   ok mal probieren... ok juppp, größtenteils nur noch eine Zeile ok 
.. Size(LETZTEWEGELISTE)=77, da kann vielleicht noch was raus...ja da noch was mach...
.. und auch den XSAMMELFERTIG wieder raus, vohrher kann T(8) und so nicht gehen
.. überhaupt wenn XSAMMELFERTIG nicht mehr passt, kommt was anderes raus.
.. huuuuu es scheint, ich hab XSAMMELFERTIG wieder rausgebracht....
   .. nee, f3 fehlt jetzt mal, angeblich soll das phi-gleich sein:
[ [ 1, 1, 1, 1, 277 ], [ f3, f2, f4, f5, f1 ] ]
[ [ 1, 1, 8, 1, 7 ], [ f5, f4, f1*f3, f1, f2 ] ], 
WEGEVERGLEICHER([[1,1,1,1,277],[G.1,G.5,G.4,G.2,G.3]],[[1,1,8,1,7],[G.2,G.1,G.1*G.3,G.4,G.5]],1);
da fehlt die [ 24, 16, 11, 17, 30 ] aus dem alten
WEGEVERGLEICHER([[1,1,1,1,325],[G.1,G.5,G.4,G.2,G.3]],[[1,1,8,1,7],[G.2,G.1,G.1*G.3,G.4,G.5]],1);
[ [ 1, 14, 4, 24, 16 ], [ 24, 16, 11, 17, 30 ] ]
[ 2, 7, 4 ]
[ 3, 10, 4, 8, 16 ]
[ [ 1, 14, 4, 24, 16 ], [ 24, 16, 11, 17, 30 ], [ 3, 10, 4, 8, 16 ], [ 2, 7, 4 ] ]
[ f1, f2*f4*f5, f4, f2*f3, f3 ][ 1, 14, 4, 24, 16 ]
[ f2, f3, f1*f3*f4*f5, f1*f3, f5 ][ 24, 16, 11, 17, 30 ]
[ f2*f3, f1*f5, f1*f3*f4*f5, f1*f3, f5 ][ 3, 10, 4, 8, 16 ]
[ f2*f3, f1*f5, f1*f3, f4*f5, f5 ][ 2, 7, 4 ][ f2*f3, f1*f5, f1*f3, f4*f5, f5 ]
ist aber definitiv nicht phi-gleich.
Die erforderlichen Daten sind aber jetzt da:
         (277) 5 [ 1, 9, 5, 1, 1 ] Pcgs([ f1, f5, f4, f2, f3 ]) Pcgs([ f1, f2*f4*f5, f4, f2*f3, f3 
 ]) = ??????? [ 24, 16, 11, 17, 30 ][ 26, 29, 12, 3, 2 ][ 1, 14, 4, 24, 16 ][ 1, 30, 4, 24, 16 ]
trotzdem noch phi-gleich...
hab deshalb in WEGEFINDER noch ein extra if not(IsBound(PART[12])) rein
--> jetzt scheint es endlich ohne XSAMMELFERTIG zu gehen
--> ich hebe es mal in LOG6 auf
ok XSAMMELFERTIG isT damit raus ..
.. es fehlt jetzt zwar bei T(16) alles zu 4 [ 2, 2, 1, 1 ] 5 <=== [ 16, 13 ] (5) 
   aber dem kann ich jetzt in Ruche nachkommen mit VORLETZT:=1;
   also erastmal Feierabend 

    
#das war hier der Ablauf
LogTo("GAP_LOGFILE5.txt");
AKTUELLERTEST();
XSAMMELVIEWER0(XSAMMEL);
NEUEWEGELISTE;
WEGEVERGLEICHER(NEUEWEGELISTE[1],NEUEWEGELISTE[2]);
#ergibt [ f2, f4, f3, f1, f5 ]->[ f2, f4, f3, f1, f5 ] ok

#und das liefert sogar die Aufteilung für SEPARATOR:
AGES:=[];
for i in [1..Size(NEUEWEGELISTE)] do
  A:=WEGEVERGLEICHER(NEUEWEGELISTE[1],NEUEWEGELISTE[i]);
  Add(AGES,A[5]);
  Print(A[5]);
  od;
AGES;
#stimmt bis auf einen einzigen Vergleich 1-3: Was könnte das sein.???
WEGEVERGLEICHER(NEUEWEGELISTE[1],NEUEWEGELISTE[3]);
#ergibt [ f2, f4, f3, f1, f5 ]->[ f2, f3, f5, f1, f4*f5 ] ok
LogTo();

LogTo("GAP_LOGFILE6.txt");
VORLETZT:=1;
XSAMMEL:=[];#nur anfangs einmal
AUZAHL:=0;DDDDBIT:=0;DBIT:=1;#kurze Variante
G:=SmallGroup(16,14);
RMAXSUCH(G);#time;
G:=SmallGroup(16,11);
RMAXSUCH(G);#time;
G:=SmallGroup(16,3);
RMAXSUCH(G);#time;
XSAMMEL1:=StructuralCopy(XSAMMEL);;
G:=SmallGroup(32,27);
RMAXSUCH(G);#time;
XSAMMELFERTIG:=StructuralCopy(XSAMMEL);;
VORLETZT:=0;AKTUELLERTEST(0,0);
LogTo();

-- weiter ohne dem XSAMMELFERTIG:
VORLETZT:=1;AUZAHL:=0;DDDDBIT:=0;DBIT:=1;#kurze Variante
T(8);
G:=SmallGroup(16,13);
RMAXSUCH(G);#time;

false[ f4, f1, f2, f3 ] -1 5 [ 1, 2, 5, 3 ] DONNERWETTER *.21false12415
false[ f4, f1, f3, f2 ] -1 5 [ 1, 2, 1, 2 ] DONNERWETTER .211false12425
false[ f4, f1, f2*f3, f2 ] 0 5 [ 1, 2, 4, 4 ] .12true21413
true[ f4, f2, f1, f3 ] 0 3 [ 1, 2, 5, 3 ] .1111false11435
false[ f4, f3, f1, f2 ] 0 5 [ 1, 1, 2, 2 ] .21false12415
true[ f4, f3, f2, f1 ] 0 4 [ 1, 1, 2, 2 ] .211false12425
false[ f4, f3, f1*f2, f1 ] 0 5 [ 1, 1, 1, 2 ] .1111111false11465
false[ f4, f1*f3, f2, f1 ] 0 5 [ 1, 1, 3, 4 ] *.21false12415
false[ f4, f1*f3, f1, f2 ] -1 5 [ 1, 1, 2, 4 ] DONNERWETTER *.200false02425
false[ f4, f1*f3, f1*f2, f1 ] -1 5 [ 1, 1, 4, 2 ] DONNERWETTER .1111111111false11495
true[ f4, f2*f3, f1, f2 ] 0 3 [ 1, 1, 3, 4 ] .11111111111false114105
false[ f4, f1*f2, f1, f3 ] 0 5 [ 1, 1, 3, 3 ] .21false12415
false[ f4, f1*f2, f3, f1 ] 0 5 [ 1, 1, 1, 4 ] .200false02425
false[ f4, f1*f2, f1*f3, f1 ] 0 5 [ 1, 1, 4, 3 ] .13true31413
false[ f4, f1*f2*f3, f2, f1 ] 0 5 [ 1, 2, 5, 4 ] .12true21413
true[ f4, f1*f2*f3, f3, f1 ] 0 3 [ 1, 2, 1, 2 ] /12

VORLETZT:=0;AUZAHL:=0;DDDDBIT:=0;DBIT:=1;#kurze Variante
T(8);
G:=SmallGroup(16,13);
RMAXSUCH(G);#time;

false[ f4, f1, f2, f3 ] -1 5 [ 1, 2, 5, 3 ] DONNERWETTER *.22false22415
false[ f4, f1, f3, f2 ] -1 5 [ 1, 2, 1, 2 ] DONNERWETTER .212false22425
false[ f4, f1, f2*f3, f2 ] 0 5 [ 1, 2, 4, 4 ] .12true21413
true[ f4, f2, f1, f3 ] 0 3 [ 1, 2, 5, 3 ] .1111false11435
false[ f4, f3, f1, f2 ] 0 5 [ 1, 1, 2, 2 ] .21false12415
false[ f4, f3, f2, f1 ] 0 5 [ 1, 1, 2, 2 ] .211false12425
false[ f4, f3, f1*f2, f1 ] 0 5 [ 1, 1, 1, 2 ] .13true31413
true[ f4, f1*f3, f2, f1 ] 0 3 [ 1, 1, 3, 4 ] .13true31413
true[ f4, f2*f3, f1, f2 ] 0 3 [ 1, 1, 3, 4 ] .13true31413
true[ f4, f1*f2, f1, f3 ] 0 3 [ 1, 1, 3, 3 ] .11112true21443
true[ f4, f1*f2*f3, f2, f1 ] 0 3 [ 1, 2, 5, 4 ] /12

.. es fehlen also glatt zwei DONNERWETTER. Wo sind die hin
.. Auẞerdem was ist das, davon müsste doch das zweite true sein bei gleichem W.
false[ f4, f3, f1, f2 ] 0 5 [ 1, 1, 2, 2 ] .21false12415
false[ f4, f3, f2, f1 ] 0 5 [ 1, 1, 2, 2 ] .211false12425
WEGEVERGLEICHER([W,Reversed(H)],LETZTEWEGELISTE[1],1);
.. naja absolut gleicher Weg [ 1, 1, 2, 2 ], das muss ja true ergeben. 
   Was da blos wieder nicht ging...
.. hmpf na klar, in WEGEFINDER auch ein extra if not(IsBound(PART[12])) bei PHI^-1 rein...
   GUTE NACHT
   
VORLETZT:=0;AUZAHL:=0;DDDDBIT:=0;DBIT:=1;#kurze Variante
T(16);XSAMMELVIEWER2(XSAMMEL);
T(32);XSAMMELVIEWER3(XSAMMEL);
T(64);XSAMMELVIEWER4(XSAMMEL);

.. T(16) und T(32) stimmen jetzt und T(64) läuft, jetzt aber wirklich Gute Nacht
.. morgen weiter mit LETZTELISTE kürzer machen
.. vorher aber die [32,22] ist nicht mehr komplett drin...

rauskommen muss
#         5 [ 16, 4, 4, 16, 16 ] 64 [1203] 0 [ 32, 22 ] *
#         5 [ 16, 8, 16, 8, 16 ] 128 [1219] 0 [ 32, 22 ] *
#         5 [ 16, 12, 16, 16, 12 ] 64 [1235] 0 [ 32, 22 ] *
#         5 [ 16, 14, 16, 16, 14 ] 32 [1243] 0 [ 32, 22 ] *
 #         5 [ 16, 16, 8, 8, 16 ] 64 [1248] 0 [ 32, 22 ] *
#         5 [ 16, 16, 12, 16, 12 ] 32 [1252] 0 [ 32, 22 ] *
#         5 [ 16, 16, 15, 16, 15 ] 16 [1254] 0 [ 32, 22 ] *
 #         5 [ 16, 16, 16, 4, 4 ] 32 [1258] 0 [ 32, 22 ] *
 #         5 [ 16, 16, 16, 14, 14 ] 16 [1260] 0 [ 32, 22 ] *
#         5 [ 16, 16, 16, 15, 15 ] 8 [1261] 0 [ 32, 22 ] *
ich habe aber nur
-         5 [ 16, 4, 4, 16, 16 ] 64 [1075] 0 [ 32, 22 ] *
-         5 [ 16, 8, 16, 8, 16 ] 128 [1091] 0 [ 32, 22 ] *
-         5 [ 16, 12, 16, 16, 12 ] 64 [1107] 0 [ 32, 22 ] *
-         5 [ 16, 14, 16, 16, 14 ] 32 [1115] 0 [ 32, 22 ] *
-         5 [ 16, 16, 12, 16, 12 ] 32 [1120] 0 [ 32, 22 ] *
-         5 [ 16, 16, 15, 16, 15 ] 16 [1122] 0 [ 32, 22 ] *
-         5 [ 16, 16, 16, 15, 15 ] 8 [1125] 0 [ 32, 22 ] *

Suche:
VORLETZT:=1;AUZAHL:=0;DDDDBIT:=0;DBIT:=1;#kurze Variante
T(16);
XSAMMEL1:=StructuralCopy(XSAMMEL);;
G:=SmallGroup(32,22);
 LogTo("GAP_LOGFILE8.txt");
 XSAMMEL:=StructuralCopy(XSAMMEL1);;
 VORLETZT:=1;
 RMAXSUCH(G);#time;
 XSAMMELVIEWER0(XSAMMEL);
 LogTo();
XSAMMEL:=StructuralCopy(XSAMMEL1);;
VORLETZT:=0;
RMAXSUCH(G);#time;
XSAMMELVIEWER0(XSAMMEL);

hier die Abweichung:
false[ f4, f2*f3*f5, f5, f2, f1 ] 0 6 [ 1, 2, 10, 92, 108 ] .310false03526
false[ f4, f2*f3*f5, f5, f1*f2, f1 ] 0 6 [ 1, 2, 10, 15, 1 ] .20000false02546
false[ f4, f2*f3*f5, f2, f3, f1 ] 0 6 [ 1, 2, 10, 92, 96 ] /29

??????.000000000000000000000000000000000000000000000000000001true105532
true[ f4*f5, f2, f3, f4, f1 ] 0 2 [ 1, 2, 10, 92, 14 ] #/28
*
??????.02true20512
false[ f3, f2, f4, f5, f1 ] -1 6 [ 1, 2, 10, 92, 134 ] DONNERWETTER *.02true20512
false[ f3, f2, f5, f4, f1 ] -1 6 [ 1, 2, 10, 92, 208 ] DONNERWETTER .02true20512
false[ f3, f2, f4*f5, f4, f1 ] 0 6 [ 1, 2, 10, 92, 207 ] *.02true20512
false[ f3, f4, f2, f5, f1 ] -1 6 [ 1, 2, 10, 92, 230 ] DONNERWETTER .02true20512
wieso ist da oben ??????.02true, obwohl DONNERWETTER folgt? 
Sollte [ 1, 2, 10, 92, 134 ] zu [ 1, 2, 10, 92, 96 ] phi-gleich sein?
Kann gar nicht sein, weil beide phi auf [....8,16] enden.
deshalb 
WHALT:=[ 1, 2, 10, 92, 134 ];
und nochmal das Ganze bis break dann
WEGEVERGLEICHER([W,Reversed(H)],LETZTEWEGELISTE[2],1); ergibt true???

das  rechne ich gleich nochmal in VOR LETZT=1:

brk> LETZTEWEGELISTE{[1..5]};
[ [ [ 1, 2, 10, 92, 96 ], [ f4, f2*f3*f5, f2, f3, f1 ] ], 
  [ [ 1, 2, 10, 15, 1 ], [ f4, f2*f3*f5, f5, f1*f2, f1 ] ], 
  [ [ 1, 2, 10, 92, 108 ], [ f4, f2*f3*f5, f5, f2, f1 ] ], 
  [ [ 1, 2, 10, 16, 4 ], [ f4, f2*f3*f5, f5, f1, f2 ] ], 
  [ [ 1, 2, 10, 92, 86 ], [ f4, f2*f3*f5, f3, f2, f1 ] ] ]
brk> W;H;
[ 1, 2, 10, 92, 134 ]
[ f3, f2, f4, f5, f1 ]
WEGEVERGLEICHER([[ 1, 2, 10, 92, 134 ],[G.1,G.5,G.4,G.2,G.3]],[[ 1, 2, 10, 92, 134 ],[G.1,G.5,G.4,G.2,G.3]],1);
so muss es aussehen: aus VORLETZT=1 ganz durchgelaufen
[ [ 9, 26, 4, 8, 16 ], [ 8, 29, 3, 9, 26 ] ]
[ 9, 26, 4, 8, 16 ]
[ 15, 29, 6, 1, 12 ]
[ [ 9, 26, 4, 8, 16 ], [ 8, 29, 3, 9, 26 ], [ 15, 29, 6, 1, 12 ], [ 9, 26, 4, 8, 16 ] ]
[ f1*f2, f2*f3*f5, f4, f2, f3 ][ 9, 26, 4, 8, 16 ]
[ f2, f1*f3*f4, f1*f3*f5, f1, f5 ][ 8, 29, 3, 9, 26 ]
[ f1*f2, f2*f3*f5, f4, f2, f3 ][ 15, 29, 6, 1, 12 ]
[ f1, f5, f4, f2, f3 ][ 9, 26, 4, 8, 16 ][ f1, f5, f4, f2, f3 ]
so sieht es aus: aus VORLETZT=1 gleich nach break:
[ [ 9, 26, 4, 8, 16 ], [ 8, 29, 3, 9, 26 ] ]
[ 9, 26, 4, 8, 16 ]
[ [ 9, 26, 4, 8, 16 ], [ 8, 29, 3, 9, 26 ], [ 8, 29, 3, 9, 26 ], [ 9, 26, 4, 8, 16 ] ]
[ f1*f2, f2*f3*f5, f4, f2, f3 ][ 9, 26, 4, 8, 16 ]
[ f2, f1*f3*f4, f1*f3*f5, f1, f5 ][ 8, 29, 3, 9, 26 ]
[ f1, f2*f3*f5, f1*f2*f3, f1*f2*f4, f3*f4 ][ 8, 29, 3, 9, 26 ]
[ f2*f4*f5, f1*f4*f5, f1*f2*f3, f1*f2*f4, f3*f4 ][ 9, 26, 4, 8, 16 ][ f2*f4*f5, f1*f4*f5, f1*f2*f3, 
  f1*f2*f4, f3*f4 ]
da stimmt das zweite [ 8, 29, 3, 9, 26 ] nicht, das richtige [ 15, 29, 6, 1, 12 ] ist aber drin...
...aaaah ich ahne was: in WEGEVERGLEICHER muss 10-->11 sein. ok ja
.. aber, 
WEGEVERGLEICHER([W,Reversed(H)],LETZTEWEGELISTE[3],1);
ergibt
[ [ 9, 26, 4, 8, 16 ], [ 8, 29, 3, 9, 26 ] ]
[ 1, 6, 4 ]
[ 2, 3, 7 ]
[ 5, 10, 4, 8 ]
[ [ 9, 26, 4, 8, 16 ], [ 8, 29, 3, 9, 26 ], [ 1, 2, 4, 8 ], [ 5, 10, 4, 8 ], [ 2, 3, 7 ], [ 1, 6, 4 ] ]
[ f1*f2, f2*f3*f5, f4, f2, f3 ][ 9, 26, 4, 8, 16 ]
[ f2, f1*f3*f4, f1*f3*f5, f1, f5 ][ 8, 29, 3, 9, 26 ]
[ f2, f1*f3*f4, f1*f3*f5, f1, f5 ][ 1, 2, 4, 8 ]
[ f2, f3*f4*f5, f1*f3, f1, f5 ][ 5, 10, 4, 8 ]
[ f2, f3*f4*f5, f1, f3*f5, f3 ][ 2, 3, 7 ]
[ f2, f3*f4*f5, f1, f5, f3 ][ 1, 6, 4 ][ f2, f3*f4*f5, f1, f5, f3 ]
und das liegt jetzt daran, dass
[ [ 9, 26, 4, 8, 16 ], [ 8, 29, 3, 9, 26 ] ]
am Anfang wohl nicht vollständig ist, da fehlt die Verknüpfung von HANF zu [1]
muss ich jetzt mal gründlichst überlegen...dazu Ausgabe, wenn HANF gesetzt wird.
bei VORLETZT=1 kommt dabei heraus:
brk> LETZTEWEGELISTE{[1..5]};
[ [ [ 1, 1, 2, 14, 10 ], [ f4*f5, f1*f2*f4, f4, f3, f1 ] ], 
  [ [ 1, 1, 2, 4, 2 ], [ f4*f5, f1*f2*f4, f4, f1, f3 ] ], 
  [ [ 1, 1, 2, 14, 8 ], [ f4*f5, f1*f2*f4, f3, f4, f1 ] ], 
  [ [ 1, 2, 1, 14, 2 ], [ f4*f5, f3*f4, f1*f2*f3, f3, f1 ] ], 
  [ [ 1, 2, 10, 43, 2 ], [ f4*f5, f3*f4, f3, f1*f2, f1 ] ] ]
brk> LETZTEWEGELISTE{[20..25]};         
[ [ [ 1, 2, 2, 3, 4 ], [ f4*f5, f4, f1, f2*f3, f2 ] ], [ [ 1, 2, 2, 14, 9 ], [ f4*f5, f4, f1, f3, f2 ] ], 
  [ [ 1, 2, 2, 14, 12 ], [ f4, f5, f1*f2, f3, f1 ] ], [ [ 1, 2, 2, 6, 2 ], [ f4, f5, f1*f2, f1, f3 ] ], 
  [ [ 1, 2, 3, 6, 1 ], [ f4, f5, f1*f3, f1*f2, f1 ] ], [ [ 1, 2, 3, 13, 11 ], [ f4, f5, f1*f3, f1, f2 ] ] ]
WEGEVERGLEICHER([W,Reversed(H)],LETZTEWEGELISTE[24],1);
[ [ 9, 26, 4, 8, 16 ], [ 8, 29, 3, 9, 26 ] ]
[ 1, 6, 4 ]
[ 2, 3, 7 ]
[ 5, 10, 4, 8 ]
[ 1, 2, 4, 8 ]
[ [ 9, 26, 4, 8, 16 ], [ 8, 29, 3, 9, 26 ], [ 1, 2, 4, 8 ], [ 5, 10, 4, 8 ], [ 2, 3, 7 ], [ 1, 6, 4 ] ]
[ f1*f2, f2*f3*f5, f4, f2, f3 ][ 9, 26, 4, 8, 16 ]
[ f2, f1*f3*f4, f1*f3*f5, f1, f5 ][ 8, 29, 3, 9, 26 ]
[ f2, f1*f3*f4, f1*f3*f5, f1, f5 ][ 1, 2, 4, 8 ]
[ f2, f3*f4*f5, f1*f3, f1, f5 ][ 5, 10, 4, 8 ]
[ f2, f3*f4*f5, f1, f3*f5, f3 ][ 2, 3, 7 ]
[ f2, f3*f4*f5, f1, f5, f3 ][ 1, 6, 4 ][ f2, f3*f4*f5, f1, f5, f3 ]
nu da fehlt doch unter der [ 1, 2, 4, 8 ] die...
WEGEVERGLEICHER([W,Reversed(H)],LETZTEWEGELISTE[3],1);
()()()()()huuu aber jetzt hab ich nochmal das Add[10] und Add[11] komplett neu gemacht
in WEGEVERGLEICHER

So, nach diesem weiter mit 
.. kürzere NEUEWEGELISTE, da werden nicht alle gebraucht.
.. und auch WEGEBAUM kann ja raus
.. jetzt fehlt was zur [32,48]... also

Suche:
VORLETZT:=1;AUZAHL:=0;DDDDBIT:=0;DBIT:=1;#kurze Variante
VORLETZT:=1;AUZAHL:=3;DDDDBIT:=1;DBIT:=1;#kurze Variante
T(16);
XSAMMEL1:=StructuralCopy(XSAMMEL);;
G:=SmallGroup(32,48);
 LogTo("GAP_LOGFILE8.txt");
 XSAMMEL:=StructuralCopy(XSAMMEL1);;
 VORLETZT:=1;
 RMAXSUCH(G);#time;
 XSAMMELVIEWER0(XSAMMEL);
 LogTo();
XSAMMEL:=StructuralCopy(XSAMMEL1);;
VORLETZT:=0;
RMAXSUCH(G);#time;
XSAMMELVIEWER0(XSAMMEL);

WHALT:=[ 1, 1, 3, 8, 4 ];
brk> W;H;
[ 1, 1, 3, 8, 4 ]
[ f5, f1*f3, f2, f1, f4 ]
brk> LETZTEWEGELISTE{[21]};
[ [ [ 1, 2, 4, 2, 4 ], [ f5, f1, f2*f3, f4, f2 ] ] ]
WEGEVERGLEICHER([W,Reversed(H)],LETZTEWEGELISTE[19],1);
wieder mit VORLETZT=1 vergleichen
WEGEVERGLEICHER([[ 1, 1, 3, 8, 4 ],[G.4,G.1,G.2,G.1*G.3,G.5]],[[ 1, 2, 4, 2, 4 ],[G.2,G.4,G.2*G.3,G.1,G.5]],1);
DDDDBIT:=1;
auch da sind beide phi-gleich. Da hat sich wohl die Sache erledigt...???
jetzt ORB dazu
******[ 
[ [ <identity> of ..., f5 ] ], 

[ [ f1, f1*f5 ], 
  [ f2*f4, f2*f4*f5 ], 
  [ f1*f2*f3*f4, f1*f2*f3*f4*f5 ], 
  [ f1*f2*f3, f1*f2*f3*f5 ], 
  [ f2, f2*f5 ], 
  [ f1*f4, f1*f4*f5 ] ], 

[ [ f3, f3*f5 ], [ f3*f4, f3*f4*f5 ] ], 

[ [ f4, f4*f5 ] ], 
  
[ [ f1*f2, f1*f2*f5 ], 
  [ f2*f3, f2*f3*f5 ], 
  [ f1*f3*f4, f1*f3*f4*f5 ], 
  [ f2*f3*f4, f2*f3*f4*f5 ], 
  [ f1*f3, f1*f3*f5 ], 
  [ f1*f2*f4, f1*f2*f4*f5 ] ] ]

also definitiv verschiedene Orbits, also dürfte das gar nicht phi-gleich sein
oder das phi-gleich funktioniert nicht

.. deshalb versuche ich jetzt (Teilweg+Phi)-Gleichheit, das ist etwas spezieller.
.. <R/> bei der Gelegenheit dann auch gleich die gesamte LETZTEWEGELISTE durchsuchen, nicht nur Stufe k
.. der Wert (..) darf anders werden bei XSAMMELVIEWER weil das PWEG-PHI-gleich andere Reihenfolge bringen könnte
ok ok ok ok ok ok ok ok also T(32) stimmt jetzt definitiv mit dem aus XSAMMEL.txt überein, aucH die (..)-Zahlen
ok also gleich git und erst danach noch weng weiter mit <R/>
.. das versuche ich jetzt mal,
   ok zuerst ob das kkk rauskann, dafür nur k+2....ok kann raus
   .. dann mach ich halt mal los mit dem
      .. ich durchlaufe mit W die gesamte LETZTEWEGELISTE
      .. setze bei jedem das k neu,
      .. bestimme kk
      .. wenn kk>k dann return true
      .. also alles ganz einfach
.. die unterschiedlichen (..) war wohl weil bei n=16 XSAMMEL.txt nicht aktuell ist...
   wenn n=16 nicht ganz übereinstimmt, dann stimmt aber trotzdem n=32, also ist es wohl so.
ok ok ok ok ok ok ok und schon ist das neue QY07L durch, T(32) passt. L1
.. Potential für schnelles QY07L ist auch da, alle PHI zu je zwei zusammenfassen.
UND FEIERABEND!!!!

noch weng aufheb:
LogTo("GAP_LOGFILE_L1.txt");
VORLETZT:=0;AUZAHL:=0;DDDDBIT:=0;DBIT:=1;#kurze Variante
T(32);time;
XSAMMELVIEWER0(XSAMMEL);
XSAMMELVIEWER3(XSAMMEL);
XSAMMELVIEWER4(XSAMMEL);
LogTo();


##weiter jetzt
nö 4587 wieder auf nur die letzten k aus LWL durchsuchen nicht, weil bei [32,25] ist ein Gegenbeispiel dabei i=29+1->8
.. aha mit der Korrektur k für i=i und nicht i=1 berechnen werden es noch weniger auch bei [32,25]
.. dann direkt weiter mit TEILWEGELISTE

#Read...
VORLETZT:=0;AUZAHL:=0;DDDDBIT:=0;DBIT:=1;#kurze Variante
T(32);time;
XSAMMELVIEWER4(XSAMMEL);

[32,25] Frage ist hier f4*f5 in der selben Bahn wie f5?
70true[ f4*f5, f4, f1*f2*f3, f2, f1 ] 0 2 [ 1, 2, 3, 15, 6 ] #/24
26false[ f5, f4, f1*f2*f3, f2, f1 ] 0 7 [ 1, 2, 3, 15, 2 ] *.3022222222222222222222222211111111111

um das rauszubekommen,AUZAHL:=2;
VORLETZT:=0;AUZAHL:=2;DDDDBIT:=0;DBIT:=1;#kurze Variante
T(32);time;
XSAMMELVIEWER4(XSAMMEL);
und danach sind f5 und f4*f5 nicht in der selben Bahn! Also alles zurückstell auf Version "nur gleiche k" durchsuchen.

ok ist zurückgestellt, ab jetzt muss immer (inzwischen falsch)
[ 3, 27, 5, 8, 11, 5, 14, 9, 11, 8, 7, 5, 5, 2, 5 ]165
[ 20, 55, 40, 55, 92, 33, 60, 102, 68, 89, 64, 39, 33, 20, 27 ]
[ 5, 14, 2, 7, 2, 2, 1 ]198
[ 10, 32, 10, 147, 39, 51, 1 ]
herauskommen.

ok jetzt erst paar keinere Korrekturen wie 
   ok kkk ganz raus
   ok anstelle {[1..k]} nur [k] vergleichen bei while überall
   ok WEGEBAUM mal deaktivieren wenigstens
ok funktioniert soweit identisch, dann geht es jetzt an den 
.. schnellen WEGEVERGLEICHER...

[ [ [ 1, 1, 3, 2 ], [ f4, f1*f2, f1, f3 ], 1, [ 13, 4, 10, 8 ] ], 
  [ [ 1, 2, 1, 15 ], [ f4, f3, f1*f2, f1 ], 2, [ 2, 4, 13, 8 ] ], 
  [ [ 1, 2, 10, 55 ], [ f4, f3, f1, f2 ], 1, [ 6, 2, 13, 8 ] ], 
  [ [ 1, 2, 10, 51 ], [ f4, f1, f3, f2 ], 2, [ 6, 13, 2, 8 ] ], 
  [ [ 1, 2, 5, 2 ], [ f4, f1, f2, f3 ], 1, [ 1, 2, 4, 8 ] ] ]
WEGEVERGLEICHER([W,Reversed(H)],[LETZTEWEGELISTE[i][1],Reversed(LETZTEWEGELISTE[i][2])],1);
WEGEVERGLEICHER([LETZTEWEGELISTE[1][1],Reversed(LETZTEWEGELISTE[1][2])],[LETZTEWEGELISTE[2][1],Reversed(LETZTEWEGELISTE[2][2])],1);



also von
[ f4, f1*f2, f3, f1 ]
über
[ f4, f1, f2, f3 ]
nach
[ f4, f1*f2, f1, f3 ]

macht direkt
WEGEVERGLEICHER([W,Reversed(H)],[LETZTEWEGELISTE[1][1],Reversed(LETZTEWEGELISTE[1][2])],1);
[ f1, f3, f1*f2, f4 ][ 1 ]
[ f1, f3, f1*f2, f4 ][ 1 ]
[ f1, f3, f1*f2, f4 ][ 1, 2 ]
[ f1, f3, f1*f2, f4 ][ 1, 2 ]
[ f1, f1*f2*f3*f4, f1*f2, f4 ][ 7, 2, 4 ]
[ f1, f1*f2*f3*f4, f1*f2, f4 ][ 1, 2, 4 ]
[ f1, f1*f2*f3*f4, f1*f2, f4 ][ 1, 2, 4, 8 ]
[ f1*f2*f3*f4, f1, f1*f2, f4 ][ 2, 1, 4, 8 ]
[ f1*f2*f3*f4, f1, f1*f2, f4 ][ 1, 2, 4, 8 ]
[ f3, f1, f1*f2, f4 ][ 5, 2, 4, 8 ]
[ f3, f1*f2, f1*f4, f4 ][ 2, 5, 4 ]
[ f3, f1*f2, f1*f4, f4 ][ 1, 2, 4 ]
[ f3, f1*f2, f1*f4, f4 ][ 1, 2 ]
[ f3, f1*f2, f1*f4, f4 ][ 1, 2 ]
[ f3, f1*f2, f1*f4, f4 ][ 1 ]
[ f3, f1*f2, f1*f4, f4 ][ 1 ][ f3, f1*f2, f1*f4, f4 ]
mit r=[ f3, f1*f2, f1*f4, f4 ]
ha, hin und zurück passt hier ja gar nicht:
WEGEVERGLEICHER([LETZTEWEGELISTE[1][1],Reversed(LETZTEWEGELISTE[1][2])],[LETZTEWEGELISTE[1][1],Reversed(LETZTEWEGELISTE[1][2])],1);
WEGEVERGLEICHER([LETZTEWEGELISTE[2][1],Reversed(LETZTEWEGELISTE[2][2])],[LETZTEWEGELISTE[2][1],Reversed(LETZTEWEGELISTE[2][2])],1);
WEGEVERGLEICHER([LETZTEWEGELISTE[3][1],Reversed(LETZTEWEGELISTE[3][2])],[LETZTEWEGELISTE[3][1],Reversed(LETZTEWEGELISTE[3][2])],1);
WEGEVERGLEICHER([LETZTEWEGELISTE[4][1],Reversed(LETZTEWEGELISTE[4][2])],[LETZTEWEGELISTE[4][1],Reversed(LETZTEWEGELISTE[4][2])],1);
WEGEVERGLEICHER([W,Reversed(H)],[W,Reversed(H)],1);
Menschmenschmensch, da war bei =[8,3] doch i[10] und i[11] ungleich [1,2,4]
jetzt läuf der r=MRES Vergleich durch!!!
das war eine N durch!! Pause

Ab jetzt gilt:
[ 1, 1 ]3
[ 1, 1 ]
# 2, 3, 4, 5
[ 3, 3, 1, 1 ]11
[ 3, 3, 1, 1 ]
# 2, 3, 4
[ 1, 7, 2 ]21
[ 4, 11, 8 ]
#10, 11,12, 13,14
[ 4,  8, 2,  4, 1 ]40
[ 6, 12, 4, 11, 1 ]
# 21  22  23  24  25  26  27  28  29  30  31  32  33  34  35
[ 3,  27,  5,  8, 11,  5, 14,  9, 11,  8,  7,  5,  5,  2,  5 ]165
[ 20, 55, 40, 55, 87, 33, 54, 89, 68, 83, 57, 39, 33, 20, 27 ]
[ 20, 55, 40, 55, 83, 33, 54, 93, 72, 83, 56, 39, 33, 20, 27 ]#ab ???
# 45, 46, 47, 48, 49, 50, 51
[  5, 14,  2,  7,  2,  2, 1 ]198
[ 10, 30, 10, 55, 38, 27, 1 ]
[ 10, 30, 10, 55, 39, 28, 1 ]#neu ab ???
#195..245
[ 4, 64, 7, 17, 21, 7, 8, 5, 4, 5, 64, 20, 22, 14, 31, 11, 6, 6, 22, 4, 8, 
  12, 10, 7, 14, 16, 6, 17, 19, 9, 13, 15, 2, 6, 10, 22, 11, 13, 10, 7, 17, 
  21, 18, 11, 5, 12, 7, 2, 7, 7, 2, 6, 10, 1 ]893
[ 60, 165, 120, 330, 498, 198, 473, 376, 144, 352, 324, 558, 432, 498, 1006, 
  336, 234, 198, 1221, 120, 162, 600, 441, 653, 678, 562, 550, 1167, 993, 
  688, 538, 965, 210, 386, 608, 1469, 749, 518, 278, 330, 1167, 1149, 1064, 
  618, 443, 606, 222, 80, 397, 591, 156, 606, 573, 72 ]
#260..267
[ 6, 22, 2, 9, 4, 4, 3, 1 ]944
[ 15, 60, 20, 165, 234, 168, 333, 1 ]

ok auch das Gesamt-PHI beim ersten LETZTEWEGELISTE-Eintrag scheint geklärt.
ok damit kann ich ja mal zum schnellen WEGEVERGLEICHER übergehen...ok ist so gut wie durch ok L6
  count  self/ms  chld/ms  stor/kb  chld/kb  package  function                                 
   2232       40      110       61       61           PositionFirstComponentRepariert          
   8529      250       20     1256        0           DEEP_COPY_OBJ                            
  33384      730      100      601       11  GAP      PositionSorted                           
   3102      590      370       72        1           XLEER                                    
    605      380     1210      456     2341           XMISCH                                   
    392     1580      590     2448      543  GAP      Stabilizer                               
   8674     2380        0     2924        0  GAP      Group                                    
   6042     2470       20      141        0  (oprt.)  PositionFirstComponent                   
   6042      160     2470      141      141           QY08                                     
  71940     2550      130     2778        0           Commu                                    
    158     1240     1770      451     3071           QY15                                     
   8296     2500      700     3307      664           QY10                                     
  45365     3680        0    12546        0           IZUN                                     
  71452     5240        0    15527        0           QY09                                     
   5884     1550     6960     2561     5474           QY21                                     
 144348     9940        0     9307        0  (oprt.)  PcElementByExponentsNC                   
   2944     7010     2980     9387     4765           XFUELL                                   
 143649    10730        0    19800        0           NZUI                                     
   1818     3920     7540     5816    10604           WEGEVERGLEICHER                          
   3932    11240      230    25228      340  (oprt.)  RightTransversal                         
    158     1940    10300     2027    20802           QY14                                     
 128997    13900      200    12169       83  (oprt.)  Size                                     
   5726     1800    18370     2607    35519           QY11                                     
 145981    25610        0    36697        0  (oprt.)  ExponentsOfPcElement                     
   1818     3450    29250     5903    48595           QY07L                                    
  21343    45340        0   101118        0  (oprt.)  PcgsByPcSequenceNC                       
   2544     6370    40130     7712    84178           QY12                                     
   3930    36380   141350    73890   251812           QY13                                     
          202970            356945                    TOTAL                                    
.. jetzt hole ich mal die Zeiten von ganz am Anfang

  count  self/ms  chld/ms  stor/kb  chld/kb  package  function                                 
   1028       10       20       14        0  GAP      PositionSorted                           
    470       70       10       62       12           QY07NEU                                  
    536      100        0       14        0           PositionFirstComponentRepariert          
   1815      220        0       42        0  (oprt.)  PositionFirstComponent                   
    105       50      180       57      117           QY15                                     
   1821      200       90       42        1           XLEER                                    
   1815       80      230       42       42           QY08                                     
    538       80      520      115     1039           XMISCH                                   
   9802      620        0      675        0  (oprt.)  PcElementByExponentsNC                   
   2944      840        0     1067        0  GAP      Group                                    
   1710      340      730      659      436           QY21MINI                                 
  28728     1880        0     6178        0           QY09                                     
   6331     2350        0     3473        0           QY10A                                    
    105      380     2130      575     4486           QY14                                     
  30215     2730        0     6087        0  (oprt.)  Size                                     
   1262     4680        0    10530        0  (oprt.)  RightTransversal                         
   1710      560     4640      876     9786           QY11A                                    
   1821     3810     1430     6515     3108           XFUELL                                   
  39126     7610        0    11297        0  (oprt.)  ExponentsOfPcElement                     
   7741    14840        0    35338        0  (oprt.)  PcgsByPcSequenceNC                       
   1431     2980    17450     4278    37664           QY12                                     
   1262     1930    38230     3562    77053           QY13                                     
              10               102                    OTHER                                    
           46370             91611                    TOTAL                                    
.. na deutlich weniger, mal schauen was noch geht

162790 mehr ist momentan nich, aber gut, da überleg ich nochmal
2284340 für die [ 256, 56089 ]
170340 für T(32) nachdem LETZTEWEGELISTE von 1 auf gefllt wird und anderes

.. oho, auf einmal ist QY13 nur noch 4390 statt vorher 36380. Was war das?
   gut git sagt besser RightTransversal statt CosetDecomposition, also nehmen wir das.
   jetzt nimmt die Sache Gestalt an:

  count  self/ms  chld/ms  stor/kb  chld/kb  package  function                                  
   4046      100       10      260        0           DEEP_COPY_OBJ                             
   4552      120        0       62        0  GAP      PositionSorted                            
   2232       60      130       61       61           PositionFirstComponentRepariert           
   3102      530      390       72        1           XLEER                                     
    605      360     1280      456     2343           XMISCH                                    
   6032     2070        0      141        0  (oprt.)  PositionFirstComponent                    
   6032      150     2070      141      141           QY08                                      
   8480     2330       20     2744        0  GAP      Group                                     
  71932     2400       40     2778        0           Commu                                     
  31620     2530        0     8680        0           IZUN                                      
    158     1260     1680      428     3033           QY15                                      
  71410     5070        0    15497        0           QY09                                      
   8274     4320      640     7500      665           QY10                                      
  90074     6350      140    14228        0  (oprt.)  Size                                      
 101063     6880        0    13812        0           NZUI                                      
   5874     1670     5690     2557     5453           QY21                                      
   2944     5480     2330     9416     4643           XFUELL                                    
 164853     9760        0    10477        0  (oprt.)  PcElementByExponentsNC                    
   1814     3880     7180     5803    10584           WEGEVERGLEICHER                           
    158     2060    10340     2028    20832           QY14                                      
   3924    14310        0    32098        0  (oprt.)  RightTransversal                          
   5716     1850    17600     2569    35081           QY11                                      
   1814     2650    17830     6127    27097           QY07L                                     
 107778    22830        0    32029        0  (oprt.)  ExponentsOfPcElement                      
  19126    38740        0    89150        0  (oprt.)  PcgsByPcSequenceNC                        
   2544     6230    40320     7708    84269           QY12                                      
   3924     4650   133450     8868   249726           QY13                                      
          148640            275700                    TOTAL                                     

.. möglicherweise war aucH die schnelle Anfangsvariante eine von den fehlerhaften, egal, läuft jetzt.

MemoryUsage(XSAMMEL);
502244 mit IZUN NZUI
gap> MemoryUsage(XSAMMEL);
1506640 ohne IZUN NZUI, also muss das drinbleiben

Zeitaufteilung der PcgsByPcSequenceNC
  count  self/ms  chld/ms  stor/kb  chld/kb  package  function                                  
   4552       70        0       62        0  GAP      PositionSorted                            
   4046       80        0      260        0           DEEP_COPY_OBJ                             
   2232       40       70       61       61           PositionFirstComponentRepariert           
    272        0      430        5     1397           PcgsByPcSequenceNCMI                      
   3102      450      370       72        1           XLEER                                     
    316       10      850        6     1628           PcgsByPcSequenceNC15                      
    605      380     1140      456     2348           XMISCH                                    
   6032     2270        0      141        0  (oprt.)  PositionFirstComponent                    
   6032      150     2270      141      141           QY08                                      
    936       30     2400       18     4829           PcgsByPcSequenceNC07                      
  71932     2330      150     2778        0           Commu                                     
  31620     2560        0     8680        0           IZUN                                      
   8480     2660       10     2745        0  GAP      Group                                     
    158     1160     1660      428     3040           QY15                                      
   2232       40     4330       43    11404           PcgsByPcSequenceNC14                      
  71410     4940        0    15497        0           QY09                                      
   8274     4580      470     7496      665           QY10                                      
  90074     6330       40    14225        0  (oprt.)  Size                                      
 101063     7260        0    13812        0           NZUI                                      
   2944     5530     2180     9405     4640           XFUELL                                    
   5874     1260     6580     2557     5452           QY21                                      
 164853     9290        0    10476        0  (oprt.)  PcElementByExponentsNC                    
   1814     3870     6950     5803    10584           WEGEVERGLEICHER                           
    158     1860     9430     2028    20876           QY14                                      
   5716      100    12050      111    24796           PcgsByPcSequenceNC11                      
   3924    13690        0    32098        0  (oprt.)  RightTransversal                          
   9632      280    17640      188    44939           PcgsByPcSequenceNC12                      
   5716     1890    17460     2568    35199           QY11                                      
   1814     2640    17750     6127    27117           QY07L                                     
 107778    20920        0    32031        0  (oprt.)  ExponentsOfPcElement                      
  19126    37740        0    89159        0  (oprt.)  PcgsByPcSequenceNC                        
   2544     6920    38480     7709    84459           QY12                                      
   3924     3950   131200     8867   250100           QY13                                      
          145280            276064                    TOTAL                                     

   4458    16120        0    36370        0  (oprt.)  RightTransversal     
   9632      300    17410      188    44939           PcgsByPcSequenceNC12 
   2144     1410    17550     3315    29158           QY07                 
 112600    22350        0    33474        0  (oprt.)  ExponentsOfPcElement 
   6580     2200    20600     2983    40908           QY11                 
  20248    39600        0    94404        0  (oprt.)  PcgsByPcSequenceNC   
   2544     6710    38670     7708    84458           QY12                 
   4458     4690   137890    10015   263873           QY13                 
          152670            290992                    TOTAL                

###zu anupq aus D4_2E/ANUPQ_Test.txt
#n=64:
LoadPackage("anupq");
R1:=[[1],[2,2],[2,2,2],[2,2,2,2],
[2,2,2,2,2],
[2,2,2,2,2,2]];
G1:=PcgsOfR(R1);
R2:=[[1],[2,2],[2,2,2],[2,2,2,2],
[2,2,2,2,2],
[1,1,1,1,1,2]];
G2:=PcgsOfR(R2);
RMAXSUCH(G1);time;
WOHINDAMIT(Reversed(GeneratorsOfGroup(G2)));
IsIsomorphicPGroup(G1,G2);time;#aus ANUPQ-Package
#2000:440



#G=[128,2163]stark gemäßigt
R1:=[[1],[2,2],[2,2,1],[2,2,1,1],
[1,1,1,1,1],
[1,1,14,14,14,1],
[2,2,1,1,1,1,14]];
G1:=PcgsOfR(R1);
R2:=[[1],[2,2],[2,2,1],[2,2,1,1],
[2,2,1,1,1],
[1,1,1,1,1,1],
[1,1,32,32,32,32,1]];
G2:=PcgsOfR(R2);
RMAXSUCH(G1);time;
WOHINDAMIT(Reversed(GeneratorsOfGroup(G2)));
IsIsomorphicPGroup(G1,G2);time;#aus ANUPQ-Package
#22000:???

#G=[128,2163] leicht gemäßigt
R1:=[[1],[2,2],[2,2,2],[2,2,2,2],
[2,2,1,16,16],
[2,2,1,15,15,16],
[2,2,16,1,16,1,1]];
G1:=PcgsOfR(R1);
R2:=[[1],[2,2],[2,2,2],[2,2,2,2],
[2,2,1,16,16],
[2,2,16,1,16,2],
[2,2,1,15,15,15,1]];
G2:=PcgsOfR(R2);
RMAXSUCH(G1);time;
RMAXSUCH(G2);time;#(muss ganz fix gehen)
IsIsomorphicPGroup(G1,G2);time;#aus ANUPQ-Package
#nix


#neuer Versuch: LWL kürzer machen auf eventuell  nur 1:
Suche:
AUZAHL:=0;DDDDBIT:=0;DBIT:=0;#kurze Variante
T(16);
XSAMMEL1:=StructuralCopy(XSAMMEL);;
G:=SmallGroup(32,49);
XSAMMEL:=StructuralCopy(XSAMMEL1);;
RMAXSUCH(G);#time;
XSAMMELVIEWER0(XSAMMEL);
LETZTEWEGELISTE;
XMERKZAHL;Size(LETZTEWEGELISTE);

T(32);#Ergebnis, bei mehreren inh werden nicht alle 31 Anfangselemente durchlaufen... erstmals bei [16,13];
#dadurch zu kleine XMERKZAHL. hier jetzt das untersuchen:

DBIT:=1;
T(8);
XSAMMEL1:=StructuralCopy(XSAMMEL);;
G:=SmallGroup(16,13);
XSAMMEL:=StructuralCopy(XSAMMEL1);;
RMAXSUCH(G);#time;
XSAMMELVIEWER0(XSAMMEL);
LETZTEWEGELISTE;
XMERKZAHL;Size(LETZTEWEGELISTE);

1false[ f1, f4, f2, f3 ] -1 6 [ 1, 2, 6, 3 ] DONNERWETTER 
2false[ f1, f4, f3, f2 ] -1 6 [ 1, 2, 2, 2 ] DONNERWETTER 
3false[ f1, f4, f2*f3, f3 ] 0 6 [ 1, 2, 7, 3 ] .
3true[ f2, f4, f1, f3 ] 0 2 [ 1, 2, 6, 3 ] ..
4false[ f4, f1, f2, f3 ] 0 6 [ 1, 2, 9, 3 ] 
5false[ f4, f1, f3, f2 ] 0 6 [ 1, 2, 3, 2 ] 
6false[ f4, f1, f2*f3, f3 ] 0 6 [ 1, 2, 8, 3 ] 
6true[ f4, f2, f1, f3 ] 0 3 [ 1, 2, 9, 3 ] 
7false[ f4, f3, f1, f2 ] 0 6 [ 1, 1, 2, 2 ] 

#da ist das if ZR3MERK=0 and WEGEZAHL=0 then RBIT:=0; zuviel, ohne dem geht es!!!!
#und statt WEGEZAHL:=WNUMB+1; hatte ich WEGEZAHL:=WNUMB; eingegeben
#gut dass ich das noch rechtzeitig vor dem Verwerfen gesehen hab

#jetzt muss ich noch rausbekommen, warum geringfüfig mehr QY13 sind....
#aha, das erste mal bei [16,2]
DBIT:=1;
T(8);
XSAMMEL1:=StructuralCopy(XSAMMEL);;
G:=SmallGroup(16,2);
XSAMMEL:=StructuralCopy(XSAMMEL1);;
WNUMBIT:=0;
RMAXSUCH(G);
LETZTEWEGELISTE;
XSAMMEL:=StructuralCopy(XSAMMEL1);;
WNUMBIT:=1;
RMAXSUCH(G);#time;
LETZTEWEGELISTE;
#oha, ich muss nicht aus jedem QY13 einen pcgs aufheben sondern einen für jeden WEGLI{[1..K]}
#ja, da geht noch was, WEGEZAHL=1 wäre ja auch zu einfach gewesen. Überlewge icH mir aber nicht jetzt
#also halt. Die zugehörigen Daten waren

gap> XSAMMEL:=StructuralCopy(XSAMMEL1);;
gap> WNUMBIT:=0;
0
gap> RMAXSUCH(G);
?...???
1false[ f3, f1, f4, f2 ] -1 6 [ 1, 1, 2, 2 ] DONNERWETTER ??
2false[ f3, f4, f1, f2 ] 0 6 [ 1, 2, 3, 1 ] ?
3false[ f3, f4, f2, f1 ] 0 6 [ 1, 2, 2, 1 ] ?
4false[ f3, f4, f1*f2, f2 ] 0 6 [ 1, 2, 1, 2 ] ??
4true[ f3, f1*f4, f4, f2 ] 0 3 [ 1, 1, 2, 2 ] .???
4true[ f4, f2, f3, f1 ] 0 2 [ 1, 1, 2, 2 ] ......???
4true[ f3*f4, f4, f1, f2 ] 0 2 [ 1, 2, 1, 2 ] ..... <4> 1
gap> LETZTEWEGELISTE;
[ [ [ 1, 1, 2, 2 ], [ f3, f1, f4, f2 ], 5, [ [ 1, 0, 1, 0 ], [ 0, 1, 1, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ] ], 
  [ [ 1, 2, 3, 1 ], [ f3, f4, f1, f2 ], 1, [ [ 1, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 1, 1 ], [ 0, 0, 0, 1 ] ] ], 
  [ [ 1, 2, 2, 1 ], [ f3, f4, f2, f1 ], 2, [ [ 1, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ], [ 0, 1, 1, 1 ] ] ], 
  [ [ 1, 2, 1, 2 ], [ f3, f4, f1*f2, f2 ], 2, [ [ 1, 0, 1, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 1, 0 ], [ 0, 1, 1, 1 ] ] ] ]
gap> XSAMMEL:=StructuralCopy(XSAMMEL1);;
gap> WNUMBIT:=1;
1
gap> RMAXSUCH(G);#time;
?...???
1false[ f3, f1, f4, f2 ] -1 6 [ 1, 1, 2, 2 ] DONNERWETTER ??
2false[ f3, f4, f1, f2 ] 0 6 [ 1, 2, 3, 1 ] ?
3false[ f3, f4, f2, f1 ] 0 6 [ 1, 2, 2, 1 ] ?
4false[ f3, f4, f1*f2, f2 ] 0 6 [ 1, 2, 1, 2 ] ??
4true[ f3, f1*f4, f4, f2 ] 0 3 [ 1, 1, 2, 2 ] .???
4true[ f4, f2, f3, f1 ] 0 2 [ 1, 1, 2, 2 ] ......???
4false[ f3*f4, f4, f1, f2 ] 0 6 [ 1, 2, 1, 2 ] ?
4false[ f3*f4, f4, f2, f1 ] 0 6 [ 1, 2, 2, 2 ] ?
4false[ f3*f4, f4, f1*f2, f2 ] 0 6 [ 1, 2, 3, 1 ] ??
4false[ f3*f4, f1*f2, f4, f2 ] 0 6 [ 1, 1, 2, 2 ] ??
4true[ f3*f4, f1*f2*f4, f4, f2 ] 0 3 [ 1, 1, 2, 2 ] ..... <1> 1
gap> LETZTEWEGELISTE;
[ [ [ 1, 1, 2, 2 ], [ f3, f1, f4, f2 ], 5, [ [ 1, 0, 1, 0 ], [ 0, 1, 1, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ] ], 
  [ [ 1, 2, 1, 2 ], [ f3*f4, f4, f1, f2 ], 0, [ [ 1, 0, 1, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 1, 0 ], [ 0, 1, 1, 1 ] ] ], 
  [ [ 1, 1, 2, 2 ], [ f3*f4, f1*f2, f4, f2 ], 1, [ [ 1, 0, 1, 0 ], [ 0, 1, 1, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ] ], 
  [ [ 1, 2, 3, 1 ], [ f3*f4, f4, f1*f2, f2 ], 2, [ [ 1, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 1, 1 ], [ 0, 0, 0, 1 ] ] ] ]
gap> 
